[{"title":"Babylfsr","url":"/2022/09/12/Babylfsr/","content":"<h2 id=\"例题如下\">1. 例题如下</h2>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"keyword\">from</span> secret <span class=\"keyword\">import</span> KEY,FLAG,MASK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(FLAG==<span class=\"string\">&quot;de1ctf&#123;&quot;</span>+hashlib.sha256(<span class=\"built_in\">hex</span>(KEY)[<span class=\"number\">2</span>:].rstrip(<span class=\"string\">&#x27;L&#x27;</span>)).hexdigest()+<span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(FLAG[<span class=\"number\">7</span>:<span class=\"number\">11</span>]==<span class=\"string\">&#x27;1224&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">LENGTH = <span class=\"number\">256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(KEY.bit_length()==LENGTH)</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(MASK.bit_length()==LENGTH)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">m</span>):</span><br><span class=\"line\">    pad_length = <span class=\"number\">8</span> - <span class=\"built_in\">len</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pad_length*<span class=\"string\">&#x27;0&#x27;</span>+m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">lfsr</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, init, mask, length</span>):</span><br><span class=\"line\">        self.init = init</span><br><span class=\"line\">        self.mask = mask</span><br><span class=\"line\">        self.lengthmask = <span class=\"number\">2</span>**(length+<span class=\"number\">1</span>)-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        nextdata = (self.init &lt;&lt; <span class=\"number\">1</span>) &amp; self.lengthmask </span><br><span class=\"line\">        i = self.init &amp; self.mask &amp; self.lengthmask </span><br><span class=\"line\">        output = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">            output ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            i = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        nextdata ^= output</span><br><span class=\"line\">        self.init = nextdata</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    l = lfsr(KEY,MASK,LENGTH)</span><br><span class=\"line\">    r = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">63</span>):</span><br><span class=\"line\">        b = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">            b = (b&lt;&lt;<span class=\"number\">1</span>)+l.<span class=\"built_in\">next</span>()</span><br><span class=\"line\">        r += pad(<span class=\"built_in\">bin</span>(b)[<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;output&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(r)</span><br></pre></td></tr></table></figure>\r\n<p>另外给的信息为：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分析\">2. 分析</h2>\r\n<p>分析程序，是一个普通的lfsr，但不知道初始KEY和MASK，需要利用给出的另一段信息（504bit），推出所需的MASK和KEY（分别都是256bit）。</p>\r\n<h3 id=\"求掩码\">求掩码</h3>\r\n<p>先考虑如何推出掩码。由于 lfsr 的性质，每一次生成的 bit 都会加到向量的最低位，同时丢弃掉最高位那个 bit. 于是在连续 256 次生成之后，原有的 KEY 所有的位都被丢弃，lfsr 的状态会转为我们已知的 256 个 bit —— 也就是题目所给出的串的前 256 位。从此之后，我们完全知道了 lfsr 的状态，只需要在已知状态的情况下推出掩码了。</p>\r\n<p>设初始KEY为<span class=\"math inline\">\\((a_{0},a_{1},\\cdots,a_{255})\\)</span>，MASK为<span class=\"math inline\">\\((m_0,m_1,\\cdots,m_{255})^{T}\\)</span>，<code>lfsr</code>运算如下： <span class=\"math display\">\\[ { \\begin{pmatrix} a_0&amp; a_1&amp; \\cdots &amp; a_{254} &amp; a_{255} \\\\ a_1&amp; a_2 &amp; \\cdots &amp; a_{255} &amp; o_0 \\\\ \\ddots \\\\ a_{255} &amp; o_0 &amp; \\cdots &amp; o_{253} &amp; o_{254} \\end{pmatrix} \\begin{pmatrix} m_0 \\\\ m_1 \\\\ \\vdots \\\\ m_{255} \\end{pmatrix} = \\begin{pmatrix} o_0 \\\\ o_1 \\\\ \\vdots \\\\ o_{255} \\end{pmatrix} } \\]</span></p>\r\n<p>上面是一个方程；而状态向量有 256 维，我们需要 256 组方程才能解出整个掩码向量。但我们现在只有 504 - 256 = 248 个方程可用，显然秩是不够用的。容易想到，直接猜测 lfsr 此后生成的 8 个 bit，于是就有 256 组方程了；</p>\r\n<p>解方程组的问题可以转化为矩阵求逆的问题。把 lfsr 的状态一行一行地写在矩阵上，形成的矩阵记为 <span class=\"math inline\">\\(A\\)</span> . 把 lsfr 每次所生成的结果也拼成一个向量，记为 <span class=\"math inline\">\\(O\\)</span>. 那么掩码向量 <span class=\"math inline\">\\(m\\)</span> 使得： <span class=\"math display\">\\[A\\cdot m = O\\]</span> 两边左乘 <span class=\"math inline\">\\(A^{-1}\\)</span>，可以得到掩码向量： <span class=\"math display\">\\[m = A^{-1}\\cdot O\\]</span></p>\r\n<p>爆破掩码脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&#x27;001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">padding</span>):</span><br><span class=\"line\">    s = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> x ] + padding</span><br><span class=\"line\">    M = matrix(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">    T = vector(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s) - <span class=\"number\">256</span>):</span><br><span class=\"line\">        M[i] = s[i:i+<span class=\"number\">256</span>]</span><br><span class=\"line\">        T[i] = s[i+<span class=\"number\">256</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        mask = M.inverse() * T</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mask</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> itertools.product([<span class=\"number\">0</span>,<span class=\"number\">1</span>], repeat=<span class=\"number\">8</span>):</span><br><span class=\"line\">    test(<span class=\"built_in\">list</span>(i))</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"求key\">求KEY</h3>\r\n<p>接下来考虑求出初始状态 KEY. 我们目前有的东西是：（猜测的）连续 512 个 lfsr 输出，以及与之对应的掩码。注意到第 256 个输出，是由 KEY 的末位，拼接上前 255 个输出所形成的；第 255 个输出，是由 KEY 的倒数两位，拼接上前 254 个输出所形成的。我们可以先求出 KEY 的末位，再求出倒数第二位……以此类推，整个 KEY 就求出来了。</p>\r\n<p>完整脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&#x27;001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bitAnd</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"keyword\">lambda</span> x,y: <span class=\"built_in\">int</span>(x) &amp; <span class=\"built_in\">int</span>(y), a,b))</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bin2int</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x,y: x*<span class=\"number\">2</span> + y, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">padding</span>):</span><br><span class=\"line\">    s = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> x ] + padding</span><br><span class=\"line\">    M = matrix(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">    T = vector(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s) - <span class=\"number\">256</span>):</span><br><span class=\"line\">        M[i] = s[i:i+<span class=\"number\">256</span>]</span><br><span class=\"line\">        T[i] = s[i+<span class=\"number\">256</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        mask = M.inverse() * T</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    key = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> bitAnd([<span class=\"number\">0</span>] + key + s[<span class=\"number\">0</span>:<span class=\"number\">255</span> - i], mask).count(<span class=\"number\">1</span>) % <span class=\"number\">2</span> == s[<span class=\"number\">255</span>-i]:</span><br><span class=\"line\">            key = [<span class=\"number\">0</span>] + key</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            key = [<span class=\"number\">1</span>] + key</span><br><span class=\"line\">    key = <span class=\"built_in\">hex</span>(bin2int(key))[<span class=\"number\">2</span>:]</span><br><span class=\"line\">    r = hashlib.sha256(key.encode()).hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r[:<span class=\"number\">4</span>] == <span class=\"string\">&#x27;1224&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> itertools.product([<span class=\"number\">0</span>,<span class=\"number\">1</span>], repeat=<span class=\"number\">8</span>):</span><br><span class=\"line\">    test(<span class=\"built_in\">list</span>(i))</span><br><span class=\"line\"><span class=\"comment\"># 1224473d5e349dbf2946353444d727d8fa91da3275ed3ac0dedeb7e6a9ad8619</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意，该题在sage下进行求解。</p>\r\n</blockquote>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"BIRD 入门","url":"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/","content":"<p>BIRD，即BIRD Internet Routing Daemon，是一个开源软件，支持各类标准路由协议，包括BGP，RIP和OSPF。本文主要关注BGP和OSPF协议，下面对其进行简单介绍。</p>\r\n<span id=\"more\"></span>\r\n<p>BIRD配置文件<code>bird.conf</code>位于<code>/etc/bird</code>文件目录下。其配置十分复杂且跟协议相关，详细的配置可参考<a href=\"https://bird.network.cz/\">BIRD manual</a>，本文仅关注Emulator所依赖的features。</p>\r\n<p><strong>BIRD 路由表</strong> 路由协议的主要功能是作为协议参与者与其对等者（peers）交换信息，这些路由信息存放在路由表中。BIRD在内存中存放有数个路由表，这些路由表如何接收或导出其数据被称为<code>protocol</code>。在某些例子中，这些协议是真正的路由协议，如bgp，rip，ospf，将导出或导入到各类路由器的路由表中。但某些协议不是真正的路由协议，BIRD使用<code>protocol</code>关键字，指明BIRD路由表从哪获取路由，并将路由发送何处。这些特殊的<code>protocol</code>用于指明数据如何从一个路由表流向另一个路由表。</p>\r\n<figure>\r\n<img src=\"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/image-20220912212527054-16629891354721.png\" alt=\"image-20220912212527054\"><figcaption aria-hidden=\"true\">image-20220912212527054</figcaption>\r\n</figure>\r\n<h2 id=\"pipe-between-tables\">Pipe Between Tables</h2>\r\n<p>对于IPv4，仅存储在BIRD主表<code>master4</code>中的路由将会被导出到内核的路由表中（通过<code>kernel</code>协议）。如果未指明协议中的表名，将会默认使用master table。对于不同的协议将会使用不同的表名，这些路由将使用<code>pipe</code>协议传送到master table中。</p>\r\n<p><code>pipe</code>协议连接两个路由表，分别为主表（使用<code>table</code>关键字）和次表（使用<code>peer</code>关键字）。在import和export两个方向中可以使用filter过滤路由信息。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol pipe &#123;</span><br><span class=\"line\">\ttable t_bgp;</span><br><span class=\"line\">\tpeer table master4;</span><br><span class=\"line\">\timport none;</span><br><span class=\"line\">\texport all;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述的例子中，所有t_bgp的表项被导出到master4表中，但master4中没有任何路由被导入到t_bgp中。在下列的例子中，所有t_direct表中的路由项被导出到t_bgp表中，且路由的local preference属性设为40。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol pipe &#123;</span><br><span class=\"line\">\ttable t_direct;</span><br><span class=\"line\">\tpeer table t_bgp;</span><br><span class=\"line\">\timport none;</span><br><span class=\"line\">\texport filter &#123; bgp_local_pref = <span class=\"number\">40</span>; accept; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgp路由表与kernel路由表\">BGP路由表与Kernel路由表</h2>\r\n<p>BIRD没有真正用于路由的路由表，真正用于路由的路由表叫kernel路由表，位于系统kernel中，但kernel路由表取决于路由协议学习真正的路由。为此，BIRD提供<code>kernel</code>协议用于连接BIRD的路由表与kernel路由表。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol kernel &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t\texport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlearn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述的例子中，未指定路由表名，因此默认为master表（master4用于IPv4）。“import all”表示BIRD将从kernel路由表导入所有信息到master4表，“export all”表示master4表中所有路由信息将导出到kernel路由表中。</p>\r\n<h2 id=\"device-协议\">device 协议</h2>\r\n<p>每个BGP路由器中都有一个叫<code>device</code>的强制协议，该协议不是真正的路由协议，不生成任何路由，也不接受任何路由。该协议仅用于从kernel中获取网卡信息。在Emulator中，该协议仅为一个empty block。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol device &#123; &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgpas所有的ip前缀\">BGP：AS所有的IP前缀</h2>\r\n<p>在BGP协议中，每个BGP路由器需要告知Internet其代表的自治系统所拥有的网络前缀，告知其他AS本AS是这些IP前缀的所有者。BGP路由器如何知道这些前缀属于自身AS？BGP路由器可以通过以下几种方法获取该信息。</p>\r\n<ol type=\"1\">\r\n<li>从BGP路由器所附加的网络中</li>\r\n<li>从配置文件添加的静态表项中</li>\r\n<li>从IBGP（Interior BGP）和IGP（Internal Gateway Protocol）中，例如从其他属于同一AS的路由器中。</li>\r\n</ol>\r\n<h3 id=\"使用direct协议生成路由\">使用direct协议生成路由</h3>\r\n<p>每个BGP路由器附加在AS的一个或多个内部网络中，因此可以从自身网卡所在的网络中获取IP前缀。BIRD使用<code>direct</code>协议来收集这些IP前缀信息，并且生成相应的路由。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol direct local_nets &#123; <span class=\"meta\"># give it a customized name: local_nets</span></span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_direct;</span><br><span class=\"line\">\t\t<span class=\"meta\"># import all the generated routes to t_direct</span></span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tinterface <span class=\"string\">&quot;eth0&quot;</span>;</span><br><span class=\"line\">\tinterface <span class=\"string\">&quot;eth1&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在<code>direct</code>协议中，<code>interface</code>关键字用于从接口中生成路由。假定BGP路由器分别使用 <em>eth0</em> 和 <em>eth1</em> 连接到自治系统的内部网络 <em>10.150.0.0./24</em> 和 <em>10.150.1.0/24</em> ，direct协议将会生成对于 <em>10.150.0.0./24</em> 和 <em>10.150.1.0/24</em> 的路由项，存储到t_direct表中。 使用<code>birdc show route</code>命令列出每个表中的路由项。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table t direct 10.150.0.0/24</span></span><br><span class=\"line\">Table t_direct:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table t bgp 10.150.0.0/24</span></span><br><span class=\"line\">Table t_bgp:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\">BGP.local_pref: 40</span><br><span class=\"line\">BGP.large_community: (150, 0, 0)</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table master4 10.150.0.0/24</span></span><br><span class=\"line\">Table master4:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\">BGP.local_pref: 40</span><br><span class=\"line\">BGP.large_community: (150, 0, 0)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"从static协议中生成路由\">从static协议中生成路由</h3>\r\n<p>BIRD使用<code>static</code>协议在BGP配置文件中添加静态IP前缀信息，该协议同样不是真正的协议，因为该协议不支持从peer中导入路由，仅提供预定义的路由信息。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol <span class=\"type\">static</span> &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\troute <span class=\"number\">10.150</span><span class=\"number\">.1</span><span class=\"number\">.0</span>/<span class=\"number\">24</span> via <span class=\"number\">10.150</span><span class=\"number\">.0</span><span class=\"number\">.254</span> &#123;</span><br><span class=\"line\">\t\tbgp_large_community.add(LOCAL_COMM);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\troute <span class=\"number\">10.150</span><span class=\"number\">.2</span><span class=\"number\">.0</span>/<span class=\"number\">24</span> blackhole &#123;</span><br><span class=\"line\">\t\tbgp_large_community.add(LOCAL_COMM);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"asn和ip前缀\">ASN和IP前缀</h3>\r\n<p>现实世界中，我们需要知道一个特定的AS所拥有的IP前缀和特定的IP前缀属于哪个AS。可以使用RADB数据库获取该信息。示例如下：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">whois -h whois.radb.net -- <span class=\"string\">&#x27;-i origin AS11872&#x27;</span> | grep route</span></span><br><span class=\"line\">route:      128.230.0.0/16</span><br><span class=\"line\">route:      149.119.0.0/16</span><br><span class=\"line\">route:      128.230.0.0/17</span><br><span class=\"line\">route:      128.230.128.0/17</span><br><span class=\"line\">route:      128.230.0.0/18</span><br><span class=\"line\">route:      128.230.64.0/18</span><br><span class=\"line\">route:      128.230.128.0/18</span><br><span class=\"line\">route:      128.230.192.0/18</span><br><span class=\"line\">route:      128.230.0.0/19</span><br><span class=\"line\">route:      128.230.32.0/19</span><br><span class=\"line\">route:      128.230.64.0/19</span><br><span class=\"line\">route:      128.230.96.0/19</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">whois -h whois.radb.net 110.75.129.5</span></span><br><span class=\"line\">route:          110.75.129.0/24</span><br><span class=\"line\">descr:          Alibaba (US) Technology Co., Ltd.</span><br><span class=\"line\">origin:         AS45102</span><br><span class=\"line\">mnt-by:         MAINT-CNNIC-AP</span><br><span class=\"line\">last-modified:  2020-06-28T00:10:33Z</span><br><span class=\"line\">source:         APNIC</span><br><span class=\"line\"></span><br><span class=\"line\">route:          110.75.129.0/24</span><br><span class=\"line\">descr:          Alibaba (US) Technology Co., Ltd.</span><br><span class=\"line\">origin:         AS37963</span><br><span class=\"line\">mnt-by:         MAINT-CNNIC-AP</span><br><span class=\"line\">last-modified:  2020-06-28T00:09:56Z</span><br><span class=\"line\">source:         APNIC</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgp-peering\">BGP Peering</h2>\r\n<p>在IX-100中，AS-150，AS-151，AS-2，AS-3和AS-4都连接到IX-100网络 <em>0.100.0.0/24</em>。每个自治系统都有BGP路由器连接到该网络中，且属于物理连接，但并不意味着自治系统已经与其他系统进行了对等连接，为了建立对等连接，每个BGP路由器需要设置<code>peering</code>关系。</p>\r\n<figure>\r\n<img src=\"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/Users\\lylan\\Desktop\\resources\\8e5851d6517a45fe8067e76f0b6e0f64.png\" alt=\"IX-100.png\"><figcaption aria-hidden=\"true\">IX-100.png</figcaption>\r\n</figure>\r\n<h3 id=\"建立peering关系\">建立Peering关系</h3>\r\n<p>在两个BGP路由器物理连接后，需要设置BGP peering用于相互通信和交换路由信息。BGP路由器可以建立多个peer，每个叫做 <em>peering session</em>。BIRD使用<code>bgp</code>协议建立 <em>peering session</em>。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp u_as2 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t\timport filter &#123;</span><br><span class=\"line\">\t\t\t... omitted ...</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\texport where ... filter omitted ...</span><br><span class=\"line\">\t\tnext hop self;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.150</span> as <span class=\"number\">150</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>local 选项</strong>：指定了路由器属于哪个AS和路由器的IP地址，该IP地址应当属于IX网络（IX网络段为10.100.0.0/24）。IP地址是可选的，但当路由器具有多个IP地址时，可以避免BGP session选择错误的IP地址。</p>\r\n<p><strong>neighnor 选项</strong>：指定了peer的IP地址和peer所属的AS，该IP地址同样属于IX网络。</p>\r\n<p><strong>IPv4 channel和路由表</strong>：每个协议都通过channel连接到一个路由表。BGP支持IPv4和IPv6 channel，每个channel包含两个filter，分别为import和export filter，能够接收，拒绝和修改路由。</p>\r\n<h3 id=\"import和export-filters\">Import和Export Filters</h3>\r\n<p>当导入和导出路由时，可以使用过滤规则。BIRD包含简单的编程语言，其过滤规则为程序。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">table t_bgp;</span><br><span class=\"line\">import filter &#123;</span><br><span class=\"line\">\tbgp_large_community.add(PROVIDER_COMM);</span><br><span class=\"line\">\tbgp_local_pref = <span class=\"number\">10</span>;</span><br><span class=\"line\">\taccept;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export where bgp_large_community ˜ [LOCAL_COMM, CUSTOMER_COMM];</span><br></pre></td></tr></table></figure>\r\n<p>在上述的例子中，当路由从peer中导入时，社区信息将被添加且local preference值被设为10，当路由导出到peer时，仅属于LOCAL_COMM和CUSTOMER_COMM 社区的路由将会被导出。 路由具有许多属性，filter可以通过预定义的变量访问这些属性，部分预定义变量如下：</p>\r\n<ul>\r\n<li>net：路由网络前缀</li>\r\n<li>bgp_path：路由AS路径</li>\r\n<li>bgp_local_pref：路由的本地preference值，用于路径选择</li>\r\n<li>bgp_next_hop：转发包到目的地的下一跳</li>\r\n<li>bgp_large_community：与路由相关的large 社区值列表</li>\r\n</ul>\r\n<h3 id=\"peering-via-路由服务器\">Peering via 路由服务器</h3>\r\n<p>Internet exchanges提供叫 <code>router server</code>的特别服务器，N个自治系统仅需要连接到该路由服务器便可以互相交换路由信息。<code>route server</code>从BGP的参与者接收到路由时，将会转发其他所有的参与者，其功能类似于多播。 AS-2，AS-3和AS-4通过<code>router server</code>与其他互相连接，其中AS-2 BGP路由器的BGP表项如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp p_rs100 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t\timport filter &#123;</span><br><span class=\"line\">\t\t\tbgp_large_community.add(PREE_COMM);</span><br><span class=\"line\">\t\t\tbgp_local_pref = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t\t\taccept;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\texport where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM];</span><br><span class=\"line\">\t\tnext_hop self;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.100</span> as <span class=\"number\">100</span>; <span class=\"meta\"># peer with the route server</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>router server需要添加所有的AS-2，AS-3和AS-4的peering entry，包含“rs client”选项开启。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp p_as2 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t\texport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trs client;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.100</span> as <span class=\"number\">100</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>; ➙Peer with AS<span class=\"number\">-2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"route-advertisements\">Route Advertisements</h3>\r\n<p>BGP路由器转发其路由消息时，该路由advertisement包含两个section：</p>\r\n<ul>\r\n<li><strong>路径属性</strong>：\r\n<ul>\r\n<li>Origin：定义路由信息来源，如internal或external路由协议</li>\r\n<li>AS Path：AS列表</li>\r\n<li>Next hop：下一跳路由器地址</li>\r\n</ul></li>\r\n<li><strong>网络层可达信息</strong>（NLRI）：从特定路径可达的IP前缀，例如 <em>100.5.0.0./24</em></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Internet Protocol Version 4, Src: 10.100.0.3, Dst: 10.100.0.150</span><br><span class=\"line\">Transmission Control Protocol, Src Port: 179, Dst Port: 33905, ...</span><br><span class=\"line\">Border Gateway Protocol - UPDATE Message</span><br><span class=\"line\">\tMarker: ffffffffffffffffffffffffffffffff</span><br><span class=\"line\">\tLength: 94</span><br><span class=\"line\">\tType: UPDATE Message (2)</span><br><span class=\"line\">\tWithdrawn Routes Length: 0</span><br><span class=\"line\">\tTotal Path Attribute Length: 67</span><br><span class=\"line\">\tPath attributes</span><br><span class=\"line\">\t\tPath Attribute - ORIGIN: IGP</span><br><span class=\"line\">\t\tPath Attribute - AS PATH: 3 12 164</span><br><span class=\"line\">\t\tPath Attribute - NEXT HOP: 10.100.0.3</span><br><span class=\"line\">\t\tPath Attribute - LARGE_COMMUNITY: 3:1:0 12:1:0 164:0:0</span><br><span class=\"line\">\tNetwork Layer Reachability Information (NLRI)</span><br><span class=\"line\">\t\t10.164.0.0/24</span><br><span class=\"line\">\t\t\tNLRI prefix length: 24</span><br><span class=\"line\">\t\t\tNLRI prefix: 10.164.0.0</span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["bird","network"]},{"title":"CBC反转攻击","url":"/2022/09/12/CBC%E5%8F%8D%E8%BD%AC%E6%94%BB%E5%87%BB/","content":"<h2 id=\"cbc-反转攻击\">CBC 反转攻击</h2>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>查看文件内容</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">flag = <span class=\"string\">&#x27;DASCTF&#123;********************************&#125;&#x27;</span></span><br><span class=\"line\">BLOCKSIZE = <span class=\"number\">16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    pad_len = BLOCKSIZE - (<span class=\"built_in\">len</span>(data) %</span><br><span class=\"line\">                        BLOCKSIZE) <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(data) % BLOCKSIZE != <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data + <span class=\"string\">&quot;=&quot;</span> * pad_len</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">unpad</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.replace(<span class=\"string\">&quot;=&quot;</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enc</span>(<span class=\"params\">data, key, iv</span>):</span><br><span class=\"line\">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class=\"line\">    encrypt = cipher.encrypt(pad(data))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> encrypt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dec</span>(<span class=\"params\">data, key, iv</span>):</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class=\"line\">        encrypt = cipher.decrypt(data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unpad(encrypt)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        key = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">        iv = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">        pre = <span class=\"string\">&quot;yusa&quot;</span>*<span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">            choice = raw_input(menu)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> choice == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                name = raw_input(<span class=\"string\">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;admin&#x27;</span>:</span><br><span class=\"line\">                    exit()</span><br><span class=\"line\">                token = enc(pre+name, key, iv)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&quot;Here is your token(in hex): &quot;</span>+iv.encode(<span class=\"string\">&#x27;hex&#x27;</span>)+token.encode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> choice == <span class=\"string\">&#x27;2&#x27;</span>:</span><br><span class=\"line\">                token = raw_input(<span class=\"string\">&quot;Your token(in hex): &quot;</span>).decode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                iv = token[:<span class=\"number\">16</span>]</span><br><span class=\"line\">                name = dec(token[<span class=\"number\">16</span>:], key, iv)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> iv.encode(<span class=\"string\">&#x27;hex&#x27;</span>)+name.encode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name[:<span class=\"number\">16</span>] == <span class=\"string\">&quot;yusa&quot;</span>*<span class=\"number\">4</span>:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span> <span class=\"string\">&quot;Hello, &quot;</span>+name[<span class=\"number\">16</span>:]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> name[<span class=\"number\">16</span>:] == <span class=\"string\">&#x27;admin&#x27;</span>:</span><br><span class=\"line\">                        <span class=\"built_in\">print</span> flag</span><br><span class=\"line\">                        exit()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\">menu = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">1. register</span></span><br><span class=\"line\"><span class=\"string\">2. login</span></span><br><span class=\"line\"><span class=\"string\">3. exit</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    task()</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>攻击思路 题目提示为CBC反转攻击，需要了解CBC反转攻击原因 <img src=\"/2022/09/12/CBC%E5%8F%8D%E8%BD%AC%E6%94%BB%E5%87%BB/27c02823d6c18308ea47bd1f21558f8b.png\" alt=\"27c02823d6c18308ea47bd1f21558f8b.png\"> 用户能够控制IV和密文输入，<span class=\"math inline\">\\(plain2 = cipher1 \\oplus Dec(cipher)\\)</span>，当用户的密文输入为<span class=\"math inline\">\\(cipher1 \\oplus plain2 \\oplus [tamperd]\\)</span>时，解密的<code>plain2</code>则被修改为 <span class=\"math display\">\\[\r\n cipher1 \\oplus plain2 \\oplus [tamperd] \\oplus Dec(cipher) = \\\\\r\n cipher1 \\oplus Dec(cipher) \\oplus plain2 \\oplus [tamperd] = \\\\\r\n plain2 \\oplus plain2 \\oplus [tamperd] =[tamperd]\r\n \\]</span> 因此，可以将login返回的token（iv和token）分别进行修改</p>\r\n<p><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">token = `xxxxxx`</span><br><span class=\"line\">iv = token[:32]</span><br><span class=\"line\">c1 = token[32:64]</span><br><span class=\"line\">c2 = token[64:]</span><br><span class=\"line\">s1 = c1 ^ 原文2 ^ 篡改内容</span><br><span class=\"line\"></span><br><span class=\"line\">token2 = send(iv+s1+c2)</span><br><span class=\"line\">s2 = token[:32] ^ 原文1 ^ iv</span><br><span class=\"line\">send(s2 + s1 + c2)</span><br></pre></td></tr></table></figure></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"Easy RSA","url":"/2022/09/12/Easy-RSA/","content":"<h2 id=\"easy-rsa\">Easy RSA</h2>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>打开py文件，发现内容为：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">from</span> flag <span class=\"keyword\">import</span> flag</span><br><span class=\"line\"></span><br><span class=\"line\">p = getPrime(<span class=\"number\">1024</span>)</span><br><span class=\"line\">r = random.randint(<span class=\"number\">2</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">e =<span class=\"number\">65537</span></span><br><span class=\"line\">n=p**r</span><br><span class=\"line\">m=flag</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"built_in\">int</span>(m.encode(<span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"number\">16</span>) &lt; n)</span><br><span class=\"line\">c = <span class=\"built_in\">pow</span>(<span class=\"built_in\">int</span>(m.encode(<span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"number\">16</span>),e,n)</span><br><span class=\"line\">c=long_to_bytes(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;c =\\n&#x27;</span>, c.encode(<span class=\"string\">&#x27;base64&#x27;</span>),n</span><br></pre></td></tr></table></figure></p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">c =</span><br><span class=\"line\">apxy3z3DgGnzaEedcUy3A49wAsqyyn9sqx6eYZL5iDrCq0Wjs8BOY2Ofza5wuaFigm32PVpO5jpu</span><br><span class=\"line\">Dgw9b6oX8KM2ZB9/dDmwQc7JKnAKhCQrIc1v9qt7iQbnTK0DTQj/xvQkz/IBeSjoWBmHOx4s0tDx</span><br><span class=\"line\">ZRAjOPui5wwAywNM3ynULEPczv+xN2v+6HBeoS2YuyfF5mq/pIAMPwZs+QpkuwxSbNQ6xPNP9Ox1</span><br><span class=\"line\">IeKz/41F7/D2fDsGB5CcFdAiQq+r95BhVeGzeaiQBpzwAXAPKIyO+fP6/M9XmpSJwjaMSiAUnksp</span><br><span class=\"line\">9KfVOXgEG9Z0FmxP6rgqPl0vU+rVeJ2RsTUYCSP8Vy+PD3PGwDDdUtNzvcEXKr2BKiNoOUxprBAt</span><br><span class=\"line\">yvcsmGqRLgDl1ZVgzSZ1U4MAmJ9x42mIU0XvolqaOCJZzaym1kJoBlw7/<span class=\"number\">7</span>+Nej4owEtan/c3TIkD</span><br><span class=\"line\">kr/gCenUD/8MSlvnfTUMGdQLkSht2BZiuiHxVVRVzY5ETG6v+w9AtDMC</span><br><span class=\"line\"><span class=\"number\">4600616808891590817884946117009414083548013610469076381106568481948720521467073218024827360073980550620353792084520767372304347132535784875671026563160583598386773718586111034826555689602824563172463446924287072570386712719870348862904936370894695108302490867826094352072132696743116741635111860205049129717948520534270924834318704244999690532431941248905257880347561221151841978982240191397364038490250930604211256385925496658620755582058753376328583001312846508295319286941837220522563729215928111164274042890696771820759856790994461944209269732769269559257608440686713206622111649275898426040931301005711446055819707704086201357712959922814300067907536161841255533171805313149332383712997091780368142625499055149806043238057037400510197255364471685815004154357049874205884682322443391374020169114833722616851257895369648472048116320266548560787733764126281102645474252013714507014577620450816459153848279084910457288549191</span></span><br></pre></td></tr></table></figure></p>\r\n<p>分析文件中代码题意，可以看出p为1024位的质数，r取值范围为[2,9]，指数e为65537，模数 <span class=\"math inline\">\\(n=p^r\\)</span>，且题中已给出密文c和模数n，因此可以爆破求解出r，得到r之后，可以求出p，由于n的素因子只有p，则 <span class=\"math inline\">\\(\\phi(n) = n *(1- \\frac{1}{p}) = p^r* (1- \\frac{1}{p}) = p^r - p^{r-1}\\)</span></p>\r\n<blockquote>\r\n<p><span class=\"math inline\">\\(\\phi(n)\\)</span>的含义为小于n且与n互素的整数的个数，<span class=\"math inline\">\\(\\phi(n)\\)</span>求法为，列出n的所有素因子，设为 <span class=\"math inline\">\\(p_1,p_2,p_3,...,p_n\\)</span>，则 <span class=\"math inline\">\\(\\phi(n)=n\\times(1-\\frac{1}{p_1})\\times(1-\\frac{1}{p_2})\\times\\cdots\\times(1-\\frac{1}{p_n})\\)</span> 当n素因子为 <span class=\"math inline\">\\(p, q\\)</span> 时，<span class=\"math inline\">\\(\\phi(n)=(p-1)\\times(q-1)\\)</span></p>\r\n</blockquote></li>\r\n<li><p>编写py代码如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Cryptodome.Util.number <span class=\"keyword\">import</span> long_to_bytes, bytes_to_long</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\">c = <span class=\"string\">&#x27;&#x27;&#x27;apxy3z3DgGnzaEedcUy3A49wAsqyyn9sqx6eYZL5iDrCq0Wjs8BOY2Ofza5wuaFigm32PVpO5jpuDgw9b6oX8KM2ZB9/dDmwQc7JKnAKhCQrIc1v9qt7iQbnTK0DTQj/xvQkz/IBeSjoWBmHOx4s0tDxZRAjOPui5wwAywNM3ynULEPczv+xN2v+6HBeoS2YuyfF5mq/pIAMPwZs+QpkuwxSbNQ6xPNP9Ox1IeKz/41F7/D2fDsGB5CcFdAiQq+r95BhVeGzeaiQBpzwAXAPKIyO+fP6/M9XmpSJwjaMSiAUnksp9KfVOXgEG9Z0FmxP6rgqPl0vU+rVeJ2RsTUYCSP8Vy+PD3PGwDDdUtNzvcEXKr2BKiNoOUxprBAtyvcsmGqRLgDl1ZVgzSZ1U4MAmJ9x42mIU0XvolqaOCJZzaym1kJoBlw7/7+Nej4owEtan/c3TIkDkr/gCenUD/8MSlvnfTUMGdQLkSht2BZiuiHxVVRVzY5ETG6v+w9AtDMC&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">n = <span class=\"number\">4600616808891590817884946117009414083548013610469076381106568481948720521467073218024827360073980550620353792084520767372304347132535784875671026563160583598386773718586111034826555689602824563172463446924287072570386712719870348862904936370894695108302490867826094352072132696743116741635111860205049129717948520534270924834318704244999690532431941248905257880347561221151841978982240191397364038490250930604211256385925496658620755582058753376328583001312846508295319286941837220522563729215928111164274042890696771820759856790994461944209269732769269559257608440686713206622111649275898426040931301005711446055819707704086201357712959922814300067907536161841255533171805313149332383712997091780368142625499055149806043238057037400510197255364471685815004154357049874205884682322443391374020169114833722616851257895369648472048116320266548560787733764126281102645474252013714507014577620450816459153848279084910457288549191</span></span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\">c = bytes_to_long(base64.b64decode(c))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i  <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">p = gmpy2.iroot(n,i)</span><br><span class=\"line\"><span class=\"keyword\">if</span> p[<span class=\"number\">1</span>]:</span><br><span class=\"line\"><span class=\"keyword\">break</span></span><br><span class=\"line\">p  = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(p[<span class=\"number\">0</span>]))</span><br><span class=\"line\">phi_n = n-(p**(i-<span class=\"number\">1</span>))</span><br><span class=\"line\">d = gmpy2.invert(e,phi_n)</span><br><span class=\"line\">m = gmpy2.powmod(c,d,p**i)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure></p>\r\n<p>得到flag为<code>flag&#123;7422e7ed91c8089a1f2aa323a6a0a6f9&#125;</code></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"RSA 算法各类攻击","url":"/2022/09/12/RSA-%E7%AE%97%E6%B3%95%E5%90%84%E7%B1%BB%E6%94%BB%E5%87%BB/","content":"<h2 id=\"dp泄漏\">dp泄漏</h2>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>基本数学公式 <span class=\"math display\">\\[a = kb + p\\]</span> <span class=\"math display\">\\[a\\mod b = p\\]</span> 已知条件：<span class=\"math inline\">\\(dp, n, e, c\\)</span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"rsa的基本公式\">RSA的基本公式</h3>\r\n<p><span class=\"math display\">\\[c \\equiv m^e\\mod n\\]</span> <span class=\"math display\">\\[m \\equiv c^d\\mod n\\]</span> <span class=\"math display\">\\[\\phi ( n ) = ( p - 1 ) \\times ( q - 1 ) \\]</span> <span class=\"math display\">\\[d \\times e \\equiv 1\\mod \\phi( n )\\]</span></p>\r\n<h3 id=\"dp是什么\">dp是什么</h3>\r\n<p><span class=\"math display\">\\[dp \\equiv d\\mod( p − 1 )\\]</span></p>\r\n<h3 id=\"推导过程\">推导过程</h3>\r\n<p>将该公式变形：</p>\r\n<p><span class=\"math display\">\\[dp \\equiv d\\mod ( p − 1 )\\\\\r\n\\Rightarrow dp \\times e\\equiv d \\times e \\mod (p-1)\\\\\r\n\\Rightarrow d \\times e \\equiv k \\times (p-1) + dp \\times e\\]</span></p>\r\n<p>变形后的公式与下式结合</p>\r\n<p><span class=\"math display\">\\[d\\times e \\equiv1mod\\phi (n)\\]</span></p>\r\n<p>因为：</p>\r\n<p><span class=\"math display\">\\[\\phi(n)=(p-1)\\times(q-1)\\]</span></p>\r\n<p>所以我们可以进行变形：</p>\r\n<p><span class=\"math display\">\\[\\Rightarrow d\\times e \\equiv 1\\mod(p-1) \\times (q-1)\\]</span></p>\r\n<p>得到：</p>\r\n<p><span class=\"math display\">\\[ k \\times (p-1) + dp \\times e=1mod\\phi (n)\\]</span></p>\r\n<p>再次变形：</p>\r\n<p><span class=\"math display\">\\[k_1 \\times (p-1) + dp \\times e =1mod (p-1)\\times(q-1)\\]</span></p>\r\n<p>结合：</p>\r\n<p><span class=\"math display\">\\[k_1 \\times (p-1) + dp \\times e = k_2 \\times (p-1) \\times (q-1) +1\\\\\r\n\\Rightarrow dp \\times e = [k_2 \\times (p-1) \\times (q-1) +1] - [k_1 \\times (p-1)]\\\\ \\Rightarrow dp \\times e = [k_2 \\times (q-1) - k_1] \\times (p-1) +1\\]</span></p>\r\n<p>设：<span class=\"math inline\">\\(X = k_2 \\times (q-1) - k_1\\)</span> <span class=\"math display\">\\[\\Rightarrow dp \\times e = X \\times (p-1) +1\\\\\r\n\\Rightarrow dp &lt; p-1\\\\\r\n\\Rightarrow X &lt; e\\\\\r\n\\Rightarrow X \\in (0,e)\\]</span></p>\r\n<h3 id=\"求p\">求P</h3>\r\n<p>遍历X（65537种可能），求出p-1，得到p且能被n整除，接下来便是常规的RSA解法</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">65538</span>):</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (dp*e-<span class=\"number\">1</span>) % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">      p = (dp*e-<span class=\"number\">1</span>)//i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % p == <span class=\"number\">0</span>:</span><br><span class=\"line\">            q = n // p</span><br><span class=\"line\">            phi_n = (p-<span class=\"number\">1</span>)*(q-<span class=\"number\">1</span>)</span><br><span class=\"line\">            d = gmpy2.invert(e, phi_n)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"dpdq泄漏\">dp,dq泄漏</h2>\r\n<h3 id=\"已知条件\">已知条件</h3>\r\n<p>公式如下：</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\\ c\\equiv m^e\\mod n\\\\\r\nm\\equiv c^d\\mod n\\\\\r\n\\phi(n)=(p-1)\\times(q-1)\\\\\r\nd\\times e\\equiv 1\\mod\\phi(n)\\\\\r\ndp\\equiv d\\mod(p-1)\\\\\r\ndq\\equiv d\\mod(q-1)\\end{align}\\]</span> 已知 <span class=\"math inline\">\\(c,e,dp,dq\\)</span>，求 <span class=\"math inline\">\\(m\\)</span></p>\r\n<h3 id=\"公式推导\">公式推导</h3>\r\n<p>利用中国剩余定理，可以得到</p>\r\n<p><span class=\"math display\">\\[\\begin{align}m_1\\equiv c^d\\mod p\\\\\r\nm_2\\equiv c^d\\mod q\\end{align}\\]</span> 由公式7可得 <span class=\"math display\">\\[\\begin{align}c^d=m_1+p*k\\end{align}\\]</span> 代入公式8，可得 <span class=\"math display\">\\[\\begin{align}m_2\\equiv (m_1+p*k)\\mod q\\end{align}\\]</span> 将两边同时减去<span class=\"math inline\">\\(m_1\\)</span> <span class=\"math display\">\\[\\begin{align}m_2-m_1\\equiv pk\\mod q\\end{align}\\]</span> 因为 <span class=\"math inline\">\\(gcd(p,q)=1\\)</span>，可求p的逆元，得到 <span class=\"math display\">\\[\\begin{align}(m_2-m_1)*p^{-1}\\equiv k\\mod q\\\\\r\n\\Rightarrow k\\equiv (m_2-m_1)*p^{-1}\\mod q\\end{align}\\]</span> 将公式9和公式13合并，得到 <span class=\"math display\">\\[\\begin{align}c^d=((m_2-m_1)*p^{-1}\\mod q)*p+m_1\\end{align}\\]</span> 代入公式2，得到 <span class=\"math display\">\\[\\begin{align}m\\equiv(((m_2-m_1)*p^{-1}\\mod q)*p+m_1)\\mod n\\end{align}\\]</span> 将公式5，6分别代入7，8，得到 <span class=\"math display\">\\[\\begin{align}m_1\\equiv c^{dq\\mod(q-1)}\\mod q\\\\\r\nm_2\\equiv c^{dp\\mod(p-1)}\\mod p\\end{align}\\]</span> 得到 <span class=\"math display\">\\[\\begin{align}m_1\\equiv c^{dq}\\mod q\\\\\r\nm_2\\equiv c^{dp}\\mod p\\end{align}\\]</span> 算出 <span class=\"math inline\">\\(m_1,m_2\\)</span> 后，代入公式15，即可求出 <span class=\"math inline\">\\(m\\)</span></p>\r\n<h3 id=\"求解代码\">求解代码</h3>\r\n<p>编写代码如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">m1 = gmpy2.powmod(c, dq, q)</span><br><span class=\"line\">m2 = gmpy2.powmod(c, dp, p)</span><br><span class=\"line\">m = (((m2-m1) * gmpy2.invert(p, q) % q) * p + m1) % n</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"共模攻击\">共模攻击</h2>\r\n<h3 id=\"已知条件-1\">已知条件</h3>\r\n<p>已知：<span class=\"math inline\">\\(c_1,c_2,e_1,e_2,n\\)</span> <span class=\"math display\">\\[\\begin{align}\r\nc_1=m^{e_1}\\mod n\\\\\r\nc_2 = m^{e_2}\\mod n\r\n\\end{align}\\]</span></p>\r\n<h3 id=\"公式推导-1\">公式推导</h3>\r\n<p>首先假设 <span class=\"math inline\">\\(gcd(e_1,e_2)=1\\)</span>，此时则有 <span class=\"math inline\">\\(k_1*e_1+k_2*e_2=1\\)</span>，可以得到 <span class=\"math display\">\\[\\begin{align*}\r\n(c_1^{k_1}*c_2^{k_2})\\mod n &amp; = ((m^{e_1}\\mod n)^{k_1}*(m^{e_2}\\mod n)^{k_2})\\mod n\\\\\r\n&amp; = ((m^{e_1})^{k_1}*(m^{e_2})^{k_2})\\mod n\\\\\r\n&amp; = ((m^{e_1k_1}*(m^{e_2k_2})\\mod n\\\\\r\n&amp; = m^{e_1k_1+e_2k_2}\\mod n\\\\\r\n&amp; = m\\mod n\r\n\\end{align*}\\]</span></p>\r\n<h3 id=\"求解代码-1\">求解代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">common_n_attack</span>(<span class=\"params\">n,e1,e2,c1,c2</span>):</span><br><span class=\"line\">   _,k1,k2 = gmpy2.gcdext(e1, e2)</span><br><span class=\"line\">   <span class=\"keyword\">if</span> k1 &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      k1 = -k1</span><br><span class=\"line\">      c1 = gmpy2.invert(c1, n)</span><br><span class=\"line\">   <span class=\"keyword\">elif</span> k2 &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      k2 = -k2</span><br><span class=\"line\">      c2 = gmpy2.invert(c2, n)</span><br><span class=\"line\">   m = (c1**k1*c2**k2)%n</span><br><span class=\"line\">   <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\r\n","categories":["CTF"],"tags":["crypto","RSA"]},{"title":"weak DSA","url":"/2022/09/12/weak-DSA/","content":"<h2 id=\"weak-dsa\">weak DSA</h2>\r\n<ol type=\"1\">\r\n<li><p>题目： 打开附件，看到存在五个文件</p>\r\n<p><span id=\"more\"></span></p>\r\n<p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ll</span></span><br><span class=\"line\">总用量 24</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  653  2月 20  2019 dsa_public.pem</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  514  2月 20  2019 message1</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  374  2月 20  2019 message2</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt   46  2月 20  2019 sign1</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt   46  2月 20  2019 sign2</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt 1376  2月 20  2019 tipcode.py</span><br></pre></td></tr></table></figure></p>\r\n<p>题目意思为弱DSA签名算法，判断用同一个K参数进行签名，并提供了2个message和2个sign签名文件。</p></li>\r\n<li><p>解题</p>\r\n<ul>\r\n<li>使用openssl命令查看文件签名</li>\r\n</ul>\r\n<p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">openssl asn1parse -inform der -<span class=\"keyword\">in</span> sign1</span> </span><br><span class=\"line\">    0:d=0  hl=2 l=  44 cons: SEQUENCE          </span><br><span class=\"line\">    2:d=1  hl=2 l=  20 prim: INTEGER           :3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span><br><span class=\"line\">24:d=1  hl=2 l=  20 prim: INTEGER           :2C507D83CC9DB08B3D13B059A37B846189D32EC8</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">openssl asn1parse -inform der -<span class=\"keyword\">in</span> sign2</span></span><br><span class=\"line\">    0:d=0  hl=2 l=  44 cons: SEQUENCE          </span><br><span class=\"line\">    2:d=1  hl=2 l=  20 prim: INTEGER           :3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span><br><span class=\"line\">24:d=1  hl=2 l=  20 prim: INTEGER           :704302989E4D680DEDF760E354C1F23760FA95BE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>第一项内容为r，后一内容为s，可以看出sign1和sign2共享了密钥k，因为其r值<code>3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</code>一致。</p>\r\n<ul>\r\n<li>查看公钥文件内容</li>\r\n</ul>\r\n<p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ openssl dsa -<span class=\"keyword\">in</span> dsa_public.pem -text -noout -pubin</span><br><span class=\"line\"><span class=\"built_in\">read</span> DSA key</span><br><span class=\"line\">pub: </span><br><span class=\"line\">    5e:ef:ca:12:9c:84:b4:3d:e1:d0:1e:c4:d3:85:b4:</span><br><span class=\"line\">    48:b8:e2:c2:77:fb:49:e0:01:d1:1b:f9:18:43:<span class=\"built_in\">fc</span>:</span><br><span class=\"line\">    da:5a:31:99:0e:93:67:d2:19:49:d2:1d:14:23:45:</span><br><span class=\"line\">    23:a7:1a:22:69:92:85:a9:f9:37:17:f8:57:c0:4e:</span><br><span class=\"line\">    73:73:03:c1:aa:f3:35:38:9d:ba:af:5a:3b:4d:27:</span><br><span class=\"line\">    a8:3f:03:5d:02:5a:da:27:b6:d7:0c:52:<span class=\"built_in\">fc</span>:78:a1:</span><br><span class=\"line\">    67:41:01:84:b2:46:82:f0:d6:5b:43:05:2b:ab:05:</span><br><span class=\"line\">    38:6b:50:d6:fa:be:3b:<span class=\"built_in\">df</span>:89:<span class=\"built_in\">df</span>:bb:72:51:48:ab:</span><br><span class=\"line\">    d4:9e:a2:63:2c:7d:3b:7d</span><br><span class=\"line\">P:   </span><br><span class=\"line\">    00:bb:65:76:c4:bd:9b:1e:64:9f:dc:1b:5f:0d:35:</span><br><span class=\"line\">    ae:db:c0:c0:85:bb:3c:cf:d7:1a:a7:9f:e9:d4:29:</span><br><span class=\"line\">    12:23:3c:84:a0:d2:e5:bc:d7:7d:fb:a3:bb:3d:27:</span><br><span class=\"line\">    b2:bd:db:a6:e7:21:72:f6:6b:94:d1:f6:11:86:d2:</span><br><span class=\"line\">    6f:ee:44:38:f9:71:1f:d5:a2:96:e3:09:e3:bd:76:</span><br><span class=\"line\">    a6:7d:88:77:2f:1b:2e:fe:77:66:77:24:49:81:da:</span><br><span class=\"line\">    55:27:5a:2f:99:0e:8f:b3:1a:18:5d:dc:<span class=\"built_in\">fc</span>:4b:b4:</span><br><span class=\"line\">    15:65:67:fa:6b:62:a0:e7:26:74:<span class=\"built_in\">fc</span>:92:db:ef:8c:</span><br><span class=\"line\">    7e:cb:fe:95:88:3f:04:4f:c5</span><br><span class=\"line\">Q:   </span><br><span class=\"line\">    00:8a:92:14:5a:fa:41:1f:5d:90:51:ef:a4:a3:74:</span><br><span class=\"line\">    3a:c9:98:85:76:7d</span><br><span class=\"line\">G:   </span><br><span class=\"line\">    05:fb:e9:06:39:a3:b2:f3:36:8d:4d:47:fd:f2:42:</span><br><span class=\"line\">    8c:e3:80:<span class=\"built_in\">cd</span>:8e:84:ae:fe:90:eb:4a:fd:21:2a:99:</span><br><span class=\"line\">    a9:59:3e:b0:1f:f6:d6:26:48:a0:16:67:bf:f9:72:</span><br><span class=\"line\">    4e:4b:01:96:6e:f6:0b:f1:b2:77:6d:a2:a1:81:a2:</span><br><span class=\"line\">    6e:5e:60:8f:ff:94:a3:e3:92:38:4a:cf:62:1c:23:</span><br><span class=\"line\">    e4:93:b6:3c:24:7c:30:b3:ea:<span class=\"built_in\">dd</span>:e4:0d:4c:36:e5:</span><br><span class=\"line\">    55:27:31:8a:84:d5:87:16:2c:d7:40:5d:66:85:22:</span><br><span class=\"line\">    60:23:8c:48:3e:72:bf:10:71:85:10:7a:6e:43:76:</span><br><span class=\"line\">    90:58:77:bc:82:8c:1d:20</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>编写脚本如下：</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> DSA</span><br><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha1</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;dsa_public.pem&#x27;</span>) <span class=\"keyword\">as</span> f: <span class=\"comment\"># 读取公钥文件</span></span><br><span class=\"line\">    key = DSA.import_key(f.read())</span><br><span class=\"line\">    y = key.y</span><br><span class=\"line\">    g = key.g</span><br><span class=\"line\">    p = key.p</span><br><span class=\"line\">    q = key.q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;message1&#x27;</span>, encoding = <span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data1 = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;message2&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data2 = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">sha = sha1() <span class=\"comment\"># sha1 hash</span></span><br><span class=\"line\">sha.update(data1.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">m1 = <span class=\"built_in\">int</span>(sha.hexdigest(), <span class=\"number\">16</span>) <span class=\"comment\"># 获取message1内容sha1哈希值</span></span><br><span class=\"line\"></span><br><span class=\"line\">sha = sha1()</span><br><span class=\"line\">sha.update(data2.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">m2 = <span class=\"built_in\">int</span>(sha.hexdigest(), <span class=\"number\">16</span>) <span class=\"comment\"># 获取message2内容sha1哈希值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(m1, m2)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 = <span class=\"number\">0x2C507D83CC9DB08B3D13B059A37B846189D32EC8</span> <span class=\"comment\"># 签名文件sign1 s 值</span></span><br><span class=\"line\">s2 = <span class=\"number\">0x704302989E4D680DEDF760E354C1F23760FA95BE</span> <span class=\"comment\"># 签名文件sign2 s 值</span></span><br><span class=\"line\">r = <span class=\"number\">0x3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span></span><br><span class=\"line\"></span><br><span class=\"line\">ds = s2 - s1</span><br><span class=\"line\">dm = m2 - m1</span><br><span class=\"line\">k = gmpy2.mul(dm, gmpy2.invert(ds, q))</span><br><span class=\"line\">k = gmpy2.f_mod(k, q)</span><br><span class=\"line\">tmp = gmpy2.mul(k, s1) - m1</span><br><span class=\"line\">x = tmp * gmpy2.invert(r,q)</span><br><span class=\"line\">x = gmpy2.f_mod(x, q) <span class=\"comment\"># x is the private key</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(x))</span><br></pre></td></tr></table></figure>\r\n<p>脚本运行结果如下：</p>\r\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./exp.py </span><br><span class=\"line\">292662942869370611771676609473484271930756369187 94408533737537379184444430172035752205145606426</span><br><span class=\"line\">301024118086430365762957779330181182629483123408</span><br></pre></td></tr></table></figure></p>\r\n<p>因此flag为<code>301024118086430365762957779330181182629483123408</code></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto","DSA"]},{"title":"分组加密模式","url":"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","content":"<p>There are five types of operations in block cipher modes, ECB (Electronic Code Block) mode, CBC (Cipher Block Chaining) mode, CFB (Cipher Feedback) mode, OFB (Output Feedback) mode and CTR ( Counter) mode.</p>\r\n<span id=\"more\"></span>\r\n<p>Where ECB and CBC mode works on block ciphers, and CFB and OFB mode works on block ciphers acting as stream ciphers. ECB is used for transmitting a single value insecure manner, CBC is used for encrypting blocks of text authentication, CFB is used for transmitting an encrypted stream of data authentication, OFB is used for transmitting an encrypted stream of data, CTR is used for transmitting block-oriented applications.</p>\r\n<h2 id=\"block-cipher-modes-of-operation\">Block cipher modes of operation</h2>\r\n<p>There are 5 modes of operation in the block cipher.</p>\r\n<h3 id=\"ecb-mode\">1. ECB mode</h3>\r\n<p>ECB mode stands for Electronic Code Block Mode. It is one of the simplest modes of operation. In this mode, the plain text is divided into a block where each block is 64 bits. Then each block is encrypted separately. The same key is used for the encryption of all blocks. Each block is encrypted using the key and makes the block of ciphertext.</p>\r\n<ul>\r\n<li>At the receiver side, the data is divided into a block, each of 64 bits. The same key which is used for encryption is used for decryption. It takes the 64-bit ciphertext and, by using the key convert the ciphertext into plain text.</li>\r\n<li>As the same key is used for all blocks’ encryption, if the block of plain text is repeated in the original message, then the ciphertext’s corresponding block will also repeat. As the same key used for tor all block, to avoid the repetition of block ECB mode is used for an only small message where the repetition of the plain text block is less.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/b13d6ff681264bd9afeb423dec608e63.webp\" alt=\"ecb\"><figcaption aria-hidden=\"true\">ecb</figcaption>\r\n</figure>\r\n<h3 id=\"cbc-mode\">2. CBC Mode</h3>\r\n<ul>\r\n<li>CBC Mode stands for Cipher block Mode at the sender side; the plain text is divided into blocks. In this mode, IV(Initialization Vector) is used, which can be a random block of text. IV is used to make the ciphertext of each block unique.</li>\r\n<li>The first block of plain text and IV is combined using the XOR operation and then encrypted the resultant message using the key and form the first block of ciphertext. The first block of ciphertext is used as IV for the second block of plain text. The same procedure will be followed for all blocks of plain text.</li>\r\n<li>At the receiver side, the ciphertext is divided into blocks. The first block ciphertext is decrypted using the same key, which is used for encryption. The decrypted result will be XOR with the IV and form the first block of plain text. The second block of ciphertext is also decrypted using the same key, and the result of the decryption will be XOR with the first block of ciphertext and form the second block of plain text. The same procedure is used for all the blocks.</li>\r\n<li>CBC Mode ensures that if the block of plain text is repeated in the original message, it will produce a different ciphertext for corresponding blocks.<br>\r\nNote that the key which is used in CBC mode is the same; only the IV is different, which is initialized at a starting point.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/d2a42bc7495942afa81b2a6ca78d27ac.webp\" alt=\"cbc\"><figcaption aria-hidden=\"true\">cbc</figcaption>\r\n</figure>\r\n<h3 id=\"cfb-mode\">3. CFB Mode</h3>\r\n<ul>\r\n<li>CFB mode stands for Cipher Feedback Mode. In this mode, the data is encrypted in the form of units where each unit is of 8 bits.</li>\r\n<li>Like cipher block chaining mode, IV is initialized. The IV is kept in the shift register. It is encrypted using the key and form the ciphertext.</li>\r\n<li>Now the leftmost j bits of the encrypted IV is XOR with the plain text’s first j bits. This process will form the first part of the ciphertext, and this ciphertext will be transmitted to the receiver.</li>\r\n<li>Now the bits of IV is shifted left by j bit. Therefore the rightmost j position of the shift register now has unpredictable data. These rightmost j positions are now filed with the ciphertext. The process will be repeated for all plain text units.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/9561710becb4435c98e0b8ada546747d.webp\" alt=\"9561710becb4435c98e0b8ada546747d\"><figcaption aria-hidden=\"true\">9561710becb4435c98e0b8ada546747d</figcaption>\r\n</figure>\r\n<h3 id=\"ofb-mode\">4. OFB mode</h3>\r\n<ul>\r\n<li>OFB Mode stands for output feedback Mode. OFB mode is similar to CDB mode; the only difference is in CFB, the ciphertext is used for the <a href=\"https://www.educba.com/encryption-process/\">next stage of the encryption process</a>, whereas in OFB, the output of the IV encryption is used for the next stage of the encryption process.</li>\r\n<li>The IV is encrypted using the key and form encrypted IV. Plain text and leftmost 8 bits of encrypted IV are combined using XOR and produce the ciphertext.</li>\r\n<li>For the next stage, the ciphertext, which is the form in the previous stage, is used as an IV for the next iteration. The same procedure is followed for all blocks.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/814105d6cfdb43f69677bd741eae0130.webp\" alt=\"814105d6cfdb43f69677bd741eae0130\"><figcaption aria-hidden=\"true\">814105d6cfdb43f69677bd741eae0130</figcaption>\r\n</figure>\r\n<h3 id=\"ctr-mode\">5. CTR Mode</h3>\r\n<ul>\r\n<li><p>CTR Mode stands for counter mode. As the name is counter, it uses the sequence of numbers as an input for the algorithm. When the block is encrypted, to fill the next register next counter value is used.<br>\r\nNote: the counter value will be incremented by 1.</p></li>\r\n<li><p>For encryption, the first counter is encrypted using a key, and then the plain text is XOR with the encrypted result to form the ciphertext.</p></li>\r\n<li><p>The counter will be incremented by 1 for the next stage, and the same procedure will be followed for all blocks. For decryption, the same sequence will be used. Here to convert ciphertext into plain text, each ciphertext is XOR with the encrypted counter. For the next stage, the counter will be incremented by the same will be repeated for all Ciphertext blocks.</p>\r\n<p><img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/35da82f1f0ca4102ae145acd4994be87.webp\" alt=\"35da82f1f0ca4102ae145acd4994be87\"> 原文来源于：<a href=\"https://www.educba.com/block-cipher-modes-of-operation/\">https://www.educba.com/block-cipher-modes-of-operation/</a></p></li>\r\n</ul>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"古典密码题解 2","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-2/","content":"<h2 id=\"凯撒替换\">凯撒？替换？</h2>\r\n<h3 id=\"打开文件\">打开文件</h3>\r\n<span id=\"more\"></span>\r\n<p>发现内容为：<code>MTHJ&#123;CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZO HIXOEOWMEHZO&#125;</code></p>\r\n<p>采用词频分析网站，进行解密，得到结果为<code>flag substitution cipher decryption is always easy just like a piece of cake</code></p>\r\n<p>因此flag为<code>flag&#123;substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake&#125;</code></p>\r\n<h2 id=\"简单刺激小游戏\">简单刺激小游戏</h2>\r\n<ol type=\"1\">\r\n<li>文件内容为<code>f&#123;1calrfesaaE_ygInE&#125;</code>，应该为栅栏密码</li>\r\n<li>使用脚本，得到结果为：<code>flag&#123;raI1fEnce_Easy&#125;</code></li>\r\n</ol>\r\n<h2 id=\"还原大师\">还原大师</h2>\r\n<p>我们得到了一串神秘字符串：<code>TASC?O3RJMV?WDJKX?ZM</code>，中间的问号为未知大写字母，并得到了该字符串的部分MD5为<code>E903???4DAB</code>，请猜出该字符串，并提交MD5作为答案</p>\r\n<p>编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">s = <span class=\"string\">&#x27;TASC?O3RJMV?WDJKX?ZM&#x27;</span></span><br><span class=\"line\">md5 = <span class=\"string\">&#x27;E903???4DAB&#x27;</span>.lower()</span><br><span class=\"line\"><span class=\"keyword\">for</span> j1 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j2 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j3 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            ss = s[:<span class=\"number\">4</span>]+<span class=\"built_in\">chr</span>(j1)+ s[<span class=\"number\">5</span>:<span class=\"number\">11</span>] + <span class=\"built_in\">chr</span>(j2)+ s[<span class=\"number\">12</span>:<span class=\"number\">17</span>] + <span class=\"built_in\">chr</span>(j3) + s[-<span class=\"number\">2</span>:]</span><br><span class=\"line\">            <span class=\"keyword\">assert</span>(<span class=\"built_in\">len</span>(ss) == <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">            mds = hashlib.md5(ss.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest().lower()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mds[:<span class=\"number\">4</span>] == md5[:<span class=\"number\">4</span>] <span class=\"keyword\">and</span> mds[<span class=\"number\">7</span>:<span class=\"number\">11</span>] == md5[<span class=\"number\">7</span>:]:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(mds)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>得到结果为<code>E9032994DABAC08080091151380478A2</code></p>\r\n<h2 id=\"古典密码1\">古典密码1</h2>\r\n<p>打开文件，发现内容如下： &gt; iodj{36g9i2777 &gt; &gt; -... ----. ..--- -... .- -.-. ...-- ----. .- .- ..--- &gt; &gt; a0dd}b6942c07</p>\r\n<p>第1为凯撒加密，第2为摩尔斯密码，第3为栅栏密码</p>\r\n<p>凯撒和摩尔斯密码解密脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 凯撒密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ks</span>(<span class=\"params\">s : <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    s = s.lower()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">27</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) + j - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)), end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i,end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">decrypt_ks(<span class=\"string\">&#x27;iodj&#123;36g9i2777&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 摩尔斯密码</span></span><br><span class=\"line\">a2mo_dict = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"string\">&#x27;.-&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"string\">&#x27;-...&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"string\">&#x27;-.-.&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>: <span class=\"string\">&#x27;-..&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>: <span class=\"string\">&#x27;.&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;f&#x27;</span>: <span class=\"string\">&#x27;..-.&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>: <span class=\"string\">&#x27;--.&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>: <span class=\"string\">&#x27;....&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>: <span class=\"string\">&#x27;..&#x27;</span>, <span class=\"string\">&#x27;j&#x27;</span>: <span class=\"string\">&#x27;.---&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;k&#x27;</span>: <span class=\"string\">&#x27;-.-&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>: <span class=\"string\">&#x27;.-..&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>: <span class=\"string\">&#x27;--&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>: <span class=\"string\">&#x27;-.&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>: <span class=\"string\">&#x27;---&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;p&#x27;</span>: <span class=\"string\">&#x27;.--.&#x27;</span>, <span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;--.-&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>: <span class=\"string\">&#x27;.-.&#x27;</span>, <span class=\"string\">&#x27;s&#x27;</span>: <span class=\"string\">&#x27;...&#x27;</span>, <span class=\"string\">&#x27;t&#x27;</span>: <span class=\"string\">&#x27;-&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;u&#x27;</span>: <span class=\"string\">&#x27;..-&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>: <span class=\"string\">&#x27;...-&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>: <span class=\"string\">&#x27;.--&#x27;</span>, <span class=\"string\">&#x27;x&#x27;</span>: <span class=\"string\">&#x27;-..-&#x27;</span>, <span class=\"string\">&#x27;y&#x27;</span>: <span class=\"string\">&#x27;-.--&#x27;</span>, <span class=\"string\">&#x27;z&#x27;</span>: <span class=\"string\">&#x27;--..&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;0&#x27;</span>: <span class=\"string\">&#x27;-----&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>: <span class=\"string\">&#x27;.----&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>: <span class=\"string\">&#x27;..---&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>: <span class=\"string\">&#x27;...--&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>: <span class=\"string\">&#x27;....-&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;5&#x27;</span>: <span class=\"string\">&#x27;.....&#x27;</span>, <span class=\"string\">&#x27;6&#x27;</span>: <span class=\"string\">&#x27;-....&#x27;</span>, <span class=\"string\">&#x27;7&#x27;</span>: <span class=\"string\">&#x27;--...&#x27;</span>, <span class=\"string\">&#x27;8&#x27;</span>: <span class=\"string\">&#x27;---..&#x27;</span>, <span class=\"string\">&#x27;9&#x27;</span>: <span class=\"string\">&#x27;----.&#x27;</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">mo2a_dict = <span class=\"built_in\">dict</span>(<span class=\"built_in\">zip</span>(a2mo_dict.values(), a2mo_dict.keys()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ms</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, split: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    l = s.split(split)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mo2a_dict[i],end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">decrypt_ms(<span class=\"string\">&#x27;-... ----. ..--- -... .- -.-. ...-- ----. .- .- ..---&#x27;</span>,<span class=\"string\">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>得到解密内容1、2分别为：<code>flag&#123;36d9f2777</code>、<code>b92bac39aa2</code>，使用之前的栅栏密码解码脚本解密内容3，得到<code>ab206cd90d47&#125;</code>，因此flag为<code>flag&#123;36d9f2777b92bac39aa2ab206cd90d47&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 1","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-1/","content":"<h2 id=\"斐波那契\">斐波那契</h2>\r\n<h3 id=\"打开文件发现内容如下\">打开文件发现内容如下</h3>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>encryption:1,1346269,2,5,8,13,3,21,34,55,89,144,233,377,610,987,2584,4181,6765,1597,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,2178309,1</p>\r\n<p>cipher:flag{0efa24ed49aa78d97bc2657c4aeaf4ad}</p>\r\n</blockquote>\r\n<h3 id=\"解题\">解题</h3>\r\n<p>发现encrytion后内容为乱序斐波那契数列，长度为32，和flag中内容长度一致，推测需找出encryption对应的编号，然后再对应到flag内容上，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = [<span class=\"number\">1</span>,<span class=\"number\">1346269</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">3</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">1597</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>,<span class=\"number\">46368</span>,<span class=\"number\">75025</span>,<span class=\"number\">121393</span>,<span class=\"number\">196418</span>,<span class=\"number\">317811</span>,<span class=\"number\">514229</span>,<span class=\"number\">832040</span>,<span class=\"number\">2178309</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">flag = <span class=\"string\">&#x27;0efa24ed49aa78d97bc2657c4aeaf4ad&#x27;</span></span><br><span class=\"line\">b = s.copy()</span><br><span class=\"line\">b.sort()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">res = [<span class=\"literal\">None</span>] * <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(flag)):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> res[b.index(s[i])]:</span><br><span class=\"line\">        res[b.index(s[i])] = flag[i]</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        c = (flag[i])</span><br><span class=\"line\">res[res.index(<span class=\"literal\">None</span>)] = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>\r\n<p>解得flag如下：<code>0dfea24d49aa78d927bc657c4aeaf4ea</code></p>\r\n<h2 id=\"仿射\">仿射</h2>\r\n<ol type=\"1\">\r\n<li>查看目录，存在两个文件：<code>hint.txt</code>和<code>cipher.txt</code>，内容分别为<code>achjbnpdfherebjsw</code>、<code>b=7</code></li>\r\n<li>解题 根据仿射变换性质：<span class=\"math inline\">\\(C = (a*M+b)\\mod 26\\)</span>，且a与26互素，因此穷举a，便历所有字符，当输出字符为可读单词时，便求得解。编写脚本如下：</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 仿射</span></span><br><span class=\"line\">cipher = <span class=\"string\">&#x27;achjbnpdfherebjsw&#x27;</span></span><br><span class=\"line\">b = <span class=\"number\">7</span></span><br><span class=\"line\">a_ = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">17</span>,<span class=\"number\">19</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">25</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> a_: <span class=\"comment\"># 便历所有a</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> cipher:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>),<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>): <span class=\"comment\"># 便历所有小写字母，判断进行加密后是否与cipher一致</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((d - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)) * a + b) % <span class=\"number\">26</span> == <span class=\"built_in\">ord</span>(c) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>):</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>(d)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(res) == <span class=\"built_in\">len</span>(cipher):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a, res)</span><br></pre></td></tr></table></figure>\r\n<p>输出结果为 &gt; 1 tvacugiwyaxkxuclp &gt; &gt; 3 phasycuqiazmzysvf &gt; &gt; 5 jzaqewmukapcpeqxd &gt; &gt; 7 zdaeomqswahuhoejr &gt; &gt; 9 flagisyouareright &gt; &gt; 11 xjamqkwcoavivqmbz &gt; &gt; 15 draokqeymafsfkozb &gt; &gt; 17 vpausicmgajwjsuth &gt; &gt; 19 bxawmokieatgtmwrj &gt; &gt; 21 rbakweogqalylwkdx &gt; &gt; 23 ltaicygksabobcifv &gt; &gt; 25 hfaygusecadqdgypl</p>\r\n<p>因此结果为：<code>flagisyouareright</code>，转换为32位md5后为<code>e8cb7b46bcf72d62e74100dd19bc63c6</code></p>\r\n<h2 id=\"大帝的秘密武器\">大帝的秘密武器</h2>\r\n<h3 id=\"题目\">题目</h3>\r\n<p>请解开以下密文获得合理单词，并使用同样加密方法和加密向量加密以下明文，作为答案提交</p>\r\n<blockquote>\r\n<p>FRPHEVGL</p>\r\n<p>ComeChina</p>\r\n</blockquote>\r\n<h3 id=\"解题-1\">解题</h3>\r\n<p>使用脚本，求得偏移量，然后再进行加密</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 大帝的秘密武器</span></span><br><span class=\"line\">s1 = <span class=\"string\">&#x27;FRPHEVGL&#x27;</span></span><br><span class=\"line\">s2 = <span class=\"string\">&#x27;ComeChina&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">encrypt_ks</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, w: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span> :</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.islower():</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) + w) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) + w) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">decrypt_ks(s1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(encrypt_ks(s2, <span class=\"number\">13</span>))</span><br></pre></td></tr></table></figure>\r\n<p>从<code>decrypt_ks</code>可以看出结果为<code>13 security</code>，因此偏移为<code>13</code>，使用encrypt_ks函数，偏移参数为13，加密结果为<code>PbzrPuvan</code></p>\r\n<h2 id=\"残缺的哈希值\">残缺的哈希值</h2>\r\n<h3 id=\"题目-1\">题目</h3>\r\n<p>小明一直将电脑密码的哈希值写在纸上，结果一不小心将墨水撒在了上面，只看得到前10位是c2979c7124，小明只记得密码是4位的数字加字母，你能帮小明恢复密码的哈希值吗？（提示：flag为密码的哈希值）</p>\r\n<h3 id=\"解题-2\">解题</h3>\r\n<p>编写脚本，暴力破解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">md5 = <span class=\"string\">&#x27;c2979c7124&#x27;</span></span><br><span class=\"line\">ss = <span class=\"string\">&#x27;0123456789abcdefghjklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> itertools.product(ss, repeat=<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hashlib.md5(<span class=\"string\">&#x27;&#x27;</span>.join(s).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest()[:<span class=\"number\">10</span>] == md5:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(hashlib.md5(<span class=\"string\">&#x27;&#x27;</span>.join(s).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest())</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>得到flag为：<code>c2979c71244dec2befc6e369941c6546</code></p>\r\n<h2 id=\"浪里淘沙\">浪里淘沙</h2>\r\n<h3 id=\"题目-2\">题目</h3>\r\n<blockquote>\r\n<p>我有密集恐惧症，所以大家自求多福吧，把获得的单词连在一起提交即可。（我这里有一串数字：4，8，11，15，16）</p>\r\n</blockquote>\r\n<p>打开<code>浪里淘沙.txt</code>，发现存在大量英文单词文本，且无空格区分。</p>\r\n<h3 id=\"解题-3\">解题</h3>\r\n<p>使用编辑器手动对单词进行切分（添加空格），然后使用脚本进行统计词频，并按次数从小到大排序，最后将数字作为索引输出单词</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">b = [<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>]</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\浪里淘沙\\浪里淘沙.txt&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    text : <span class=\"built_in\">str</span> = f.read()</span><br><span class=\"line\">    l = text.split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(l))</span><br><span class=\"line\">    s = <span class=\"built_in\">dict</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"string\">&#x27;&#x27;</span> <span class=\"keyword\">and</span> i != <span class=\"string\">&#x27; &#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s.get(i):</span><br><span class=\"line\">                s[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            s[i] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(s), s)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> s.items():</span><br><span class=\"line\">        res.append(item)</span><br><span class=\"line\">    res.sort(key = <span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> b:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(res[j][<span class=\"number\">0</span>],end=<span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>得到flag为：<code>weshouldlearnthecrypto</code></p>\r\n<h2 id=\"easy-crypto\">Easy Crypto</h2>\r\n<h3 id=\"打开文件发现内容如下-1\">打开文件，发现内容如下</h3>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">Jxyi yi oekh tqo.Jxyi yi oekh suburhqjyed., qdt jxu vbqw yi vv97v97t5t1ss32t9q5u62s2uu1t2v2s, ikrcyj myjx vbqw qdt &#123;&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用凯撒密码暴力破解\">使用凯撒密码暴力破解</h3>\r\n<p>得到结果为：<code>flag&#123;ff97f97d5d1cc32d9a5e62c2ee1d2f2c&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 3","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/","content":"<h2 id=\"世上无难事\">世上无难事</h2>\r\n<h3 id=\"题目\">题目</h3>\r\n<p>以下为某国总统外发的一段指令，经过一种奇怪的加密方式，看来只能用分析方法了，请将这段语句还原成通顺语句，并从其中找到KEY作为答案提交：</p>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>VIZZB IFIUOJBWO NVXAP OBC XZZ UKHVN IFIUOJBWO HB XVIXW XAW VXFI X QIXN VBD KQ IFIUOJBWO WBKAH NBWXO VBD XJBCN NKG QLKEIU DI XUI VIUI DKNV QNCWIANQ XN DXPIMKIZW VKHV QEVBBZ KA XUZKAHNBA FKUHKAKX XAW DI VXFI HBN QNCWIANQ NCAKAH KA MUBG XZZ XEUBQQ XGIUKEX MUBG PKAWIUHXUNIA NVUBCHV 12NV HUXWI XAW DI XUI SCQN QB HZXW NVXN XZZ EBCZW SBKA CQ NBWXO XAW DI DXAN NB NVXAP DXPIMKIZW MBU JIKAH QCEV XA BCNQNXAWKAH VBQN HKFI OBCUQIZFIQ X JKH UBCAW BM XLLZXCQI XAW NVI PIO KQ 640I11012805M211J0XJ24MM02X1IW09</p>\r\n</blockquote>\r\n<h3 id=\"解题\">解题</h3>\r\n<p>应当采用词频分析，可以看出 VIZZB = HELLO，使用<a href=\"https://quipqiup.com/\">词频分析网站</a>，可得结果为： &gt; HELLO EVERYBODY THANK YOU ALL RIGHT EVERYBODY GO AHEAD AND HAVE A SEAT HOW IS EVERYBODY DOING TODAY HOW ABOUT TIM SPICER WE ARE HERE WITH STUDENTS AT WAKEFIELD HIGH SCHOOL IN ARLINGTON VIRGINIA AND WE HAVE GOT STUDENTS TUNING IN FROM ALL ACROSS AMERICA FROM KINDERGARTEN THROUGH 12TH GRADE AND WE ARE JUST SO GLAD THAT ALL COULD JOIN US TODAY AND WE WANT TO THANK WAKEFIELD FOR BEING SUCH AN OUTSTANDING HOST GIVE YOURSELVES A BIG ROUND OF APPLAUSE AND THE KEY IS 640E11012805F211B0AB24FF02A1ED09</p>\r\n<p>因此flag为<code>640e11012805f211b0ab24ff02a1ed09</code></p>\r\n<h2 id=\"其实很简单\">其实很简单</h2>\r\n<h3 id=\"题目-1\">题目</h3>\r\n<p>学习凯撒密码后，密码前辈又创造出新奇异的加密方法，维吉尼亚是其中一种。出题者是一个程序员，喜欢拿helloworld做秘钥，下面是密文：dlpcsegkshrjj。</p>\r\n<h3 id=\"解题-1\">解题</h3>\r\n<p>编写脚本如下： <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">key, enc_txt</span>):</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    key_len = <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(enc_txt)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">26</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">ord</span>(key[i % key_len]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) + j)  % <span class=\"number\">26</span>  + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) == <span class=\"built_in\">ord</span>(enc_txt[i]):</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>(j + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(decrypt(<span class=\"string\">&#x27;helloworld&#x27;</span>, <span class=\"string\">&#x27;dlpcsegkshrjj&#x27;</span>))</span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果为<code>whereisthekey</code></p>\r\n<h2 id=\"密码学的心声\">密码学的心声</h2>\r\n<h3 id=\"题目-2\">题目</h3>\r\n<p>二战时期，某国军官与一个音乐家情妇相好，然而自从那时起，他屡战屡败，敌人似乎料事如神。他也有怀疑过他的情妇，但是他经过24小时观察他的情妇，发现她每天都只是作曲，然后弹奏给战地电台，为士兵们鼓气，并未有任何逾越。那么，间谍到底是谁？这张曲谱是否有猫腻？</p>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/谱子.png\" alt=\"谱子.png\"><figcaption aria-hidden=\"true\">谱子.png</figcaption>\r\n</figure>\r\n<h3 id=\"解题-2\">解题</h3>\r\n<p>题目提示没有8，因此将八进制转换为Ascii，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;111114157166145123145143165162151164171126145162171115165143150&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(s):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>(<span class=\"built_in\">int</span>(s[i:i+<span class=\"number\">3</span>], <span class=\"number\">8</span>)), end =<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    i += <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\r\n<p>结果为<code>ILoveSecurityVeryMuch</code></p>\r\n<h2 id=\"萌萌哒的八戒\">萌萌哒的八戒</h2>\r\n<h3 id=\"题目-3\">题目</h3>\r\n<p>萌萌哒的八戒原来曾经是猪村的村长，从远古时期，猪村就有一种神秘的代码。请从附件中找出代码，看看萌萌哒的猪八戒到底想说啥</p>\r\n<h3 id=\"解题-3\">解题</h3>\r\n<p>根据题目信息，提示为猪圈密码，打开图片后如下所示： <img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/猪圈1.png\" alt=\"猪圈1.png\"></p>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/猪圈2.png\" alt=\"猪圈2.png\"><figcaption aria-hidden=\"true\">猪圈2.png</figcaption>\r\n</figure>\r\n<p>根据猪圈密码，解得flag为<code>whenthepigwanttoeat</code></p>\r\n<h2 id=\"两种密码\">两种密码</h2>\r\n<h3 id=\"解题-4\">解题</h3>\r\n<p>根据题目信息，发现Bill.txt和Ciphertext.txt，加密方式包含Bill密码，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">index = [<span class=\"number\">34</span>, <span class=\"number\">6</span>, <span class=\"number\">13</span>, <span class=\"number\">43</span>, <span class=\"number\">68</span>, <span class=\"number\">21</span>, <span class=\"number\">43</span>, <span class=\"number\">1</span>, <span class=\"number\">77</span>, <span class=\"number\">100</span>, <span class=\"number\">6</span>, <span class=\"number\">41</span>, <span class=\"number\">5</span>, <span class=\"number\">54</span>, <span class=\"number\">68</span>, <span class=\"number\">100</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">13</span>, <span class=\"number\">68</span>, <span class=\"number\">41</span>, <span class=\"number\">2</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>]</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\两种密码\\Bill.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    s = f.read().split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> index:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[i][<span class=\"number\">0</span>], end = <span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>结果如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">the_decrption_path_is</span><br><span class=\"line\">&lt;--------oo&lt;-</span><br><span class=\"line\">-&gt;oo----&gt;oo-&gt;</span><br><span class=\"line\">&lt;-oo&lt;----oo&lt;-</span><br><span class=\"line\">-&gt;oo----&gt;oo-&gt;</span><br><span class=\"line\">&lt;-oo&lt;------&lt;-</span><br></pre></td></tr></table></figure>\r\n<p>根据结果，发现第二种加密方式为曲路密码，对秘文<code>lf1e7f05&#125;ba83909764e2686e&#123;7a7fsi_galfagb8d004</code>进行排列，得到结果为 <img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/曲路.png\" alt=\"曲路.png\"></p>\r\n<p>因此flag为<code>flag_isflag&#123;7a7f1e8be6862f7d09764e05400938ab&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 4","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-4/","content":"<h2 id=\"异性相吸\">异性相吸</h2>\r\n<ol type=\"1\">\r\n<li><p>打开压缩文件</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>发现存在<code>密文.txt</code>和<code>key.txt</code>，根据题目，猜测使用异或进行解密</p></li>\r\n<li><p>编写py脚本如下</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\异性相吸\\key.txt&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f1:</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\异性相吸\\密文.txt&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f2:</span><br><span class=\"line\">key = f1.read()</span><br><span class=\"line\">enc = f2.read()</span><br><span class=\"line\">res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(key)):</span><br><span class=\"line\">    res += <span class=\"built_in\">chr</span>(key[i] ^ enc[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(res)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>得到flag：flag{ea1bc0988992276b7f95b54a7435e89e}</p></li>\r\n</ol>\r\n<h2 id=\"一眼就解密\">一眼就解密</h2>\r\n<ol type=\"1\">\r\n<li><p>查看字符串，为<code>ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=</code></p></li>\r\n<li><p>根据尾部<code>=</code>号判断为base64编码</p></li>\r\n<li><p>编写py脚本如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64; <span class=\"built_in\">print</span>(base64.b64decode(<span class=\"string\">&#x27;ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>得到flag：flag{THE_FLAG_OF_THIS_STRING}</p></li>\r\n</ol>\r\n<h2 id=\"四四方方一座城\">四四方方一座城</h2>\r\n<ol type=\"1\">\r\n<li><p>打开压缩包，发现hint.py，打开文件，内容如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flag <span class=\"keyword\">import</span> FLAG,key1,key2,Offset</span><br><span class=\"line\"><span class=\"keyword\">from</span> enc <span class=\"keyword\">import</span> encrypt</span><br><span class=\"line\"></span><br><span class=\"line\">ciphertext = encrypt(FLAG)</span><br><span class=\"line\">enc_key1 = enc_key2 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key1:</span><br><span class=\"line\">enc_key1 += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span>) + Offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key2:</span><br><span class=\"line\">enc_key2 += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span>) + Offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> enc_key1</span><br><span class=\"line\"><span class=\"built_in\">print</span> enc_key2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#ciphertext:XBBSPASGXRAEUIOHPZ</span></span><br><span class=\"line\"><span class=\"comment\">#enc_key1:VXYjj</span></span><br><span class=\"line\"><span class=\"comment\">#enc_key2:NQLOUVXab</span></span><br></pre></td></tr></table></figure></p>\r\n<p>可以看出flag被加密，推测使用<code>key1</code>和<code>key2</code>加密，其中key1和key2经过编码，得到<code>enc_key1</code>和<code>enc_key2</code>，且Offset偏移未知。</p></li>\r\n<li><p>使用脚本如下，推测Offset值：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">min_num, max_num = <span class=\"number\">255</span>, <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    c = i ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &lt; min_num:</span><br><span class=\"line\">        min_num = c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &gt; max_num:</span><br><span class=\"line\">        max_num = c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    c = i ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &lt; min_num:</span><br><span class=\"line\">        min_num = c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &gt; max_num:</span><br><span class=\"line\">        max_num = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(min_num, max_num)</span><br><span class=\"line\">range1 = (<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) - max_num, <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) - min_num)  <span class=\"comment\"># 初步推测Offset范围</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(range1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">i, key</span>):  <span class=\"comment\"># 检查offset i还原key是否正常</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> key:</span><br><span class=\"line\">        c = (<span class=\"built_in\">ord</span>(s) - i) ^ <span class=\"number\">0xaf</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, res</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">True</span>, res)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">enc_key1 = <span class=\"string\">&#x27;VXYjj&#x27;</span></span><br><span class=\"line\">enc_key2 = <span class=\"string\">&#x27;NQLOUVXab&#x27;</span></span><br><span class=\"line\">enc_txt = <span class=\"string\">&#x27;XBBSPASGXRAEUIOHPZ&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(range1[<span class=\"number\">0</span>], range1[<span class=\"number\">1</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">    flag1, res1 = check(i, enc_key1)</span><br><span class=\"line\">    flag2, res2 = check(i, enc_key2)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag1 <span class=\"keyword\">and</span> flag2:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i, res1, res2)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果如下：</p>\r\n<blockquote>\r\n<p>192 255</p>\r\n<p>(-190, -70)</p>\r\n<p>-149 DBAPP LINKEDBYX</p>\r\n</blockquote>\r\n<p>因此offset偏移为<code>-149</code>，且key1和key2分别为：<code>DBAPP</code>，<code>LINKEDBYX</code></p></li>\r\n<li><p>编写解密脚本，求取flag</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cons_martix</span>(<span class=\"params\">key: <span class=\"built_in\">str</span></span>):  <span class=\"comment\"># 构造矩阵</span></span><br><span class=\"line\">    key_set = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key:  <span class=\"comment\"># 移除重复字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i <span class=\"keyword\">in</span> key_set:</span><br><span class=\"line\">            s += i</span><br><span class=\"line\">            key_set.add(i)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(key_set)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):  <span class=\"comment\"># 添加除key中出现过的26个英文字母(除掉Q)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(i) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> key_set:</span><br><span class=\"line\">                s += <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">                key_set.add(i)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (<span class=\"built_in\">len</span>(s) == <span class=\"number\">25</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">key1, key2, enc_txt</span>):</span><br><span class=\"line\">    m1, m2 = cons_martix(key1), cons_martix(key2)</span><br><span class=\"line\">    cm = [<span class=\"built_in\">chr</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) + <span class=\"number\">1</span>)]</span><br><span class=\"line\">    cm.remove(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(cm)</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(enc_txt):</span><br><span class=\"line\">        t1 = m1.find(enc_txt[i])</span><br><span class=\"line\">        t2 = m2.find(enc_txt[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">        x1, y1 = t1 // <span class=\"number\">5</span>, t1 % <span class=\"number\">5</span></span><br><span class=\"line\">        x2, y2 = t2 // <span class=\"number\">5</span>, t2 % <span class=\"number\">5</span></span><br><span class=\"line\">        res = res + cm[x1 * <span class=\"number\">5</span> + y2] + cm[x2*<span class=\"number\">5</span>+y1]</span><br><span class=\"line\">        i += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">res = decrypt(res1, res2, enc_txt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(res, hashlib.md5(<span class=\"built_in\">bytes</span>(res, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果如下：</p>\r\n<blockquote>\r\n<p>{'P', 'B', 'D', 'A'}</p>\r\n<p>{'B', 'I', 'N', 'X', 'Y', 'K', 'L', 'E', 'D'}</p>\r\n<p>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']</p>\r\n<p>whereismysecretkey</p>\r\n</blockquote>\r\n<p>得到flag：<code>whereismysecretkey</code></p></li>\r\n</ol>\r\n<h2 id=\"篱笆墙的影子\">篱笆墙的影子</h2>\r\n<ol type=\"1\">\r\n<li><p>打开文件发现内容为，推测为栅栏密码：<code>felhaagv&#123;ewtehtehfilnakgw&#125;</code></p></li>\r\n<li><p>编写脚本:</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 栅栏密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, n: <span class=\"built_in\">int</span>, pad_char: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    m = <span class=\"built_in\">len</span>(s) // n  <span class=\"comment\"># 共多少组</span></span><br><span class=\"line\">    l = <span class=\"built_in\">len</span>(s) % n  <span class=\"comment\"># 补余数</span></span><br><span class=\"line\">    res = <span class=\"built_in\">list</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l:</span><br><span class=\"line\">        pad_num = n - l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pad_num &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            res.insert(-(pad_num-<span class=\"number\">1</span>)*m, <span class=\"built_in\">chr</span>(pad_char))</span><br><span class=\"line\">            pad_num -= <span class=\"number\">1</span></span><br><span class=\"line\">        res.append(<span class=\"built_in\">chr</span>(pad_char))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>.join(res)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">s, n</span>):</span><br><span class=\"line\">    pad_s = pad(s, n, <span class=\"number\">1</span>)</span><br><span class=\"line\">    cates = <span class=\"built_in\">len</span>(pad_s) // n  <span class=\"comment\"># 组数</span></span><br><span class=\"line\">    res = [<span class=\"string\">&#x27;&#x27;</span>] * cates</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(pad_s):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cates):</span><br><span class=\"line\">            res[j] += pad_s[i+j]</span><br><span class=\"line\">        i += cates</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span>.join(res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.strip(<span class=\"built_in\">chr</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">loop</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"built_in\">len</span>(s)):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(decrypt(s, i))</span><br></pre></td></tr></table></figure></p>\r\n<p>得到flag为：<code>flag&#123;wethinkwehavetheflag&#125;</code></p></li>\r\n</ol>\r\n<h2 id=\"真的是键盘吗\">真的是键盘吗？</h2>\r\n<ol type=\"1\">\r\n<li>密文ypau_kjg;“g;”ypau+</li>\r\n<li>使用<a href=\"http://wbic16.xedoloh.com/dvorak.html\">解密网址</a>解密</li>\r\n<li>得到<code>flag&#123;this“is”flag&#125;</code></li>\r\n<li>对<code>this_is_flag</code>进行md5处理</li>\r\n<li>得到<code>951c712ac2c3e57053c43d80c0a9e543</code></li>\r\n</ol>\r\n<h2 id=\"vvvv\">VVVV</h2>\r\n<ol type=\"1\">\r\n<li>题目 查看压缩包，给出两个文件，分别为<code>encrypt.py</code>和<code>cipher</code>，查看encrypt.py，给出加密方式为维吉尼亚密码，查看cipher，发现内容为加密后的字符串。</li>\r\n<li>解题 使用脚本暴力破解或使用<a href=\"https://www.guballa.de/vigenere-solver\">在线网址</a>解密，得到flag为：<code>flag&#123;dvsksivtmjlochssoel&#125;</code></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"威尔逊定理","url":"/2022/09/12/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/","content":"<h2 id=\"威尔逊定理\">威尔逊定理</h2>\r\n<ol type=\"1\">\r\n<li><p>定义</p>\r\n<blockquote>\r\n<p>当且仅当p为素数时，<span class=\"math inline\">\\((p-1)!\\equiv -1\\mod p\\)</span></p>\r\n</blockquote>\r\n<p><span id=\"more\"></span></p></li>\r\n<li><p>题目</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sympy</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">myGetPrime</span>():</span><br><span class=\"line\">    A = getPrime(<span class=\"number\">513</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(A)</span><br><span class=\"line\">    B = A - random.randint(<span class=\"number\">1e3</span>, <span class=\"number\">1e5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(B)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sympy.nextPrime((B!) % A)</span><br><span class=\"line\"></span><br><span class=\"line\">p = myGetPrime()</span><br><span class=\"line\"><span class=\"comment\"># A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class=\"line\"><span class=\"comment\"># B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class=\"line\"></span><br><span class=\"line\">q = myGetPrime()</span><br><span class=\"line\"><span class=\"comment\"># A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class=\"line\"><span class=\"comment\"># B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class=\"line\"></span><br><span class=\"line\">r = myGetPrime()</span><br><span class=\"line\"></span><br><span class=\"line\">n = p*q*r</span><br><span class=\"line\"><span class=\"comment\"># n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class=\"line\">c = <span class=\"built_in\">pow</span>(flag, e, n)</span><br><span class=\"line\"><span class=\"comment\"># e=0x1001</span></span><br><span class=\"line\"><span class=\"comment\"># c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class=\"line\"><span class=\"comment\"># so,what is the flag?</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>求解过程</p>\r\n<p>此题难点在于<code>(B!)%A</code>，求B的阶乘的模，而B又很大，计算阶乘不大现实，由威尔逊定理可得：</p>\r\n<p><span class=\"math display\">\\[\r\n \\begin{align*}\r\n (A_1-1)! &amp;\\equiv -1\\mod A_1\\\\\r\n \\Rightarrow (B_1)!*k &amp;\\equiv -1\\mod A_1,(k = (A_1-1)!/B_1!)\\\\\r\n \\Rightarrow(B_1)!&amp;\\equiv -k^{-1}\\mod A_1,(k^{-1}为k在A_1下的逆元)\r\n \\end{align*}\r\n \\]</span></p>\r\n<p>代码如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sympy</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes, bytes_to_long</span><br><span class=\"line\"></span><br><span class=\"line\">A1 = <span class=\"number\">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class=\"line\">B1 = <span class=\"number\">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class=\"line\"></span><br><span class=\"line\">A2 = <span class=\"number\">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class=\"line\">B2 = <span class=\"number\">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class=\"line\">n = <span class=\"number\">85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class=\"line\">e = <span class=\"number\">0x1001</span></span><br><span class=\"line\">c = <span class=\"number\">75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fact_mod</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    m = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(b+<span class=\"number\">1</span>, a):</span><br><span class=\"line\">        m = m * i % a</span><br><span class=\"line\">    res = (-gmpy2.invert(m, a)) % a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sympy.nextprime(res)</span><br><span class=\"line\"></span><br><span class=\"line\">p = fact_mod(A1, B1)</span><br><span class=\"line\">q = fact_mod(A2, B2)</span><br><span class=\"line\">r = n // (p*q)</span><br><span class=\"line\">phi_n = (q-<span class=\"number\">1</span>)*(p-<span class=\"number\">1</span>)*(r-<span class=\"number\">1</span>)</span><br><span class=\"line\">d = gmpy2.invert(e, phi_n)</span><br><span class=\"line\">m = gmpy2.powmod(c, d, n)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(long_to_bytes(m))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b&#x27;RoarCTF&#123;wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A&#125;&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"小米6X刷机教程","url":"/2022/09/12/%E5%B0%8F%E7%B1%B36X%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/","content":"<p>最进闲来无事，早就想将手中的<code>小米6X</code>手机刷机了，本以为刷机很简单，却也整整搞了一天才完成，这里记录下刷机的过程。</p>\r\n<h2 id=\"解锁\">解锁</h2>\r\n<p>首先下载<a href=\"https://www.miui.com/unlock/download.html\">官方解锁工具</a>，然后进行以下步骤：</p>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li>进入“设置 -&gt; 开发者选项 -&gt; 设备解锁状态”中绑定账号和设备；</li>\r\n<li>手动进入Bootloader模式（关机后，同时按住开机键和音量下键）；</li>\r\n<li>通过USB连接手机，点击 “解锁”按钮；</li>\r\n<li>电脑打开解锁工具，使用绑定过手机的账号登录解锁工具，使用USB连接进入了fastboot模式的手机，此时会显示已连接的状态，若未连接，则点击设置，进行驱动检测。</li>\r\n</ol>\r\n<p>连接成功后，点击<strong>解锁</strong>按钮，手机将会进行解锁，但<code>手机内资料将会被清空，记得备份好手机资料</code>。解锁后，手机系统将会恢复出场设置。</p>\r\n<blockquote>\r\n<p>使用USB2.0接口进行连接，否则无法连接到手机</p>\r\n</blockquote>\r\n<h2 id=\"刷入第三方bootloader\">刷入第三方bootloader</h2>\r\n<p>手机重启，同时按电源键和音量下键，进入fastboot模式，打开电脑上的platform-tools文件夹，在该文件夹下进入cmd命令行或者powershell。</p>\r\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; .\\fastboot.exe flash recovery [recovery.img] </span><br></pre></td></tr></table></figure>\r\n<p>将<code>[recovery.img]</code>替换为想刷入的recovery镜像。</p>\r\n<p>Mi6X可以刷入的recovery为<code>lineage-18.1-20220901-recovery-wayne.img</code>。其他的recovery不保证刷入其他系统后还可以使用。</p>\r\n<h2 id=\"刷入系统\">刷入系统</h2>\r\n<p>刷入lineage_recvoery后，按电源键和音量上键进入recovery模式，</p>\r\n<ol type=\"1\">\r\n<li>进入<code>Factory reset</code>，然后点击<code>Format data/factory reset</code>、<code>Format cache partition</code>和<code>Format system partition</code>；</li>\r\n<li>手机清除后，点击<code>Apply Update</code>，再点击<code>Apply from ADB</code>，此时进入ADB模式；</li>\r\n<li>USB连接电脑，使用adb工具运行命令<code>adb sideload 镜像.zip</code>，此时会自动进行刷入，当刷入成功后，会显示<strong>Total xfer: 1.00x,</strong>。此时已经成功刷入系统，点击重启即可。</li>\r\n</ol>\r\n<h2 id=\"刷入magisk\">刷入magisk</h2>\r\n<p>FastBoot刷Magisk的优点<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a></p>\r\n<ol type=\"1\">\r\n<li>无需第三方Recovery</li>\r\n<li>不影响系统升级（完整包升级）</li>\r\n</ol>\r\n<p>方法：</p>\r\n<ol type=\"1\">\r\n<li><p>安装magisk APP</p></li>\r\n<li><p>从镜像.zip中提取boot.img，放到手机中；（如果系统包里面没有boot.img，只有payload.bin，请参考这个<a href=\"magiskcn.com/payload-boot\">教程</a>提取：)</p></li>\r\n<li><p>打开Magisk【安装 – 选择并修补一个文件 – 弹窗文件管理窗口（找到刚刚提取的boot.img）- 开始】</p></li>\r\n<li><p>修补结束，会生成一个名字为（magisk_patched-版本号_随机字符.img）的文件（每次生成的随机字符都不一样，使用的时候请输入生成的名字），将生成的文件复制到电脑中</p></li>\r\n<li><p>手机进入fastboot模式，连接电脑，使用platform-tools运行如下命令 <code>fastboot flash boot 面具文件</code></p></li>\r\n<li><p>出现下面这三行代码，就是成功刷入了。</p>\r\n<blockquote>\r\n<p>Sending 'boot' (131072 KB) OKAY [ 3.049s] Writing 'boot' OKAY [ 0.587s] Finished. Total time: 4.582s</p>\r\n</blockquote></li>\r\n<li><p>重启手机，已经成功刷入面具</p></li>\r\n</ol>\r\n<blockquote>\r\n<p>若想恢复无面具的系统，则按步骤5、6、7刷入从<code>镜像.zip</code>中提取的<code>boot.img</code></p>\r\n</blockquote>\r\n<h2 id=\"刷机包汇总\">刷机包汇总</h2>\r\n<p>MIUI<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Arrow OS<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a></p>\r\n<p>Lineage OS<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a></p>\r\n<p>TWRP<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p><a href=\"https://github.com/xiaoleGun/android_device_xiaomi_wayne-4.19\">KaleidoscopeOS-unofficial</a></p>\r\n<h2 id=\"恢复系统\">恢复系统</h2>\r\n<ol type=\"1\">\r\n<li>下载系统包（线刷包）；</li>\r\n<li>解压系统包（解压两次，直到出现文件夹）</li>\r\n<li>手机重启进入fastboot模式</li>\r\n<li>连接电脑，打开小米手机助手，点击加载设备，并选择文件夹（第2步解压的文件夹）</li>\r\n<li>点击刷机即可以恢复原系统。</li>\r\n</ol>\r\n<blockquote>\r\n<p>右下角可以选择全部删除、保留用户数据、全部删除并lock三个选项，若选择<code>全部删除并lock</code>，则需要重新解bootloader。</p>\r\n</blockquote>\r\n<section class=\"footnotes\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\" role=\"doc-endnote\"><p><a href=\"https://magiskcn.com/\" class=\"uri\">https://magiskcn.com/</a><a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\" role=\"doc-endnote\"><p>https://web.vip.miui.com/page/info/mio/mio/detail?postId=5876321&amp;app_version=dev.20051<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\" role=\"doc-endnote\"><p>https://arrowos.net/download<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\" role=\"doc-endnote\"><p>https://download.lineageos.org/wayne<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\" role=\"doc-endnote\"><p>https://dl.twrp.me/wayne/<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","categories":["Life"],"tags":["刷机"]},{"title":"不一样的flag","url":"/2022/09/12/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/","content":"<h2 id=\"题目地址\"><a href=\"https://buuoj.cn/challenges#%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag\">题目地址</a></h2>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<p>PEID查看无壳，拖入IDA反编译，结果如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> v3; <span class=\"comment\">// [esp+17h] [ebp-35h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v4; <span class=\"comment\">// [esp+30h] [ebp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v5; <span class=\"comment\">// [esp+34h] [ebp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> v6; <span class=\"comment\">// [esp+38h] [ebp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+3Ch] [ebp-10h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+40h] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  __main();</span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v5 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">qmemcpy</span>(&amp;v3, _data_start__, <span class=\"number\">0x19</span>u);  <span class=\"comment\">// &#x27;*11110100001010000101111#&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;you can choose one action to execute&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;1 up&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;2 down&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;3 left&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;4 right\\n:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;v6);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v6 == <span class=\"number\">2</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( v6 &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 == <span class=\"number\">3</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        --v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( v6 != <span class=\"number\">4</span> )</span><br><span class=\"line\">LABEL_13:</span><br><span class=\"line\">          <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        ++v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 != <span class=\"number\">1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_13;</span><br><span class=\"line\">      --v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( *(&amp;v4 + i) &lt; <span class=\"number\">0</span> || *(&amp;v4 + i) &gt; <span class=\"number\">4</span> )</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *((_BYTE *)&amp;v8 + <span class=\"number\">5</span> * v4 + v5 - <span class=\"number\">41</span>) == <span class=\"string\">&#x27;1&#x27;</span> )</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *((_BYTE *)&amp;v8 + <span class=\"number\">5</span> * v4 + v5 - <span class=\"number\">41</span>) == <span class=\"string\">&#x27;#&#x27;</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\nok, the order you enter is the flag!&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>分析代码，初始化将_data_start__字符串<code>*11110100001010000101111#</code>复制到v3处，后续逻辑为，用户输入数字1234分别代表上下左右，分别对应变量 ++v4、--v5、++v5、--v4。 然后将v5和v4作为字符串数组索引，取v3<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>字符串数组对应的值，判断该值与'1'和'#'的关系。</p>\r\n<p>将<code>*11110100001010000101111#</code>数组按5位一组排列，即为： *1111 01000 01010 00010 1111# 因此解法为走迷宫，从*开始，每一步走到0，直到遇到符号#。</p>\r\n<h3 id=\"得到flag222441144222\">得到flag：<code>222441144222</code></h3>\r\n<section class=\"footnotes\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\" role=\"doc-endnote\"><p>v3地址为[esp+17h]，v8地址为[esp+40h]，两者相距 29h即41。<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"刮开有奖","url":"/2022/09/12/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/","content":"<h2 id=\"题目地址\"><a href=\"https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96\">题目地址</a></h2>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<h3 id=\"peid查看无壳拖入ida反编译结果如下\">PEID查看无壳，拖入IDA反编译，结果如下：</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL __stdcall <span class=\"title\">DialogFunc</span><span class=\"params\">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *v4; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *v5; <span class=\"comment\">// edi</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v7; <span class=\"comment\">// [esp+8h] [ebp-20030h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+Ch] [ebp-2002Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v9; <span class=\"comment\">// [esp+10h] [ebp-20028h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v10; <span class=\"comment\">// [esp+14h] [ebp-20024h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v11; <span class=\"comment\">// [esp+18h] [ebp-20020h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v12; <span class=\"comment\">// [esp+1Ch] [ebp-2001Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v13; <span class=\"comment\">// [esp+20h] [ebp-20018h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v14; <span class=\"comment\">// [esp+24h] [ebp-20014h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v15; <span class=\"comment\">// [esp+28h] [ebp-20010h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v16; <span class=\"comment\">// [esp+2Ch] [ebp-2000Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v17; <span class=\"comment\">// [esp+30h] [ebp-20008h]</span></span><br><span class=\"line\">  CHAR String; <span class=\"comment\">// [esp+34h] [ebp-20004h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v19; <span class=\"comment\">// [esp+35h] [ebp-20003h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v20; <span class=\"comment\">// [esp+36h] [ebp-20002h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v21; <span class=\"comment\">// [esp+37h] [ebp-20001h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v22; <span class=\"comment\">// [esp+38h] [ebp-20000h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v23; <span class=\"comment\">// [esp+39h] [ebp-1FFFFh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v24; <span class=\"comment\">// [esp+3Ah] [ebp-1FFFEh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v25; <span class=\"comment\">// [esp+3Bh] [ebp-1FFFDh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v26; <span class=\"comment\">// [esp+10034h] [ebp-10004h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v27; <span class=\"comment\">// [esp+10035h] [ebp-10003h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v28; <span class=\"comment\">// [esp+10036h] [ebp-10002h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a2 == <span class=\"number\">272</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a2 != <span class=\"number\">273</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (_WORD)a3 == <span class=\"number\">1001</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;String, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">    <span class=\"built_in\">GetDlgItemTextA</span>(hDlg, <span class=\"number\">1000</span>, &amp;String, <span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"built_in\">strlen</span>(&amp;String) == <span class=\"number\">8</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v7 = <span class=\"number\">90</span>;</span><br><span class=\"line\">      v8 = <span class=\"number\">74</span>;</span><br><span class=\"line\">      v9 = <span class=\"number\">83</span>;</span><br><span class=\"line\">      v10 = <span class=\"number\">69</span>;</span><br><span class=\"line\">      v11 = <span class=\"number\">67</span>;</span><br><span class=\"line\">      v12 = <span class=\"number\">97</span>;</span><br><span class=\"line\">      v13 = <span class=\"number\">78</span>;</span><br><span class=\"line\">      v14 = <span class=\"number\">72</span>;</span><br><span class=\"line\">      v15 = <span class=\"number\">51</span>;</span><br><span class=\"line\">      v16 = <span class=\"number\">110</span>;</span><br><span class=\"line\">      v17 = <span class=\"number\">103</span>;</span><br><span class=\"line\">      <span class=\"built_in\">sub_4010F0</span>(&amp;v7, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>(&amp;v26, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">      v26 = v23;</span><br><span class=\"line\">      v28 = v25;</span><br><span class=\"line\">      v27 = v24;</span><br><span class=\"line\">      v4 = (<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"built_in\">sub_401000</span>(&amp;v26, <span class=\"built_in\">strlen</span>(&amp;v26));</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>(&amp;v26, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">      v27 = v21;</span><br><span class=\"line\">      v26 = v20;</span><br><span class=\"line\">      v28 = v22;</span><br><span class=\"line\">      v5 = (<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"built_in\">sub_401000</span>(&amp;v26, <span class=\"built_in\">strlen</span>(&amp;v26));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( String == v7 + <span class=\"number\">34</span></span><br><span class=\"line\">        &amp;&amp; v19 == v11</span><br><span class=\"line\">        &amp;&amp; <span class=\"number\">4</span> * v20 - <span class=\"number\">141</span> == <span class=\"number\">3</span> * v9</span><br><span class=\"line\">        &amp;&amp; v21 / <span class=\"number\">4</span> == <span class=\"number\">2</span> * (v14 / <span class=\"number\">9</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v4, <span class=\"string\">&quot;ak1w&quot;</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v5, <span class=\"string\">&quot;V1Ax&quot;</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MessageBoxA</span>(hDlg, <span class=\"string\">&quot;U g3t 1T!&quot;</span>, <span class=\"string\">&quot;@_@&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (_WORD)a3 != <span class=\"number\">1</span> &amp;&amp; (_WORD)a3 != <span class=\"number\">2</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">EndDialog</span>(hDlg, (<span class=\"type\">unsigned</span> __int16)a3);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>发现关键代码如下： <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( String == v7 + <span class=\"number\">34</span></span><br><span class=\"line\">        &amp;&amp; v19 == v11</span><br><span class=\"line\">        &amp;&amp; <span class=\"number\">4</span> * v20 - <span class=\"number\">141</span> == <span class=\"number\">3</span> * v9</span><br><span class=\"line\">        &amp;&amp; v21 / <span class=\"number\">4</span> == <span class=\"number\">2</span> * (v14 / <span class=\"number\">9</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v4, <span class=\"string\">&quot;ak1w&quot;</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v5, <span class=\"string\">&quot;V1Ax&quot;</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MessageBoxA</span>(hDlg, <span class=\"string\">&quot;U g3t 1T!&quot;</span>, <span class=\"string\">&quot;@_@&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure> 将v4、v5分别与<code>\"ak1w\"</code>、<code>\"V1Ax\"</code>对比，String与v7+34对比，其他类似，从String开始到v25为我方输入，后续对String部分进行变换。 1. sub_4010F0(&amp;v7, 0, 10)函数对v7开始的数组进行排序（升序）， 2. sub_401000函数为base64编码。</p>\r\n<h3 id=\"编写py对其还原\">编写py对其还原：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\">a = [<span class=\"string\">&#x27;Z&#x27;</span>,<span class=\"string\">&#x27;J&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;N&#x27;</span>,<span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;n&#x27;</span>,<span class=\"string\">&#x27;g&#x27;</span>]</span><br><span class=\"line\">a = [<span class=\"built_in\">ord</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> a]</span><br><span class=\"line\">a.sort()</span><br><span class=\"line\">res = []</span><br><span class=\"line\">res.append(<span class=\"built_in\">chr</span>(a[<span class=\"number\">0</span>]+<span class=\"number\">34</span>))                        <span class=\"comment\"># str[0]</span></span><br><span class=\"line\">res.append(<span class=\"built_in\">chr</span>(a[<span class=\"number\">4</span>]))                           <span class=\"comment\"># str[1] = v19</span></span><br><span class=\"line\">res.append( <span class=\"built_in\">chr</span>((a[<span class=\"number\">2</span>] * <span class=\"number\">3</span> + <span class=\"number\">141</span>) // <span class=\"number\">4</span>) )        <span class=\"comment\"># v20</span></span><br><span class=\"line\">res.append(base64.b64decode(<span class=\"string\">&quot;ak1w&quot;</span>).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)[<span class=\"number\">1</span>:])        <span class=\"comment\"># v21-v22</span></span><br><span class=\"line\">res.append(base64.b64decode(<span class=\"string\">&quot;V1Ax&quot;</span>).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>))            <span class=\"comment\"># v23-v25</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"得到flagujwmpwp1\">得到flag：UJWMpWP1</h3>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]}]