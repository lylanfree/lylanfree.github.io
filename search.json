[{"title":"BIRD 入门","url":"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/","content":"<p>BIRD，即BIRD Internet Routing Daemon，是一个开源软件，支持各类标准路由协议，包括BGP，RIP和OSPF。本文主要关注BGP和OSPF协议，下面对其进行简单介绍。</p>\r\n<span id=\"more\"></span>\r\n<p>BIRD配置文件<code>bird.conf</code>位于<code>/etc/bird</code>文件目录下。其配置十分复杂且跟协议相关，详细的配置可参考<a href=\"https://bird.network.cz/\">BIRD manual</a>，本文仅关注Emulator所依赖的features。</p>\r\n<p><strong>BIRD 路由表</strong> 路由协议的主要功能是作为协议参与者与其对等者（peers）交换信息，这些路由信息存放在路由表中。BIRD在内存中存放有数个路由表，这些路由表如何接收或导出其数据被称为<code>protocol</code>。在某些例子中，这些协议是真正的路由协议，如bgp，rip，ospf，将导出或导入到各类路由器的路由表中。但某些协议不是真正的路由协议，BIRD使用<code>protocol</code>关键字，指明BIRD路由表从哪获取路由，并将路由发送何处。这些特殊的<code>protocol</code>用于指明数据如何从一个路由表流向另一个路由表。</p>\r\n<figure>\r\n<img src=\"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/image-20220912212527054-16629891354721.png\" alt=\"image-20220912212527054\"><figcaption aria-hidden=\"true\">image-20220912212527054</figcaption>\r\n</figure>\r\n<h2 id=\"pipe-between-tables\">Pipe Between Tables</h2>\r\n<p>对于IPv4，仅存储在BIRD主表<code>master4</code>中的路由将会被导出到内核的路由表中（通过<code>kernel</code>协议）。如果未指明协议中的表名，将会默认使用master table。对于不同的协议将会使用不同的表名，这些路由将使用<code>pipe</code>协议传送到master table中。</p>\r\n<p><code>pipe</code>协议连接两个路由表，分别为主表（使用<code>table</code>关键字）和次表（使用<code>peer</code>关键字）。在import和export两个方向中可以使用filter过滤路由信息。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol pipe &#123;</span><br><span class=\"line\">\ttable t_bgp;</span><br><span class=\"line\">\tpeer table master4;</span><br><span class=\"line\">\timport none;</span><br><span class=\"line\">\texport all;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述的例子中，所有t_bgp的表项被导出到master4表中，但master4中没有任何路由被导入到t_bgp中。在下列的例子中，所有t_direct表中的路由项被导出到t_bgp表中，且路由的local preference属性设为40。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol pipe &#123;</span><br><span class=\"line\">\ttable t_direct;</span><br><span class=\"line\">\tpeer table t_bgp;</span><br><span class=\"line\">\timport none;</span><br><span class=\"line\">\texport filter &#123; bgp_local_pref = <span class=\"number\">40</span>; accept; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgp路由表与kernel路由表\">BGP路由表与Kernel路由表</h2>\r\n<p>BIRD没有真正用于路由的路由表，真正用于路由的路由表叫kernel路由表，位于系统kernel中，但kernel路由表取决于路由协议学习真正的路由。为此，BIRD提供<code>kernel</code>协议用于连接BIRD的路由表与kernel路由表。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol kernel &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t\texport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlearn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述的例子中，未指定路由表名，因此默认为master表（master4用于IPv4）。“import all”表示BIRD将从kernel路由表导入所有信息到master4表，“export all”表示master4表中所有路由信息将导出到kernel路由表中。</p>\r\n<h2 id=\"device-协议\">device 协议</h2>\r\n<p>每个BGP路由器中都有一个叫<code>device</code>的强制协议，该协议不是真正的路由协议，不生成任何路由，也不接受任何路由。该协议仅用于从kernel中获取网卡信息。在Emulator中，该协议仅为一个empty block。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol device &#123; &#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgpas所有的ip前缀\">BGP：AS所有的IP前缀</h2>\r\n<p>在BGP协议中，每个BGP路由器需要告知Internet其代表的自治系统所拥有的网络前缀，告知其他AS本AS是这些IP前缀的所有者。BGP路由器如何知道这些前缀属于自身AS？BGP路由器可以通过以下几种方法获取该信息。</p>\r\n<ol type=\"1\">\r\n<li>从BGP路由器所附加的网络中</li>\r\n<li>从配置文件添加的静态表项中</li>\r\n<li>从IBGP（Interior BGP）和IGP（Internal Gateway Protocol）中，例如从其他属于同一AS的路由器中。</li>\r\n</ol>\r\n<h3 id=\"使用direct协议生成路由\">使用direct协议生成路由</h3>\r\n<p>每个BGP路由器附加在AS的一个或多个内部网络中，因此可以从自身网卡所在的网络中获取IP前缀。BIRD使用<code>direct</code>协议来收集这些IP前缀信息，并且生成相应的路由。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol direct local_nets &#123; <span class=\"meta\"># give it a customized name: local_nets</span></span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_direct;</span><br><span class=\"line\">\t\t<span class=\"meta\"># import all the generated routes to t_direct</span></span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tinterface <span class=\"string\">&quot;eth0&quot;</span>;</span><br><span class=\"line\">\tinterface <span class=\"string\">&quot;eth1&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在<code>direct</code>协议中，<code>interface</code>关键字用于从接口中生成路由。假定BGP路由器分别使用 <em>eth0</em> 和 <em>eth1</em> 连接到自治系统的内部网络 <em>10.150.0.0./24</em> 和 <em>10.150.1.0/24</em> ，direct协议将会生成对于 <em>10.150.0.0./24</em> 和 <em>10.150.1.0/24</em> 的路由项，存储到t_direct表中。 使用<code>birdc show route</code>命令列出每个表中的路由项。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table t direct 10.150.0.0/24</span></span><br><span class=\"line\">Table t_direct:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table t bgp 10.150.0.0/24</span></span><br><span class=\"line\">Table t_bgp:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\">BGP.local_pref: 40</span><br><span class=\"line\">BGP.large_community: (150, 0, 0)</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">birdc show route all table master4 10.150.0.0/24</span></span><br><span class=\"line\">Table master4:</span><br><span class=\"line\">10.150.0.0/24 unicast [local_nets 13:51:05.189] * (240)</span><br><span class=\"line\">dev net0</span><br><span class=\"line\">Type: device univ</span><br><span class=\"line\">BGP.local_pref: 40</span><br><span class=\"line\">BGP.large_community: (150, 0, 0)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"从static协议中生成路由\">从static协议中生成路由</h3>\r\n<p>BIRD使用<code>static</code>协议在BGP配置文件中添加静态IP前缀信息，该协议同样不是真正的协议，因为该协议不支持从peer中导入路由，仅提供预定义的路由信息。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol <span class=\"type\">static</span> &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\troute <span class=\"number\">10.150</span><span class=\"number\">.1</span><span class=\"number\">.0</span>/<span class=\"number\">24</span> via <span class=\"number\">10.150</span><span class=\"number\">.0</span><span class=\"number\">.254</span> &#123;</span><br><span class=\"line\">\t\tbgp_large_community.add(LOCAL_COMM);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\troute <span class=\"number\">10.150</span><span class=\"number\">.2</span><span class=\"number\">.0</span>/<span class=\"number\">24</span> blackhole &#123;</span><br><span class=\"line\">\t\tbgp_large_community.add(LOCAL_COMM);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"asn和ip前缀\">ASN和IP前缀</h3>\r\n<p>现实世界中，我们需要知道一个特定的AS所拥有的IP前缀和特定的IP前缀属于哪个AS。可以使用RADB数据库获取该信息。示例如下：</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">whois -h whois.radb.net -- <span class=\"string\">&#x27;-i origin AS11872&#x27;</span> | grep route</span></span><br><span class=\"line\">route:      128.230.0.0/16</span><br><span class=\"line\">route:      149.119.0.0/16</span><br><span class=\"line\">route:      128.230.0.0/17</span><br><span class=\"line\">route:      128.230.128.0/17</span><br><span class=\"line\">route:      128.230.0.0/18</span><br><span class=\"line\">route:      128.230.64.0/18</span><br><span class=\"line\">route:      128.230.128.0/18</span><br><span class=\"line\">route:      128.230.192.0/18</span><br><span class=\"line\">route:      128.230.0.0/19</span><br><span class=\"line\">route:      128.230.32.0/19</span><br><span class=\"line\">route:      128.230.64.0/19</span><br><span class=\"line\">route:      128.230.96.0/19</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">whois -h whois.radb.net 110.75.129.5</span></span><br><span class=\"line\">route:          110.75.129.0/24</span><br><span class=\"line\">descr:          Alibaba (US) Technology Co., Ltd.</span><br><span class=\"line\">origin:         AS45102</span><br><span class=\"line\">mnt-by:         MAINT-CNNIC-AP</span><br><span class=\"line\">last-modified:  2020-06-28T00:10:33Z</span><br><span class=\"line\">source:         APNIC</span><br><span class=\"line\"></span><br><span class=\"line\">route:          110.75.129.0/24</span><br><span class=\"line\">descr:          Alibaba (US) Technology Co., Ltd.</span><br><span class=\"line\">origin:         AS37963</span><br><span class=\"line\">mnt-by:         MAINT-CNNIC-AP</span><br><span class=\"line\">last-modified:  2020-06-28T00:09:56Z</span><br><span class=\"line\">source:         APNIC</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bgp-peering\">BGP Peering</h2>\r\n<p>在IX-100中，AS-150，AS-151，AS-2，AS-3和AS-4都连接到IX-100网络 <em>0.100.0.0/24</em>。每个自治系统都有BGP路由器连接到该网络中，且属于物理连接，但并不意味着自治系统已经与其他系统进行了对等连接，为了建立对等连接，每个BGP路由器需要设置<code>peering</code>关系。</p>\r\n<figure>\r\n<img src=\"/2022/09/12/BIRD-%E5%85%A5%E9%97%A8/Users\\lylan\\Desktop\\resources\\8e5851d6517a45fe8067e76f0b6e0f64.png\" alt=\"IX-100.png\"><figcaption aria-hidden=\"true\">IX-100.png</figcaption>\r\n</figure>\r\n<h3 id=\"建立peering关系\">建立Peering关系</h3>\r\n<p>在两个BGP路由器物理连接后，需要设置BGP peering用于相互通信和交换路由信息。BGP路由器可以建立多个peer，每个叫做 <em>peering session</em>。BIRD使用<code>bgp</code>协议建立 <em>peering session</em>。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp u_as2 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t\timport filter &#123;</span><br><span class=\"line\">\t\t\t... omitted ...</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\texport where ... filter omitted ...</span><br><span class=\"line\">\t\tnext hop self;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.150</span> as <span class=\"number\">150</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>local 选项</strong>：指定了路由器属于哪个AS和路由器的IP地址，该IP地址应当属于IX网络（IX网络段为10.100.0.0/24）。IP地址是可选的，但当路由器具有多个IP地址时，可以避免BGP session选择错误的IP地址。</p>\r\n<p><strong>neighnor 选项</strong>：指定了peer的IP地址和peer所属的AS，该IP地址同样属于IX网络。</p>\r\n<p><strong>IPv4 channel和路由表</strong>：每个协议都通过channel连接到一个路由表。BGP支持IPv4和IPv6 channel，每个channel包含两个filter，分别为import和export filter，能够接收，拒绝和修改路由。</p>\r\n<h3 id=\"import和export-filters\">Import和Export Filters</h3>\r\n<p>当导入和导出路由时，可以使用过滤规则。BIRD包含简单的编程语言，其过滤规则为程序。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">table t_bgp;</span><br><span class=\"line\">import filter &#123;</span><br><span class=\"line\">\tbgp_large_community.add(PROVIDER_COMM);</span><br><span class=\"line\">\tbgp_local_pref = <span class=\"number\">10</span>;</span><br><span class=\"line\">\taccept;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export where bgp_large_community ˜ [LOCAL_COMM, CUSTOMER_COMM];</span><br></pre></td></tr></table></figure>\r\n<p>在上述的例子中，当路由从peer中导入时，社区信息将被添加且local preference值被设为10，当路由导出到peer时，仅属于LOCAL_COMM和CUSTOMER_COMM 社区的路由将会被导出。 路由具有许多属性，filter可以通过预定义的变量访问这些属性，部分预定义变量如下：</p>\r\n<ul>\r\n<li>net：路由网络前缀</li>\r\n<li>bgp_path：路由AS路径</li>\r\n<li>bgp_local_pref：路由的本地preference值，用于路径选择</li>\r\n<li>bgp_next_hop：转发包到目的地的下一跳</li>\r\n<li>bgp_large_community：与路由相关的large 社区值列表</li>\r\n</ul>\r\n<h3 id=\"peering-via-路由服务器\">Peering via 路由服务器</h3>\r\n<p>Internet exchanges提供叫 <code>router server</code>的特别服务器，N个自治系统仅需要连接到该路由服务器便可以互相交换路由信息。<code>route server</code>从BGP的参与者接收到路由时，将会转发其他所有的参与者，其功能类似于多播。 AS-2，AS-3和AS-4通过<code>router server</code>与其他互相连接，其中AS-2 BGP路由器的BGP表项如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp p_rs100 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\ttable t_bgp;</span><br><span class=\"line\">\t\timport filter &#123;</span><br><span class=\"line\">\t\t\tbgp_large_community.add(PREE_COMM);</span><br><span class=\"line\">\t\t\tbgp_local_pref = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t\t\taccept;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\texport where bgp_large_community ~ [LOCAL_COMM, CUSTOMER_COMM];</span><br><span class=\"line\">\t\tnext_hop self;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.100</span> as <span class=\"number\">100</span>; <span class=\"meta\"># peer with the route server</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>router server需要添加所有的AS-2，AS-3和AS-4的peering entry，包含“rs client”选项开启。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol bgp p_as2 &#123;</span><br><span class=\"line\">\tipv4 &#123;</span><br><span class=\"line\">\t\timport all;</span><br><span class=\"line\">\t\texport all;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\trs client;</span><br><span class=\"line\">\tlocal <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.100</span> as <span class=\"number\">100</span>;</span><br><span class=\"line\">\tneighbor <span class=\"number\">10.100</span><span class=\"number\">.0</span><span class=\"number\">.2</span> as <span class=\"number\">2</span>; ➙Peer with AS<span class=\"number\">-2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"route-advertisements\">Route Advertisements</h3>\r\n<p>BGP路由器转发其路由消息时，该路由advertisement包含两个section：</p>\r\n<ul>\r\n<li><strong>路径属性</strong>：\r\n<ul>\r\n<li>Origin：定义路由信息来源，如internal或external路由协议</li>\r\n<li>AS Path：AS列表</li>\r\n<li>Next hop：下一跳路由器地址</li>\r\n</ul></li>\r\n<li><strong>网络层可达信息</strong>（NLRI）：从特定路径可达的IP前缀，例如 <em>100.5.0.0./24</em></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Internet Protocol Version 4, Src: 10.100.0.3, Dst: 10.100.0.150</span><br><span class=\"line\">Transmission Control Protocol, Src Port: 179, Dst Port: 33905, ...</span><br><span class=\"line\">Border Gateway Protocol - UPDATE Message</span><br><span class=\"line\">\tMarker: ffffffffffffffffffffffffffffffff</span><br><span class=\"line\">\tLength: 94</span><br><span class=\"line\">\tType: UPDATE Message (2)</span><br><span class=\"line\">\tWithdrawn Routes Length: 0</span><br><span class=\"line\">\tTotal Path Attribute Length: 67</span><br><span class=\"line\">\tPath attributes</span><br><span class=\"line\">\t\tPath Attribute - ORIGIN: IGP</span><br><span class=\"line\">\t\tPath Attribute - AS PATH: 3 12 164</span><br><span class=\"line\">\t\tPath Attribute - NEXT HOP: 10.100.0.3</span><br><span class=\"line\">\t\tPath Attribute - LARGE_COMMUNITY: 3:1:0 12:1:0 164:0:0</span><br><span class=\"line\">\tNetwork Layer Reachability Information (NLRI)</span><br><span class=\"line\">\t\t10.164.0.0/24</span><br><span class=\"line\">\t\t\tNLRI prefix length: 24</span><br><span class=\"line\">\t\t\tNLRI prefix: 10.164.0.0</span><br></pre></td></tr></table></figure>\r\n","categories":["工具"],"tags":["bird","network"]},{"title":"Babylfsr","url":"/2022/09/12/Babylfsr/","content":"<h2 id=\"例题如下\">1. 例题如下</h2>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"keyword\">from</span> secret <span class=\"keyword\">import</span> KEY,FLAG,MASK</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(FLAG==<span class=\"string\">&quot;de1ctf&#123;&quot;</span>+hashlib.sha256(<span class=\"built_in\">hex</span>(KEY)[<span class=\"number\">2</span>:].rstrip(<span class=\"string\">&#x27;L&#x27;</span>)).hexdigest()+<span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(FLAG[<span class=\"number\">7</span>:<span class=\"number\">11</span>]==<span class=\"string\">&#x27;1224&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">LENGTH = <span class=\"number\">256</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(KEY.bit_length()==LENGTH)</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(MASK.bit_length()==LENGTH)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">m</span>):</span><br><span class=\"line\">    pad_length = <span class=\"number\">8</span> - <span class=\"built_in\">len</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pad_length*<span class=\"string\">&#x27;0&#x27;</span>+m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">lfsr</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, init, mask, length</span>):</span><br><span class=\"line\">        self.init = init</span><br><span class=\"line\">        self.mask = mask</span><br><span class=\"line\">        self.lengthmask = <span class=\"number\">2</span>**(length+<span class=\"number\">1</span>)-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        nextdata = (self.init &lt;&lt; <span class=\"number\">1</span>) &amp; self.lengthmask </span><br><span class=\"line\">        i = self.init &amp; self.mask &amp; self.lengthmask </span><br><span class=\"line\">        output = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">            output ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            i = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        nextdata ^= output</span><br><span class=\"line\">        self.init = nextdata</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    l = lfsr(KEY,MASK,LENGTH)</span><br><span class=\"line\">    r = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">63</span>):</span><br><span class=\"line\">        b = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">            b = (b&lt;&lt;<span class=\"number\">1</span>)+l.<span class=\"built_in\">next</span>()</span><br><span class=\"line\">        r += pad(<span class=\"built_in\">bin</span>(b)[<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;output&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(r)</span><br></pre></td></tr></table></figure>\r\n<p>另外给的信息为：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分析\">2. 分析</h2>\r\n<p>分析程序，是一个普通的lfsr，但不知道初始KEY和MASK，需要利用给出的另一段信息（504bit），推出所需的MASK和KEY（分别都是256bit）。</p>\r\n<h3 id=\"求掩码\">求掩码</h3>\r\n<p>先考虑如何推出掩码。由于 lfsr 的性质，每一次生成的 bit 都会加到向量的最低位，同时丢弃掉最高位那个 bit. 于是在连续 256 次生成之后，原有的 KEY 所有的位都被丢弃，lfsr 的状态会转为我们已知的 256 个 bit —— 也就是题目所给出的串的前 256 位。从此之后，我们完全知道了 lfsr 的状态，只需要在已知状态的情况下推出掩码了。</p>\r\n<p>设初始KEY为<span class=\"math inline\">\\((a_{0},a_{1},\\cdots,a_{255})\\)</span>，MASK为<span class=\"math inline\">\\((m_0,m_1,\\cdots,m_{255})^{T}\\)</span>，<code>lfsr</code>运算如下： <span class=\"math display\">\\[ { \\begin{pmatrix} a_0&amp; a_1&amp; \\cdots &amp; a_{254} &amp; a_{255} \\\\ a_1&amp; a_2 &amp; \\cdots &amp; a_{255} &amp; o_0 \\\\ \\ddots \\\\ a_{255} &amp; o_0 &amp; \\cdots &amp; o_{253} &amp; o_{254} \\end{pmatrix} \\begin{pmatrix} m_0 \\\\ m_1 \\\\ \\vdots \\\\ m_{255} \\end{pmatrix} = \\begin{pmatrix} o_0 \\\\ o_1 \\\\ \\vdots \\\\ o_{255} \\end{pmatrix} } \\]</span></p>\r\n<p>上面是一个方程；而状态向量有 256 维，我们需要 256 组方程才能解出整个掩码向量。但我们现在只有 504 - 256 = 248 个方程可用，显然秩是不够用的。容易想到，直接猜测 lfsr 此后生成的 8 个 bit，于是就有 256 组方程了；</p>\r\n<p>解方程组的问题可以转化为矩阵求逆的问题。把 lfsr 的状态一行一行地写在矩阵上，形成的矩阵记为 <span class=\"math inline\">\\(A\\)</span> . 把 lsfr 每次所生成的结果也拼成一个向量，记为 <span class=\"math inline\">\\(O\\)</span>. 那么掩码向量 <span class=\"math inline\">\\(m\\)</span> 使得： <span class=\"math display\">\\[A\\cdot m = O\\]</span> 两边左乘 <span class=\"math inline\">\\(A^{-1}\\)</span>，可以得到掩码向量： <span class=\"math display\">\\[m = A^{-1}\\cdot O\\]</span></p>\r\n<p>爆破掩码脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&#x27;001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">padding</span>):</span><br><span class=\"line\">    s = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> x ] + padding</span><br><span class=\"line\">    M = matrix(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">    T = vector(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s) - <span class=\"number\">256</span>):</span><br><span class=\"line\">        M[i] = s[i:i+<span class=\"number\">256</span>]</span><br><span class=\"line\">        T[i] = s[i+<span class=\"number\">256</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        mask = M.inverse() * T</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mask</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> itertools.product([<span class=\"number\">0</span>,<span class=\"number\">1</span>], repeat=<span class=\"number\">8</span>):</span><br><span class=\"line\">    test(<span class=\"built_in\">list</span>(i))</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"求key\">求KEY</h3>\r\n<p>接下来考虑求出初始状态 KEY. 我们目前有的东西是：（猜测的）连续 512 个 lfsr 输出，以及与之对应的掩码。注意到第 256 个输出，是由 KEY 的末位，拼接上前 255 个输出所形成的；第 255 个输出，是由 KEY 的倒数两位，拼接上前 254 个输出所形成的。我们可以先求出 KEY 的末位，再求出倒数第二位……以此类推，整个 KEY 就求出来了。</p>\r\n<p>完整脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&#x27;001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bitAnd</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"keyword\">lambda</span> x,y: <span class=\"built_in\">int</span>(x) &amp; <span class=\"built_in\">int</span>(y), a,b))</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">bin2int</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x,y: x*<span class=\"number\">2</span> + y, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">padding</span>):</span><br><span class=\"line\">    s = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> x ] + padding</span><br><span class=\"line\">    M = matrix(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>, <span class=\"number\">256</span>)</span><br><span class=\"line\">    T = vector(GF(<span class=\"number\">2</span>), <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s) - <span class=\"number\">256</span>):</span><br><span class=\"line\">        M[i] = s[i:i+<span class=\"number\">256</span>]</span><br><span class=\"line\">        T[i] = s[i+<span class=\"number\">256</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        mask = M.inverse() * T</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    key = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">256</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> bitAnd([<span class=\"number\">0</span>] + key + s[<span class=\"number\">0</span>:<span class=\"number\">255</span> - i], mask).count(<span class=\"number\">1</span>) % <span class=\"number\">2</span> == s[<span class=\"number\">255</span>-i]:</span><br><span class=\"line\">            key = [<span class=\"number\">0</span>] + key</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            key = [<span class=\"number\">1</span>] + key</span><br><span class=\"line\">    key = <span class=\"built_in\">hex</span>(bin2int(key))[<span class=\"number\">2</span>:]</span><br><span class=\"line\">    r = hashlib.sha256(key.encode()).hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r[:<span class=\"number\">4</span>] == <span class=\"string\">&#x27;1224&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> itertools.product([<span class=\"number\">0</span>,<span class=\"number\">1</span>], repeat=<span class=\"number\">8</span>):</span><br><span class=\"line\">    test(<span class=\"built_in\">list</span>(i))</span><br><span class=\"line\"><span class=\"comment\"># 1224473d5e349dbf2946353444d727d8fa91da3275ed3ac0dedeb7e6a9ad8619</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>注意，该题在sage下进行求解。</p>\r\n</blockquote>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"CBC反转攻击","url":"/2022/09/12/CBC%E5%8F%8D%E8%BD%AC%E6%94%BB%E5%87%BB/","content":"<h2 id=\"cbc-反转攻击\">CBC 反转攻击</h2>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>查看文件内容</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Cipher <span class=\"keyword\">import</span> AES</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">flag = <span class=\"string\">&#x27;DASCTF&#123;********************************&#125;&#x27;</span></span><br><span class=\"line\">BLOCKSIZE = <span class=\"number\">16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    pad_len = BLOCKSIZE - (<span class=\"built_in\">len</span>(data) %</span><br><span class=\"line\">                        BLOCKSIZE) <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(data) % BLOCKSIZE != <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data + <span class=\"string\">&quot;=&quot;</span> * pad_len</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">unpad</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.replace(<span class=\"string\">&quot;=&quot;</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enc</span>(<span class=\"params\">data, key, iv</span>):</span><br><span class=\"line\">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class=\"line\">    encrypt = cipher.encrypt(pad(data))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> encrypt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dec</span>(<span class=\"params\">data, key, iv</span>):</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class=\"line\">        encrypt = cipher.decrypt(data)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unpad(encrypt)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">task</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        key = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">        iv = os.urandom(<span class=\"number\">16</span>)</span><br><span class=\"line\">        pre = <span class=\"string\">&quot;yusa&quot;</span>*<span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">            choice = raw_input(menu)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> choice == <span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                name = raw_input(<span class=\"string\">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name == <span class=\"string\">&#x27;admin&#x27;</span>:</span><br><span class=\"line\">                    exit()</span><br><span class=\"line\">                token = enc(pre+name, key, iv)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&quot;Here is your token(in hex): &quot;</span>+iv.encode(<span class=\"string\">&#x27;hex&#x27;</span>)+token.encode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> choice == <span class=\"string\">&#x27;2&#x27;</span>:</span><br><span class=\"line\">                token = raw_input(<span class=\"string\">&quot;Your token(in hex): &quot;</span>).decode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                iv = token[:<span class=\"number\">16</span>]</span><br><span class=\"line\">                name = dec(token[<span class=\"number\">16</span>:], key, iv)</span><br><span class=\"line\">                <span class=\"built_in\">print</span> iv.encode(<span class=\"string\">&#x27;hex&#x27;</span>)+name.encode(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name[:<span class=\"number\">16</span>] == <span class=\"string\">&quot;yusa&quot;</span>*<span class=\"number\">4</span>:</span><br><span class=\"line\">                    <span class=\"built_in\">print</span> <span class=\"string\">&quot;Hello, &quot;</span>+name[<span class=\"number\">16</span>:]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> name[<span class=\"number\">16</span>:] == <span class=\"string\">&#x27;admin&#x27;</span>:</span><br><span class=\"line\">                        <span class=\"built_in\">print</span> flag</span><br><span class=\"line\">                        exit()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\">menu = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">1. register</span></span><br><span class=\"line\"><span class=\"string\">2. login</span></span><br><span class=\"line\"><span class=\"string\">3. exit</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    task()</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>攻击思路 题目提示为CBC反转攻击，需要了解CBC反转攻击原因 <img src=\"/2022/09/12/CBC%E5%8F%8D%E8%BD%AC%E6%94%BB%E5%87%BB/27c02823d6c18308ea47bd1f21558f8b.png\" alt=\"27c02823d6c18308ea47bd1f21558f8b.png\"> 用户能够控制IV和密文输入，<span class=\"math inline\">\\(plain2 = cipher1 \\oplus Dec(cipher)\\)</span>，当用户的密文输入为<span class=\"math inline\">\\(cipher1 \\oplus plain2 \\oplus [tamperd]\\)</span>时，解密的<code>plain2</code>则被修改为 <span class=\"math display\">\\[\r\n cipher1 \\oplus plain2 \\oplus [tamperd] \\oplus Dec(cipher) = \\\\\r\n cipher1 \\oplus Dec(cipher) \\oplus plain2 \\oplus [tamperd] = \\\\\r\n plain2 \\oplus plain2 \\oplus [tamperd] =[tamperd]\r\n \\]</span> 因此，可以将login返回的token（iv和token）分别进行修改</p>\r\n<p><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">token = `xxxxxx`</span><br><span class=\"line\">iv = token[:32]</span><br><span class=\"line\">c1 = token[32:64]</span><br><span class=\"line\">c2 = token[64:]</span><br><span class=\"line\">s1 = c1 ^ 原文2 ^ 篡改内容</span><br><span class=\"line\"></span><br><span class=\"line\">token2 = send(iv+s1+c2)</span><br><span class=\"line\">s2 = token[:32] ^ 原文1 ^ iv</span><br><span class=\"line\">send(s2 + s1 + c2)</span><br></pre></td></tr></table></figure></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"Easy RSA","url":"/2022/09/12/Easy-RSA/","content":"<h2 id=\"easy-rsa\">Easy RSA</h2>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li><p>打开py文件，发现内容为：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">from</span> flag <span class=\"keyword\">import</span> flag</span><br><span class=\"line\"></span><br><span class=\"line\">p = getPrime(<span class=\"number\">1024</span>)</span><br><span class=\"line\">r = random.randint(<span class=\"number\">2</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\">n = p**r</span><br><span class=\"line\">m = flag</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"built_in\">int</span>(m.encode(<span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"number\">16</span>) &lt; n)</span><br><span class=\"line\">c = <span class=\"built_in\">pow</span>(<span class=\"built_in\">int</span>(m.encode(<span class=\"string\">&#x27;hex&#x27;</span>), <span class=\"number\">16</span>),e,n)</span><br><span class=\"line\">c = long_to_bytes(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;c =\\n&#x27;</span>, c.encode(<span class=\"string\">&#x27;base64&#x27;</span>),n</span><br></pre></td></tr></table></figure></p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">c =</span><br><span class=\"line\">apxy3z3DgGnzaEedcUy3A49wAsqyyn9sqx6eYZL5iDrCq0Wjs8BOY2Ofza5wuaFigm32PVpO5jpu</span><br><span class=\"line\">Dgw9b6oX8KM2ZB9/dDmwQc7JKnAKhCQrIc1v9qt7iQbnTK0DTQj/xvQkz/IBeSjoWBmHOx4s0tDx</span><br><span class=\"line\">ZRAjOPui5wwAywNM3ynULEPczv+xN2v+6HBeoS2YuyfF5mq/pIAMPwZs+QpkuwxSbNQ6xPNP9Ox1</span><br><span class=\"line\">IeKz/41F7/D2fDsGB5CcFdAiQq+r95BhVeGzeaiQBpzwAXAPKIyO+fP6/M9XmpSJwjaMSiAUnksp</span><br><span class=\"line\">9KfVOXgEG9Z0FmxP6rgqPl0vU+rVeJ2RsTUYCSP8Vy+PD3PGwDDdUtNzvcEXKr2BKiNoOUxprBAt</span><br><span class=\"line\">yvcsmGqRLgDl1ZVgzSZ1U4MAmJ9x42mIU0XvolqaOCJZzaym1kJoBlw7/<span class=\"number\">7</span>+Nej4owEtan/c3TIkD</span><br><span class=\"line\">kr/gCenUD/8MSlvnfTUMGdQLkSht2BZiuiHxVVRVzY5ETG6v+w9AtDMC</span><br><span class=\"line\"><span class=\"number\">4600616808891590817884946117009414083548013610469076381106568481948720521467073218024827360073980550620353792084520767372304347132535784875671026563160583598386773718586111034826555689602824563172463446924287072570386712719870348862904936370894695108302490867826094352072132696743116741635111860205049129717948520534270924834318704244999690532431941248905257880347561221151841978982240191397364038490250930604211256385925496658620755582058753376328583001312846508295319286941837220522563729215928111164274042890696771820759856790994461944209269732769269559257608440686713206622111649275898426040931301005711446055819707704086201357712959922814300067907536161841255533171805313149332383712997091780368142625499055149806043238057037400510197255364471685815004154357049874205884682322443391374020169114833722616851257895369648472048116320266548560787733764126281102645474252013714507014577620450816459153848279084910457288549191</span></span><br></pre></td></tr></table></figure></p>\r\n<p>分析文件中代码题意，可以看出p为1024位的质数，r取值范围为[2,9]，指数e为65537，模数 <span class=\"math inline\">\\(n=p^r\\)</span>，且题中已给出密文c和模数n，因此可以爆破求解出r，得到r之后，可以求出p，由于n的素因子只有p，则 <span class=\"math inline\">\\(\\phi(n) = n *(1- \\frac{1}{p}) = p^r* (1- \\frac{1}{p}) = p^r - p^{r-1}\\)</span></p>\r\n<blockquote>\r\n<p><span class=\"math inline\">\\(\\phi(n)\\)</span>的含义为小于n且与n互素的整数的个数，<span class=\"math inline\">\\(\\phi(n)\\)</span>求法为，列出n的所有素因子，设为 <span class=\"math inline\">\\(p_1,p_2,p_3,...,p_n\\)</span>，则 <span class=\"math inline\">\\(\\phi(n)=n\\times(1-\\frac{1}{p_1})\\times(1-\\frac{1}{p_2})\\times\\cdots\\times(1-\\frac{1}{p_n})\\)</span> 当n素因子为 <span class=\"math inline\">\\(p, q\\)</span> 时，<span class=\"math inline\">\\(\\phi(n)=(p-1)\\times(q-1)\\)</span></p>\r\n</blockquote></li>\r\n<li><p>编写py代码如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> Cryptodome.Util.number <span class=\"keyword\">import</span> long_to_bytes, bytes_to_long</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\">c = <span class=\"string\">&#x27;&#x27;&#x27;apxy3z3DgGnzaEedcUy3A49wAsqyyn9sqx6eYZL5iDrCq0Wjs8BOY2Ofza5wuaFigm32PVpO5jpuDgw9b6oX8KM2ZB9/dDmwQc7JKnAKhCQrIc1v9qt7iQbnTK0DTQj/xvQkz/IBeSjoWBmHOx4s0tDxZRAjOPui5wwAywNM3ynULEPczv+xN2v+6HBeoS2YuyfF5mq/pIAMPwZs+QpkuwxSbNQ6xPNP9Ox1IeKz/41F7/D2fDsGB5CcFdAiQq+r95BhVeGzeaiQBpzwAXAPKIyO+fP6/M9XmpSJwjaMSiAUnksp9KfVOXgEG9Z0FmxP6rgqPl0vU+rVeJ2RsTUYCSP8Vy+PD3PGwDDdUtNzvcEXKr2BKiNoOUxprBAtyvcsmGqRLgDl1ZVgzSZ1U4MAmJ9x42mIU0XvolqaOCJZzaym1kJoBlw7/7+Nej4owEtan/c3TIkDkr/gCenUD/8MSlvnfTUMGdQLkSht2BZiuiHxVVRVzY5ETG6v+w9AtDMC&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">n = <span class=\"number\">4600616808891590817884946117009414083548013610469076381106568481948720521467073218024827360073980550620353792084520767372304347132535784875671026563160583598386773718586111034826555689602824563172463446924287072570386712719870348862904936370894695108302490867826094352072132696743116741635111860205049129717948520534270924834318704244999690532431941248905257880347561221151841978982240191397364038490250930604211256385925496658620755582058753376328583001312846508295319286941837220522563729215928111164274042890696771820759856790994461944209269732769269559257608440686713206622111649275898426040931301005711446055819707704086201357712959922814300067907536161841255533171805313149332383712997091780368142625499055149806043238057037400510197255364471685815004154357049874205884682322443391374020169114833722616851257895369648472048116320266548560787733764126281102645474252013714507014577620450816459153848279084910457288549191</span></span><br><span class=\"line\">e = <span class=\"number\">65537</span></span><br><span class=\"line\">c = bytes_to_long(base64.b64decode(c))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i  <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    p = gmpy2.iroot(n,i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p[<span class=\"number\">1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">p  = <span class=\"built_in\">int</span>(<span class=\"built_in\">str</span>(p[<span class=\"number\">0</span>]))</span><br><span class=\"line\">phi_n = n-(p**(i-<span class=\"number\">1</span>))</span><br><span class=\"line\">d = gmpy2.invert(e,phi_n)</span><br><span class=\"line\">m = gmpy2.powmod(c,d,p**i)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure></p>\r\n<p>得到flag为<code>flag&#123;7422e7ed91c8089a1f2aa323a6a0a6f9&#125;</code></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"PE文件格式","url":"/2022/09/12/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","content":"<h2 id=\"种类\">种类</h2>\r\n<span id=\"more\"></span>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>种类</th>\r\n<th>主扩展名</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>可执行系列</td>\r\n<td>EXE,SCR</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>库系列</td>\r\n<td>DLL,OCX,CPL,DRV</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>驱动程序系列</td>\r\n<td>SYS,VXD</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>对象文件系列</td>\r\n<td>OBJ</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>严格来说，除<code>OBJ</code>之外的所有文件都是可执行的，DLL，SYS等文件需要利用其他方法（调试器，服务等）执行。</p>\r\n<h2 id=\"基本结构\">基本结构</h2>\r\n<p>PE文件由<code>PE头+PE体</code>组成，其中PE头由<code>DOS头+DOS存根+NT头+节区头组成</code>，其示例图如下：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>文件偏移</th>\r\n<th><文件></文件></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>0000</td>\r\n<td>DOS头</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>0040</td>\r\n<td>DOS存根</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>00E0</td>\r\n<td>NT头</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>01D8</td>\r\n<td>节区头(\".text\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>0200</td>\r\n<td>节区头(\".data\")</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>0228</td>\r\n<td>节区头(\".rsrc\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>节区(\".text\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>节区头(\".data\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>节区头(\".rsrc\")</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>PE头与各节区尾部存在一个区域，称为NULL填充（NULL padding）。</p>\r\n<h3 id=\"varva\">VA&amp;RVA</h3>\r\n<p>VA指的是进程虚拟内存的绝对地址，RVA（Relative Virtual Address）指从某个基准位置开始的相对地址，其关系满足以下等式： RVA + Base = VA PE头内部信息大多以RVA形式存在。 &gt; 32位Windows中，进程虚拟内存共有4GB，VA值范围为0x00000000-0xFFFFFFFF</p>\r\n<h3 id=\"pe头\">PE头</h3>\r\n<h4 id=\"dos头\">DOS头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_DOS_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD e_magic;              <span class=\"comment\">// DOS signature: 4D5A (&quot;MZ&quot;)</span></span><br><span class=\"line\">    WORD e_cblp;</span><br><span class=\"line\">    WORD e_cp;</span><br><span class=\"line\">    WORD e_crlc;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    LONG e_lfanew              <span class=\"comment\">// NT头偏移</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>该结构体大小为0x40个字节，其中有两个重要成员：</p>\r\n<ul>\r\n<li>e_magic: DOS签名 (0x4D5A ⇒ \"MZ\")</li>\r\n<li>e_lfanew: 指示NT头的偏移（不同文件拥有可变值）</li>\r\n</ul>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ..............</span><br><span class=\"line\">00000010: b800 0000 0000 0000 4000 0000 0000 0000  ........@.......</span><br><span class=\"line\">00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">00000030: 0000 0000 0000 0000 0000 0000 e000 0000  ................</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"dos存根\">DOS存根</h4>\r\n<p>DOS存根(stub)位于DOS头下方，是可选项，大小不固定（无DOS存根，文件亦可正常运行），由代码和数据混合而成。</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th</span><br><span class=\"line\">00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno</span><br><span class=\"line\">00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS</span><br><span class=\"line\">00000070: 6d6f 6465 2e0d 0d0a 2400 0000 0000 0000  mode....$.......</span><br><span class=\"line\">00000080: ec85 5ba1 a8e4 35f2 a8e4 35f2 a8e4 35f2  ..[...5...5...5.</span><br><span class=\"line\">00000090: 6beb 3af2 a9e4 35f2 6beb 55f2 a9e4 35f2  k.:...5.k.U...5.</span><br><span class=\"line\">000000a0: 6beb 68f2 bbe4 35f2 a8e4 34f2 63e4 35f2  k.h...5...4.c.5.</span><br><span class=\"line\">000000b0: 6beb 6bf2 a9e4 35f2 6beb 6af2 bfe4 35f2  k.k...5.k.j...5.</span><br><span class=\"line\">000000c0: 6beb 6ff2 a9e4 35f2 5269 6368 a8e4 35f2  k.o...5.Rich..5.</span><br><span class=\"line\">000000d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br></pre></td></tr></table></figure>\r\n<p>40-4D区域为16位汇编指令，32位Windows中不会运行该指令，该指令内容为输出\"This program cannot be run in DOS mode\"，然后终止。</p>\r\n<h4 id=\"nt头\">NT头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class=\"line\"> DWORD Signature;</span><br><span class=\"line\"> IMAGE_FILE_HEADER FileHeader;</span><br><span class=\"line\"> IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class=\"line\">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>\r\n<p>第一个成员为签名结构体，其值为50540000h（“PE”00），另外两个成员分别为文件头（File Header）和可选头（Optional Header）结构体</p>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">000000e0: 5045 0000 4c01 0300 8752 0248 0000 0000  PE..L....R.H....</span><br><span class=\"line\">000000f0: 0000 0000 e000 0f01 0b01 070a 0078 0000  .............x..</span><br><span class=\"line\">00000100: 008c 0000 0000 0000 9d73 0000 0010 0000  .........s......</span><br><span class=\"line\">00000110: 0090 0000 0000 0001 0010 0000 0002 0000  ................</span><br><span class=\"line\">00000120: 0500 0100 0500 0100 0400 0000 0000 0000  ................</span><br><span class=\"line\">00000130: 0040 0100 0004 0000 ce26 0100 0200 0080  .@.......&amp;......</span><br><span class=\"line\">00000140: 0000 0400 0010 0100 0000 1000 0010 0000  ................</span><br><span class=\"line\">00000150: 0000 0000 1000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">00000160: 0476 0000 c800 0000 00b0 0000 0483 0000  .v..............</span><br><span class=\"line\">00000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">00000180: 0000 0000 0000 0000 5013 0000 1c00 0000  ........P.......</span><br><span class=\"line\">00000190: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">000001a0: 0000 0000 0000 0000 a818 0000 4000 0000  ............@...</span><br><span class=\"line\">000001b0: 5002 0000 d000 0000 0010 0000 4803 0000  P...........H...</span><br><span class=\"line\">000001c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class=\"line\">000001d0: 0000 0000 0000 0000 2e74 6578 7400 0000  ........</span><br></pre></td></tr></table></figure>\r\n<p>IMAGE_NT_HADERS结构体大小为F8</p>\r\n<h4 id=\"文件头\">文件头</h4>\r\n<p>文件头表示文件大致属性的IMAGE_FILE_HEADER结构体</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD Machine;</span><br><span class=\"line\">    WORD NumberOfSections;</span><br><span class=\"line\">    DWORD TimeDataStamp;</span><br><span class=\"line\">    DWORD PointerToSymbolTable;</span><br><span class=\"line\">    DWORD NumberOfSymbols;</span><br><span class=\"line\">    WORD SizeOfOptionalHeader;</span><br><span class=\"line\">    WORD Characteristics;</span><br><span class=\"line\">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>\r\n<ol type=\"1\">\r\n<li><p>Machine表示CPU类型，每个CPU其类型不一致，Intel x86 Machine码为14C。</p></li>\r\n<li><p>NumberOfSections表示文件中节区（代码、数据、资源等数据分为不同节区）数量。</p></li>\r\n<li><p>SizeOfOptionalHeader表示IMAGE_NT_HEADER结构体最后一个成员IMAGE_OPTIONAL_HEADER32的大小（PE装载器查看该值识别IMAGE_OPTIONAL_HEADER32结构体大小）</p>\r\n<blockquote>\r\n<p>PE32+格式文件中使用IMAGE_OPTIONAL_HEADER64结构体，两个结构体尺寸大小不同，需要SizeOfOptionalHeader表明结构体大小</p>\r\n</blockquote></li>\r\n<li><p>Characteristics 表明文件的属性，文件是否可以运行，是否为DLL文件等信息</p></li>\r\n</ol>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 35%\">\r\n<col style=\"width: 5%\">\r\n<col style=\"width: 58%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>Flag</th>\r\n<th>Value</th>\r\n<th>Description</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_RELOCS_STRIPPED</td>\r\n<td>0x0001</td>\r\n<td>Image only, Windows CE, and Microsoft Windows NT and later. This indicates that the file does not contain base relocations and must therefore be loaded at its preferred base address. If the base address is not available, the loader reports an error. The default behavior of the linker is to strip base relocations from executable (EXE) files.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_EXECUTABLE_IMAGE</td>\r\n<td>0x0002</td>\r\n<td>Image only. This indicates that the image file is valid and can be run. If this flag is not set, it indicates a linker error.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_LINE_NUMS_STRIPPED</td>\r\n<td>0x0004</td>\r\n<td>COFF line numbers have been removed. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_LOCAL_SYMS_STRIPPED</td>\r\n<td>0x0008</td>\r\n<td>COFF symbol table entries for local symbols have been removed. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_AGGRESSIVE_WS_TRIM</td>\r\n<td>0x0010</td>\r\n<td>Obsolete. Aggressively trim working set. This flag is deprecated for Windows 2000 and later and must be zero.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_LARGE_ADDRESS_AWARE</td>\r\n<td>0x0020</td>\r\n<td>Application can handle &gt; 2-GB addresses.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>0x0040</td>\r\n<td>This flag is reserved for future use.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_BYTES_REVERSED_LO</td>\r\n<td>0x0080</td>\r\n<td>Little endian: the least significant bit (LSB) precedes the most significant bit (MSB) in memory. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_32BIT_MACHINE</td>\r\n<td>0x0100</td>\r\n<td>Machine is based on a 32-bit-word architecture.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_DEBUG_STRIPPED</td>\r\n<td>0x0200</td>\r\n<td>Debugging information is removed from the image file.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>}IMAGE_FILE_REMOVABLE_RUN_ FROM_SWAP</td>\r\n<td>0x0400</td>\r\n<td>If the image is on removable media, fully load it and copy it to the swap file.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_NET_RUN_FROM_SWAP</td>\r\n<td>0x0800</td>\r\n<td>If the image is on network media, fully load it and copy it to the swap file.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_SYSTEM</td>\r\n<td>0x1000</td>\r\n<td>The image file is a system file, not a user program.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_DLL</td>\r\n<td>0x2000</td>\r\n<td>The image file is a dynamic-link library (DLL). Such files are considered executable files for almost all purposes, although they cannot be directly run.</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>IMAGE_FILE_UP_SYSTEM_ONLY</td>\r\n<td>0x4000</td>\r\n<td>The file should be run only on a uniprocessor machine.</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>IMAGE_FILE_BYTES_REVERSED_HI</td>\r\n<td>0x8000</td>\r\n<td>Big endian: the MSB precedes the LSB in memory. This flag is deprecated and should be zero.</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>000000e0: 5045 0000 4c01 0300 8752 0248 0000 0000 PE..L....R.H.... 000000f0: 0000 0000 e000 0f01 0b01 070a 0078 0000 .............x..</p>\r\n<h4 id=\"nt头可选头\">NT头：可选头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class=\"line\">    DWORD VirtualAddress;</span><br><span class=\"line\">    DWORD Size;</span><br><span class=\"line\">&#125;IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_NUMBER_DIRECTORY_ENTRIES 16</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD Magic; <span class=\"comment\">// IMAGE_OPTIONAL_HEADER32时为10B，IMAGE_OPTIONAL_HEADER64时为20B，</span></span><br><span class=\"line\">    BYTE MajorLinkerVersion;</span><br><span class=\"line\">    BYTE MinorLinkerVersion;</span><br><span class=\"line\">    DWORD SizeOfCode;</span><br><span class=\"line\">    DWORD SizeOfInitializedData;</span><br><span class=\"line\">    DWORD SizeOfUninitializedData;</span><br><span class=\"line\">    DWORD AddressOfEntryPoint;  <span class=\"comment\">// 持有EP的RVA值，指出程序最先执行的代码起始地址</span></span><br><span class=\"line\">    DWORD BaseOfCode;</span><br><span class=\"line\">    DOWRD BaseOfData;</span><br><span class=\"line\">    DWORD ImageBase;  <span class=\"comment\">// PE文件被加载到内存时，表示文件优先装入地址</span></span><br><span class=\"line\">    DWORD SectionAlignment;  <span class=\"comment\">// 指定节区在内存中的最小单位</span></span><br><span class=\"line\">    DWORD FileAlignment; <span class=\"comment\">// 指定节区在磁盘文件中的最小单位</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    DWORD SizeOfImage;  <span class=\"comment\">// 指定PE Image在虚拟内存中所占空间大小，一般而言，文件大小与加载到内存中大小不同</span></span><br><span class=\"line\">    DWORD SizeOfHeaders; <span class=\"comment\">// 指出整个PE头大小，必须为FileAlignment整数倍，第一节区所在位置距文件开始偏移量相同</span></span><br><span class=\"line\">    WORD Subsystem;  <span class=\"comment\">// 区分系统驱动文件与普通可执行文件</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    DWORD NumberOfRvaAndSizes;  <span class=\"comment\">// 指定DataDirectory数组个数</span></span><br><span class=\"line\">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class=\"line\">&#125;IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>\r\n<p>DataDirectory数组内容如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">DataDirectory[0] = EXPORT Directory</span><br><span class=\"line\">DataDirectory[1] = IMPORT Directory</span><br><span class=\"line\">DataDirectory[2] = RESOURCE Directory</span><br><span class=\"line\">DataDirectory[3] = EXCEPTION Directory</span><br><span class=\"line\">DataDirectory[4] = SECURITY Directory</span><br><span class=\"line\">DataDirectory[5] = BASERELOC Directory</span><br><span class=\"line\">DataDirectory[6] = DEBUG Directory</span><br><span class=\"line\">DataDirectory[7] = COPYRIGHT Directory</span><br><span class=\"line\">DataDirectory[8] = GLOBALPTR Directory</span><br><span class=\"line\">DataDirectory[9] = TLS Directory</span><br><span class=\"line\">DataDirectory[A] = LOAD_CONFIG Directory</span><br><span class=\"line\">DataDirectory[B] = BOUND_IMPORT Directory</span><br><span class=\"line\">DataDirectory[C] = IAT Directory</span><br><span class=\"line\">DataDirectory[D] = DELAY_IMPORT Directory</span><br><span class=\"line\">DataDirectory[E] = COM_DESCRIPTOR Directory</span><br><span class=\"line\">DataDirectory[F] = Reserved Directory</span><br></pre></td></tr></table></figure>\r\n<p>重点关注EXPORT/IMPORT/RESOURCE/TLS Direction</p>\r\n<h4 id=\"节区头\">节区头</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SIZEOF_SHORT_NAME     8</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class=\"line\">    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> </span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        DWORD PhysicalAddress;</span><br><span class=\"line\">        DWORD VirtualSize; <span class=\"comment\">// 内存中节区所占大小</span></span><br><span class=\"line\">    &#125; Misc;</span><br><span class=\"line\">    DWORD VirtualAddress; <span class=\"comment\">// 内存中节区起始地址（RVA）</span></span><br><span class=\"line\">    DWORD SizeOfRawData; <span class=\"comment\">// 磁盘文件中节区所占大小</span></span><br><span class=\"line\">    DWORD PointerToRawData; <span class=\"comment\">// 磁盘文件中节区起始位置</span></span><br><span class=\"line\">    DWORD PointerToRelocations;</span><br><span class=\"line\">    DWORD PointerToLinenumbers;</span><br><span class=\"line\">    WORD NumberOfRelocations;</span><br><span class=\"line\">    WORD NumberOfLinenumbers;</span><br><span class=\"line\">    DWORD Characteristics; <span class=\"comment\">// 节区属性</span></span><br><span class=\"line\">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>\r\n<p>节区头定义了各节区属性。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_CNT_CODE                  0x00000020</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA      0x00000040</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA    0x00000080</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_MEM_EXECUTE               0x20000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_MEM_READ                  0x40000000  <span class=\"comment\">// section is readable</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IMAGE_SCN_MEM_WRITE                 0x80000000      <span class=\"comment\">// section is writable</span></span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"rva-to-raw\">RVA to RAW</h3>\r\n<p>内存地址与文件偏移的映射称为 RVA to RAW，方法如下：</p>\r\n<ol type=\"1\">\r\n<li>查找RVA所在节区</li>\r\n<li>使用公式计算文件偏移</li>\r\n</ol>\r\n<blockquote>\r\n<p>RAW-PointerToRawData = RVA - VirtualAddress RAW = RVA - VirtualAddress + PointerToRawData</p>\r\n</blockquote>\r\n<p>两者相对之差+文件偏移基址 = RAW</p>\r\n<h3 id=\"pe体\">PE体</h3>\r\n<h4 id=\"导入表\">导入表</h4>\r\n<p><strong>IMAGE_IMPORT_DESCRIPTOR</strong> IMAGE_IMPORT_DESCRIPTOR结构体记录PE文件需导入哪些库文件。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        DWORD Characteristics;</span><br><span class=\"line\">        DWORD OriginalFirstThunk; <span class=\"comment\">// INT(Import Name Table) address (RAV)</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    DWORD TimeDateStamp;</span><br><span class=\"line\">    DWORD ForwarderChain;</span><br><span class=\"line\">    DWORD Name;                 <span class=\"comment\">// library name string address (RAV)</span></span><br><span class=\"line\">    DWORD FirstThunk;           <span class=\"comment\">// IAT(Import Address Table) address (RAV)</span></span><br><span class=\"line\">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class=\"line\">    WORD Hint;    <span class=\"comment\">// ordinal</span></span><br><span class=\"line\">    BYTE NAME[<span class=\"number\">1</span>]; <span class=\"comment\">// function name string</span></span><br><span class=\"line\">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>\r\n<p>PE文件往往需要导入多个库，导入多少个库就需要多少个IMAGE_IMPORT_DESCRIPTOR结构体构成的数组，以NULL结构体结束，其中结构体重要成员如下：</p>\r\n<ul>\r\n<li>OriginalFirstThunk：INT地址（RAV）</li>\r\n<li>Name：库名字字符串地址（RAV）</li>\r\n<li>FirstThunk：IAT地址（RAV）</li>\r\n</ul>\r\n<blockquote>\r\n<p>注：INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针。</p>\r\n</blockquote>\r\n<p>PE装载器把导入函数输入至IAT顺序：</p>\r\n<ol type=\"1\">\r\n<li>读取IID的Name成员，获取字符串；(\"kernel32.dll\")</li>\r\n<li>装载相应库；（LoadLibrary(\"kernel32.dll\"）</li>\r\n<li>读取IID中OriginalFirstThunk成员，获取INT地址；</li>\r\n<li>逐一读取INT中数组的值，获取IMAGE_IMPORT_BY_NAME地址；</li>\r\n<li>使用IMAGE_IMPORT_BY_NAME的hint（ordinal）或Name成员，获取相应函数起始地址。（GetProcAddress(\"GetCurrentThreadld\"）</li>\r\n<li>读取IID中FirstThunk成员，获取IAT地址。</li>\r\n<li>将第5步获得的地址填入第6步得到的IAT数组中。</li>\r\n<li>重复步骤4-7，直到INT结束。</li>\r\n</ol>\r\n<p>IID位于PE体中，但其位置信息位于PE头中，IMAGE_OPTIONAL_HEADERXX.DataDirectory[1].VirutalAddress的值为IID数组起始地址（RAV）。</p>\r\n<h4 id=\"导出表\">导出表</h4>\r\n<p>EAT是windows方便其他程序调用库相关函数的核心机制，通过EAT才能准确从相应库中求得导出函数的起始地址。PE内 <code>IMAGE_EXPORT_DESCRIPTOR</code> 结构体保存着导出信息，且仅有一个该结构体。</p>\r\n<p><strong>IMAGE_EXPORT_DESCRIPTOR</strong> IMAGE_EXPORT_DESCRIPTOR结构体代码如下所示：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_EXPORT_DESCRIPTOR</span> &#123;</span></span><br><span class=\"line\">    DWORD Characteriscs;</span><br><span class=\"line\">    DWORD TimeDateStamp;</span><br><span class=\"line\">    WORD MajorVerion;</span><br><span class=\"line\">    WORD MinorVerion;</span><br><span class=\"line\">    DWORD NAME;               <span class=\"comment\">// address of library name</span></span><br><span class=\"line\">    DWORD Base;               <span class=\"comment\">// ordinal base</span></span><br><span class=\"line\">    DWORD NumberOfFunctions;  <span class=\"comment\">// number of function;</span></span><br><span class=\"line\">    DWORD NumberoOfNames;     <span class=\"comment\">// number of name;</span></span><br><span class=\"line\">    DWORD AddrssOfFunctions;  <span class=\"comment\">// address of function start address</span></span><br><span class=\"line\">    DWORD AddressOfNames;     <span class=\"comment\">// address of function name string array</span></span><br><span class=\"line\">    DWORD AddressOfNameOrdinals; <span class=\"comment\">// address of ordinal array</span></span><br><span class=\"line\">&#125; IMAGE_EXPORT_DESCRIPTOR, *PIMAGE_EXPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>\r\n<p>其中重要成员如下：</p>\r\n<ul>\r\n<li>NumberOfFunctions：实际Export函数的个数</li>\r\n<li>NumberOfNames：Export函数中具名函数的个数</li>\r\n<li>AddressOfFunctions：Export函数地址数组</li>\r\n<li>AddessOfNames：函数名称地址数组</li>\r\n<li>AddesssOfOrdinals：Ordinal地址数组</li>\r\n</ul>\r\n<p>GetProcAddress()操作原理：</p>\r\n<ol type=\"1\">\r\n<li>利用AddressOfNames转到函数名称数组；</li>\r\n<li>逐个便历数组，获取字符串，与参数进行比较，相同时得到索引（name_index)</li>\r\n<li>通过AddressOfNameOrdinals转到Ordinal地址数组；</li>\r\n<li>在ordinal数组中通过name_index得到ordinal值；</li>\r\n<li>利用AddressOfFunctions成员转到“函数地址数组”（EAT）</li>\r\n<li>在EAT中使用ordinal作为索引，获得指定函数地址。</li>\r\n</ol>\r\n","categories":["逆向工程核心原理"],"tags":["book","reverse"]},{"title":"RSA 算法各类攻击","url":"/2022/09/12/RSA-%E7%AE%97%E6%B3%95%E5%90%84%E7%B1%BB%E6%94%BB%E5%87%BB/","content":"<h2 id=\"dp泄漏\">dp泄漏</h2>\r\n<h3 id=\"原理\">原理</h3>\r\n<p>基本数学公式 <span class=\"math display\">\\[a = kb + p\\]</span> <span class=\"math display\">\\[a\\mod b = p\\]</span> 已知条件：<span class=\"math inline\">\\(dp, n, e, c\\)</span></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"rsa的基本公式\">RSA的基本公式</h3>\r\n<p><span class=\"math display\">\\[c \\equiv m^e\\mod n\\]</span> <span class=\"math display\">\\[m \\equiv c^d\\mod n\\]</span> <span class=\"math display\">\\[\\phi ( n ) = ( p - 1 ) \\times ( q - 1 ) \\]</span> <span class=\"math display\">\\[d \\times e \\equiv 1\\mod \\phi( n )\\]</span></p>\r\n<h3 id=\"dp是什么\">dp是什么</h3>\r\n<p><span class=\"math display\">\\[dp \\equiv d\\mod( p − 1 )\\]</span></p>\r\n<h3 id=\"推导过程\">推导过程</h3>\r\n<p>将该公式变形：</p>\r\n<p><span class=\"math display\">\\[dp \\equiv d\\mod ( p − 1 )\\\\\r\n\\Rightarrow dp \\times e\\equiv d \\times e \\mod (p-1)\\\\\r\n\\Rightarrow d \\times e \\equiv k \\times (p-1) + dp \\times e\\]</span></p>\r\n<p>变形后的公式与下式结合</p>\r\n<p><span class=\"math display\">\\[d\\times e \\equiv1mod\\phi (n)\\]</span></p>\r\n<p>因为：</p>\r\n<p><span class=\"math display\">\\[\\phi(n)=(p-1)\\times(q-1)\\]</span></p>\r\n<p>所以我们可以进行变形：</p>\r\n<p><span class=\"math display\">\\[\\Rightarrow d\\times e \\equiv 1\\mod(p-1) \\times (q-1)\\]</span></p>\r\n<p>得到：</p>\r\n<p><span class=\"math display\">\\[ k \\times (p-1) + dp \\times e=1mod\\phi (n)\\]</span></p>\r\n<p>再次变形：</p>\r\n<p><span class=\"math display\">\\[k_1 \\times (p-1) + dp \\times e =1mod (p-1)\\times(q-1)\\]</span></p>\r\n<p>结合：</p>\r\n<p><span class=\"math display\">\\[k_1 \\times (p-1) + dp \\times e = k_2 \\times (p-1) \\times (q-1) +1\\\\\r\n\\Rightarrow dp \\times e = [k_2 \\times (p-1) \\times (q-1) +1] - [k_1 \\times (p-1)]\\\\ \\Rightarrow dp \\times e = [k_2 \\times (q-1) - k_1] \\times (p-1) +1\\]</span></p>\r\n<p>设：<span class=\"math inline\">\\(X = k_2 \\times (q-1) - k_1\\)</span> <span class=\"math display\">\\[\\Rightarrow dp \\times e = X \\times (p-1) +1\\\\\r\n\\Rightarrow dp &lt; p-1\\\\\r\n\\Rightarrow X &lt; e\\\\\r\n\\Rightarrow X \\in (0,e)\\]</span></p>\r\n<h3 id=\"求p\">求P</h3>\r\n<p>遍历X（65537种可能），求出p-1，得到p且能被n整除，接下来便是常规的RSA解法</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">65538</span>):</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (dp*e-<span class=\"number\">1</span>) % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">      p = (dp*e-<span class=\"number\">1</span>)//i+<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % p == <span class=\"number\">0</span>:</span><br><span class=\"line\">            q = n // p</span><br><span class=\"line\">            phi_n = (p-<span class=\"number\">1</span>)*(q-<span class=\"number\">1</span>)</span><br><span class=\"line\">            d = gmpy2.invert(e, phi_n)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"dpdq泄漏\">dp,dq泄漏</h2>\r\n<h3 id=\"已知条件\">已知条件</h3>\r\n<p>公式如下：</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\\ c\\equiv m^e\\mod n\\\\\r\nm\\equiv c^d\\mod n\\\\\r\n\\phi(n)=(p-1)\\times(q-1)\\\\\r\nd\\times e\\equiv 1\\mod\\phi(n)\\\\\r\ndp\\equiv d\\mod(p-1)\\\\\r\ndq\\equiv d\\mod(q-1)\\end{align}\\]</span> 已知 <span class=\"math inline\">\\(c,e,dp,dq\\)</span>，求 <span class=\"math inline\">\\(m\\)</span></p>\r\n<h3 id=\"公式推导\">公式推导</h3>\r\n<p>利用中国剩余定理，可以得到</p>\r\n<p><span class=\"math display\">\\[\\begin{align}m_1\\equiv c^d\\mod p\\\\\r\nm_2\\equiv c^d\\mod q\\end{align}\\]</span> 由公式7可得 <span class=\"math display\">\\[\\begin{align}c^d=m_1+p*k\\end{align}\\]</span> 代入公式8，可得 <span class=\"math display\">\\[\\begin{align}m_2\\equiv (m_1+p*k)\\mod q\\end{align}\\]</span> 将两边同时减去<span class=\"math inline\">\\(m_1\\)</span> <span class=\"math display\">\\[\\begin{align}m_2-m_1\\equiv pk\\mod q\\end{align}\\]</span> 因为 <span class=\"math inline\">\\(gcd(p,q)=1\\)</span>，可求p的逆元，得到 <span class=\"math display\">\\[\\begin{align}(m_2-m_1)*p^{-1}\\equiv k\\mod q\\\\\r\n\\Rightarrow k\\equiv (m_2-m_1)*p^{-1}\\mod q\\end{align}\\]</span> 将公式9和公式13合并，得到 <span class=\"math display\">\\[\\begin{align}c^d=((m_2-m_1)*p^{-1}\\mod q)*p+m_1\\end{align}\\]</span> 代入公式2，得到 <span class=\"math display\">\\[\\begin{align}m\\equiv(((m_2-m_1)*p^{-1}\\mod q)*p+m_1)\\mod n\\end{align}\\]</span> 将公式5，6分别代入7，8，得到 <span class=\"math display\">\\[\\begin{align}m_1\\equiv c^{dq\\mod(q-1)}\\mod q\\\\\r\nm_2\\equiv c^{dp\\mod(p-1)}\\mod p\\end{align}\\]</span> 得到 <span class=\"math display\">\\[\\begin{align}m_1\\equiv c^{dq}\\mod q\\\\\r\nm_2\\equiv c^{dp}\\mod p\\end{align}\\]</span> 算出 <span class=\"math inline\">\\(m_1,m_2\\)</span> 后，代入公式15，即可求出 <span class=\"math inline\">\\(m\\)</span></p>\r\n<h3 id=\"求解代码\">求解代码</h3>\r\n<p>编写代码如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">m1 = gmpy2.powmod(c, dq, q)</span><br><span class=\"line\">m2 = gmpy2.powmod(c, dp, p)</span><br><span class=\"line\">m = (((m2-m1) * gmpy2.invert(p, q) % q) * p + m1) % n</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"共模攻击\">共模攻击</h2>\r\n<h3 id=\"已知条件-1\">已知条件</h3>\r\n<p>已知：<span class=\"math inline\">\\(c_1,c_2,e_1,e_2,n\\)</span> <span class=\"math display\">\\[\\begin{align}\r\nc_1=m^{e_1}\\mod n\\\\\r\nc_2 = m^{e_2}\\mod n\r\n\\end{align}\\]</span></p>\r\n<h3 id=\"公式推导-1\">公式推导</h3>\r\n<p>首先假设 <span class=\"math inline\">\\(gcd(e_1,e_2)=1\\)</span>，此时则有 <span class=\"math inline\">\\(k_1*e_1+k_2*e_2=1\\)</span>，可以得到 <span class=\"math display\">\\[\\begin{align*}\r\n(c_1^{k_1}*c_2^{k_2})\\mod n &amp; = ((m^{e_1}\\mod n)^{k_1}*(m^{e_2}\\mod n)^{k_2})\\mod n\\\\\r\n&amp; = ((m^{e_1})^{k_1}*(m^{e_2})^{k_2})\\mod n\\\\\r\n&amp; = ((m^{e_1k_1}*(m^{e_2k_2})\\mod n\\\\\r\n&amp; = m^{e_1k_1+e_2k_2}\\mod n\\\\\r\n&amp; = m\\mod n\r\n\\end{align*}\\]</span></p>\r\n<h3 id=\"求解代码-1\">求解代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">common_n_attack</span>(<span class=\"params\">n,e1,e2,c1,c2</span>):</span><br><span class=\"line\">   _,k1,k2 = gmpy2.gcdext(e1, e2)</span><br><span class=\"line\">   <span class=\"keyword\">if</span> k1 &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      k1 = -k1</span><br><span class=\"line\">      c1 = gmpy2.invert(c1, n)</span><br><span class=\"line\">   <span class=\"keyword\">elif</span> k2 &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      k2 = -k2</span><br><span class=\"line\">      c2 = gmpy2.invert(c2, n)</span><br><span class=\"line\">   m = (c1**k1*c2**k2)%n</span><br><span class=\"line\">   <span class=\"keyword\">return</span> m</span><br></pre></td></tr></table></figure>\r\n","categories":["CTF"],"tags":["crypto","RSA"]},{"title":"weak DSA","url":"/2022/09/12/weak-DSA/","content":"<h2 id=\"weak-dsa\">weak DSA</h2>\r\n<ol type=\"1\">\r\n<li><p>题目： 打开附件，看到存在五个文件</p>\r\n<p><span id=\"more\"></span></p>\r\n<p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ll</span></span><br><span class=\"line\">总用量 24</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  653  2月 20  2019 dsa_public.pem</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  514  2月 20  2019 message1</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt  374  2月 20  2019 message2</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt   46  2月 20  2019 sign1</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt   46  2月 20  2019 sign2</span><br><span class=\"line\">-rwxrw-rw- 1 mrt mrt 1376  2月 20  2019 tipcode.py</span><br></pre></td></tr></table></figure></p>\r\n<p>题目意思为弱DSA签名算法，判断用同一个K参数进行签名，并提供了2个message和2个sign签名文件。</p></li>\r\n<li><p>解题</p>\r\n<ul>\r\n<li>使用openssl命令查看文件签名</li>\r\n</ul>\r\n<p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">openssl asn1parse -inform der -<span class=\"keyword\">in</span> sign1</span> </span><br><span class=\"line\">    0:d=0  hl=2 l=  44 cons: SEQUENCE          </span><br><span class=\"line\">    2:d=1  hl=2 l=  20 prim: INTEGER           :3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span><br><span class=\"line\">24:d=1  hl=2 l=  20 prim: INTEGER           :2C507D83CC9DB08B3D13B059A37B846189D32EC8</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">openssl asn1parse -inform der -<span class=\"keyword\">in</span> sign2</span></span><br><span class=\"line\">    0:d=0  hl=2 l=  44 cons: SEQUENCE          </span><br><span class=\"line\">    2:d=1  hl=2 l=  20 prim: INTEGER           :3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span><br><span class=\"line\">24:d=1  hl=2 l=  20 prim: INTEGER           :704302989E4D680DEDF760E354C1F23760FA95BE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>第一项内容为r，后一内容为s，可以看出sign1和sign2共享了密钥k，因为其r值<code>3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</code>一致。</p>\r\n<ul>\r\n<li>查看公钥文件内容</li>\r\n</ul>\r\n<p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ openssl dsa -<span class=\"keyword\">in</span> dsa_public.pem -text -noout -pubin</span><br><span class=\"line\"><span class=\"built_in\">read</span> DSA key</span><br><span class=\"line\">pub: </span><br><span class=\"line\">    5e:ef:ca:12:9c:84:b4:3d:e1:d0:1e:c4:d3:85:b4:</span><br><span class=\"line\">    48:b8:e2:c2:77:fb:49:e0:01:d1:1b:f9:18:43:<span class=\"built_in\">fc</span>:</span><br><span class=\"line\">    da:5a:31:99:0e:93:67:d2:19:49:d2:1d:14:23:45:</span><br><span class=\"line\">    23:a7:1a:22:69:92:85:a9:f9:37:17:f8:57:c0:4e:</span><br><span class=\"line\">    73:73:03:c1:aa:f3:35:38:9d:ba:af:5a:3b:4d:27:</span><br><span class=\"line\">    a8:3f:03:5d:02:5a:da:27:b6:d7:0c:52:<span class=\"built_in\">fc</span>:78:a1:</span><br><span class=\"line\">    67:41:01:84:b2:46:82:f0:d6:5b:43:05:2b:ab:05:</span><br><span class=\"line\">    38:6b:50:d6:fa:be:3b:<span class=\"built_in\">df</span>:89:<span class=\"built_in\">df</span>:bb:72:51:48:ab:</span><br><span class=\"line\">    d4:9e:a2:63:2c:7d:3b:7d</span><br><span class=\"line\">P:   </span><br><span class=\"line\">    00:bb:65:76:c4:bd:9b:1e:64:9f:dc:1b:5f:0d:35:</span><br><span class=\"line\">    ae:db:c0:c0:85:bb:3c:cf:d7:1a:a7:9f:e9:d4:29:</span><br><span class=\"line\">    12:23:3c:84:a0:d2:e5:bc:d7:7d:fb:a3:bb:3d:27:</span><br><span class=\"line\">    b2:bd:db:a6:e7:21:72:f6:6b:94:d1:f6:11:86:d2:</span><br><span class=\"line\">    6f:ee:44:38:f9:71:1f:d5:a2:96:e3:09:e3:bd:76:</span><br><span class=\"line\">    a6:7d:88:77:2f:1b:2e:fe:77:66:77:24:49:81:da:</span><br><span class=\"line\">    55:27:5a:2f:99:0e:8f:b3:1a:18:5d:dc:<span class=\"built_in\">fc</span>:4b:b4:</span><br><span class=\"line\">    15:65:67:fa:6b:62:a0:e7:26:74:<span class=\"built_in\">fc</span>:92:db:ef:8c:</span><br><span class=\"line\">    7e:cb:fe:95:88:3f:04:4f:c5</span><br><span class=\"line\">Q:   </span><br><span class=\"line\">    00:8a:92:14:5a:fa:41:1f:5d:90:51:ef:a4:a3:74:</span><br><span class=\"line\">    3a:c9:98:85:76:7d</span><br><span class=\"line\">G:   </span><br><span class=\"line\">    05:fb:e9:06:39:a3:b2:f3:36:8d:4d:47:fd:f2:42:</span><br><span class=\"line\">    8c:e3:80:<span class=\"built_in\">cd</span>:8e:84:ae:fe:90:eb:4a:fd:21:2a:99:</span><br><span class=\"line\">    a9:59:3e:b0:1f:f6:d6:26:48:a0:16:67:bf:f9:72:</span><br><span class=\"line\">    4e:4b:01:96:6e:f6:0b:f1:b2:77:6d:a2:a1:81:a2:</span><br><span class=\"line\">    6e:5e:60:8f:ff:94:a3:e3:92:38:4a:cf:62:1c:23:</span><br><span class=\"line\">    e4:93:b6:3c:24:7c:30:b3:ea:<span class=\"built_in\">dd</span>:e4:0d:4c:36:e5:</span><br><span class=\"line\">    55:27:31:8a:84:d5:87:16:2c:d7:40:5d:66:85:22:</span><br><span class=\"line\">    60:23:8c:48:3e:72:bf:10:71:85:10:7a:6e:43:76:</span><br><span class=\"line\">    90:58:77:bc:82:8c:1d:20</span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>编写脚本如下：</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> DSA</span><br><span class=\"line\"><span class=\"keyword\">from</span> hashlib <span class=\"keyword\">import</span> sha1</span><br><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;dsa_public.pem&#x27;</span>) <span class=\"keyword\">as</span> f: <span class=\"comment\"># 读取公钥文件</span></span><br><span class=\"line\">    key = DSA.import_key(f.read())</span><br><span class=\"line\">    y = key.y</span><br><span class=\"line\">    g = key.g</span><br><span class=\"line\">    p = key.p</span><br><span class=\"line\">    q = key.q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;message1&#x27;</span>, encoding = <span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data1 = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;message2&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    data2 = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">sha = sha1() <span class=\"comment\"># sha1 hash</span></span><br><span class=\"line\">sha.update(data1.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">m1 = <span class=\"built_in\">int</span>(sha.hexdigest(), <span class=\"number\">16</span>) <span class=\"comment\"># 获取message1内容sha1哈希值</span></span><br><span class=\"line\"></span><br><span class=\"line\">sha = sha1()</span><br><span class=\"line\">sha.update(data2.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">m2 = <span class=\"built_in\">int</span>(sha.hexdigest(), <span class=\"number\">16</span>) <span class=\"comment\"># 获取message2内容sha1哈希值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(m1, m2)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 = <span class=\"number\">0x2C507D83CC9DB08B3D13B059A37B846189D32EC8</span> <span class=\"comment\"># 签名文件sign1 s 值</span></span><br><span class=\"line\">s2 = <span class=\"number\">0x704302989E4D680DEDF760E354C1F23760FA95BE</span> <span class=\"comment\"># 签名文件sign2 s 值</span></span><br><span class=\"line\">r = <span class=\"number\">0x3A9CBF6D944B37943CF4FA72374D3FF87D55C8AB</span></span><br><span class=\"line\"></span><br><span class=\"line\">ds = s2 - s1</span><br><span class=\"line\">dm = m2 - m1</span><br><span class=\"line\">k = gmpy2.mul(dm, gmpy2.invert(ds, q))</span><br><span class=\"line\">k = gmpy2.f_mod(k, q)</span><br><span class=\"line\">tmp = gmpy2.mul(k, s1) - m1</span><br><span class=\"line\">x = tmp * gmpy2.invert(r,q)</span><br><span class=\"line\">x = gmpy2.f_mod(x, q) <span class=\"comment\"># x is the private key</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(x))</span><br></pre></td></tr></table></figure>\r\n<p>脚本运行结果如下：</p>\r\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./exp.py </span><br><span class=\"line\">292662942869370611771676609473484271930756369187 94408533737537379184444430172035752205145606426</span><br><span class=\"line\">301024118086430365762957779330181182629483123408</span><br></pre></td></tr></table></figure></p>\r\n<p>因此flag为<code>301024118086430365762957779330181182629483123408</code></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto","DSA"]},{"title":"不一样的flag","url":"/2022/09/12/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/","content":"<h2 id=\"题目地址\"><a href=\"https://buuoj.cn/challenges#%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag\">题目地址</a></h2>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<span id=\"more\"></span>\r\n<p>PEID查看无壳，拖入IDA反编译，结果如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> v3; <span class=\"comment\">// [esp+17h] [ebp-35h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v4; <span class=\"comment\">// [esp+30h] [ebp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v5; <span class=\"comment\">// [esp+34h] [ebp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">signed</span> <span class=\"type\">int</span> v6; <span class=\"comment\">// [esp+38h] [ebp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [esp+3Ch] [ebp-10h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+40h] [ebp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  __main();</span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v5 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">qmemcpy</span>(&amp;v3, _data_start__, <span class=\"number\">0x19</span>u);  <span class=\"comment\">// &#x27;*11110100001010000101111#&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;you can choose one action to execute&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;1 up&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;2 down&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;3 left&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;4 right\\n:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;v6);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v6 == <span class=\"number\">2</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( v6 &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 == <span class=\"number\">3</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        --v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( v6 != <span class=\"number\">4</span> )</span><br><span class=\"line\">LABEL_13:</span><br><span class=\"line\">          <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        ++v5;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 != <span class=\"number\">1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_13;</span><br><span class=\"line\">      --v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1</span>; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( *(&amp;v4 + i) &lt; <span class=\"number\">0</span> || *(&amp;v4 + i) &gt; <span class=\"number\">4</span> )</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *((_BYTE *)&amp;v8 + <span class=\"number\">5</span> * v4 + v5 - <span class=\"number\">41</span>) == <span class=\"string\">&#x27;1&#x27;</span> )</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *((_BYTE *)&amp;v8 + <span class=\"number\">5</span> * v4 + v5 - <span class=\"number\">41</span>) == <span class=\"string\">&#x27;#&#x27;</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\nok, the order you enter is the flag!&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>分析代码，初始化将_data_start__字符串<code>*11110100001010000101111#</code>复制到v3处，后续逻辑为，用户输入数字1234分别代表上下左右，分别对应变量 ++v4、--v5、++v5、--v4。 然后将v5和v4作为字符串数组索引，取v3<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>字符串数组对应的值，判断该值与'1'和'#'的关系。</p>\r\n<p>将<code>*11110100001010000101111#</code>数组按5位一组排列，即为： *1111 01000 01010 00010 1111# 因此解法为走迷宫，从*开始，每一步走到0，直到遇到符号#。</p>\r\n<h3 id=\"得到flag222441144222\">得到flag：<code>222441144222</code></h3>\r\n<section class=\"footnotes\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\" role=\"doc-endnote\"><p>v3地址为[esp+17h]，v8地址为[esp+40h]，两者相距 29h即41。<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"分组加密模式","url":"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","content":"<p>There are five types of operations in block cipher modes, ECB (Electronic Code Block) mode, CBC (Cipher Block Chaining) mode, CFB (Cipher Feedback) mode, OFB (Output Feedback) mode and CTR ( Counter) mode.</p>\r\n<span id=\"more\"></span>\r\n<p>Where ECB and CBC mode works on block ciphers, and CFB and OFB mode works on block ciphers acting as stream ciphers. ECB is used for transmitting a single value insecure manner, CBC is used for encrypting blocks of text authentication, CFB is used for transmitting an encrypted stream of data authentication, OFB is used for transmitting an encrypted stream of data, CTR is used for transmitting block-oriented applications.</p>\r\n<h2 id=\"block-cipher-modes-of-operation\">Block cipher modes of operation</h2>\r\n<p>There are 5 modes of operation in the block cipher.</p>\r\n<h3 id=\"ecb-mode\">1. ECB mode</h3>\r\n<p>ECB mode stands for Electronic Code Block Mode. It is one of the simplest modes of operation. In this mode, the plain text is divided into a block where each block is 64 bits. Then each block is encrypted separately. The same key is used for the encryption of all blocks. Each block is encrypted using the key and makes the block of ciphertext.</p>\r\n<ul>\r\n<li>At the receiver side, the data is divided into a block, each of 64 bits. The same key which is used for encryption is used for decryption. It takes the 64-bit ciphertext and, by using the key convert the ciphertext into plain text.</li>\r\n<li>As the same key is used for all blocks’ encryption, if the block of plain text is repeated in the original message, then the ciphertext’s corresponding block will also repeat. As the same key used for tor all block, to avoid the repetition of block ECB mode is used for an only small message where the repetition of the plain text block is less.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/b13d6ff681264bd9afeb423dec608e63.webp\" alt=\"ecb\"><figcaption aria-hidden=\"true\">ecb</figcaption>\r\n</figure>\r\n<h3 id=\"cbc-mode\">2. CBC Mode</h3>\r\n<ul>\r\n<li>CBC Mode stands for Cipher block Mode at the sender side; the plain text is divided into blocks. In this mode, IV(Initialization Vector) is used, which can be a random block of text. IV is used to make the ciphertext of each block unique.</li>\r\n<li>The first block of plain text and IV is combined using the XOR operation and then encrypted the resultant message using the key and form the first block of ciphertext. The first block of ciphertext is used as IV for the second block of plain text. The same procedure will be followed for all blocks of plain text.</li>\r\n<li>At the receiver side, the ciphertext is divided into blocks. The first block ciphertext is decrypted using the same key, which is used for encryption. The decrypted result will be XOR with the IV and form the first block of plain text. The second block of ciphertext is also decrypted using the same key, and the result of the decryption will be XOR with the first block of ciphertext and form the second block of plain text. The same procedure is used for all the blocks.</li>\r\n<li>CBC Mode ensures that if the block of plain text is repeated in the original message, it will produce a different ciphertext for corresponding blocks.<br>\r\nNote that the key which is used in CBC mode is the same; only the IV is different, which is initialized at a starting point.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/d2a42bc7495942afa81b2a6ca78d27ac.webp\" alt=\"cbc\"><figcaption aria-hidden=\"true\">cbc</figcaption>\r\n</figure>\r\n<h3 id=\"cfb-mode\">3. CFB Mode</h3>\r\n<ul>\r\n<li>CFB mode stands for Cipher Feedback Mode. In this mode, the data is encrypted in the form of units where each unit is of 8 bits.</li>\r\n<li>Like cipher block chaining mode, IV is initialized. The IV is kept in the shift register. It is encrypted using the key and form the ciphertext.</li>\r\n<li>Now the leftmost j bits of the encrypted IV is XOR with the plain text’s first j bits. This process will form the first part of the ciphertext, and this ciphertext will be transmitted to the receiver.</li>\r\n<li>Now the bits of IV is shifted left by j bit. Therefore the rightmost j position of the shift register now has unpredictable data. These rightmost j positions are now filed with the ciphertext. The process will be repeated for all plain text units.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/9561710becb4435c98e0b8ada546747d.webp\" alt=\"9561710becb4435c98e0b8ada546747d\"><figcaption aria-hidden=\"true\">9561710becb4435c98e0b8ada546747d</figcaption>\r\n</figure>\r\n<h3 id=\"ofb-mode\">4. OFB mode</h3>\r\n<ul>\r\n<li>OFB Mode stands for output feedback Mode. OFB mode is similar to CDB mode; the only difference is in CFB, the ciphertext is used for the <a href=\"https://www.educba.com/encryption-process/\">next stage of the encryption process</a>, whereas in OFB, the output of the IV encryption is used for the next stage of the encryption process.</li>\r\n<li>The IV is encrypted using the key and form encrypted IV. Plain text and leftmost 8 bits of encrypted IV are combined using XOR and produce the ciphertext.</li>\r\n<li>For the next stage, the ciphertext, which is the form in the previous stage, is used as an IV for the next iteration. The same procedure is followed for all blocks.</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/814105d6cfdb43f69677bd741eae0130.webp\" alt=\"814105d6cfdb43f69677bd741eae0130\"><figcaption aria-hidden=\"true\">814105d6cfdb43f69677bd741eae0130</figcaption>\r\n</figure>\r\n<h3 id=\"ctr-mode\">5. CTR Mode</h3>\r\n<ul>\r\n<li><p>CTR Mode stands for counter mode. As the name is counter, it uses the sequence of numbers as an input for the algorithm. When the block is encrypted, to fill the next register next counter value is used.<br>\r\nNote: the counter value will be incremented by 1.</p></li>\r\n<li><p>For encryption, the first counter is encrypted using a key, and then the plain text is XOR with the encrypted result to form the ciphertext.</p></li>\r\n<li><p>The counter will be incremented by 1 for the next stage, and the same procedure will be followed for all blocks. For decryption, the same sequence will be used. Here to convert ciphertext into plain text, each ciphertext is XOR with the encrypted counter. For the next stage, the counter will be incremented by the same will be repeated for all Ciphertext blocks.</p>\r\n<p><img src=\"/2022/09/12/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/35da82f1f0ca4102ae145acd4994be87.webp\" alt=\"35da82f1f0ca4102ae145acd4994be87\"> 原文来源于：<a href=\"https://www.educba.com/block-cipher-modes-of-operation/\">https://www.educba.com/block-cipher-modes-of-operation/</a></p></li>\r\n</ul>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"刮开有奖","url":"/2022/09/12/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/","content":"<h2 id=\"题目地址\"><a href=\"https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96\">题目地址</a></h2>\r\n<h2 id=\"解题过程\">解题过程</h2>\r\n<h3 id=\"peid查看无壳拖入ida反编译结果如下\">PEID查看无壳，拖入IDA反编译，结果如下：</h3>\r\n<span id=\"more\"></span>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL __stdcall <span class=\"title\">DialogFunc</span><span class=\"params\">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *v4; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *v5; <span class=\"comment\">// edi</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v7; <span class=\"comment\">// [esp+8h] [ebp-20030h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+Ch] [ebp-2002Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v9; <span class=\"comment\">// [esp+10h] [ebp-20028h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v10; <span class=\"comment\">// [esp+14h] [ebp-20024h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v11; <span class=\"comment\">// [esp+18h] [ebp-20020h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v12; <span class=\"comment\">// [esp+1Ch] [ebp-2001Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v13; <span class=\"comment\">// [esp+20h] [ebp-20018h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v14; <span class=\"comment\">// [esp+24h] [ebp-20014h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v15; <span class=\"comment\">// [esp+28h] [ebp-20010h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v16; <span class=\"comment\">// [esp+2Ch] [ebp-2000Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v17; <span class=\"comment\">// [esp+30h] [ebp-20008h]</span></span><br><span class=\"line\">  CHAR String; <span class=\"comment\">// [esp+34h] [ebp-20004h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v19; <span class=\"comment\">// [esp+35h] [ebp-20003h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v20; <span class=\"comment\">// [esp+36h] [ebp-20002h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v21; <span class=\"comment\">// [esp+37h] [ebp-20001h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v22; <span class=\"comment\">// [esp+38h] [ebp-20000h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v23; <span class=\"comment\">// [esp+39h] [ebp-1FFFFh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v24; <span class=\"comment\">// [esp+3Ah] [ebp-1FFFEh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v25; <span class=\"comment\">// [esp+3Bh] [ebp-1FFFDh]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v26; <span class=\"comment\">// [esp+10034h] [ebp-10004h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v27; <span class=\"comment\">// [esp+10035h] [ebp-10003h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v28; <span class=\"comment\">// [esp+10036h] [ebp-10002h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a2 == <span class=\"number\">272</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a2 != <span class=\"number\">273</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (_WORD)a3 == <span class=\"number\">1001</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;String, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">    <span class=\"built_in\">GetDlgItemTextA</span>(hDlg, <span class=\"number\">1000</span>, &amp;String, <span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"built_in\">strlen</span>(&amp;String) == <span class=\"number\">8</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v7 = <span class=\"number\">90</span>;</span><br><span class=\"line\">      v8 = <span class=\"number\">74</span>;</span><br><span class=\"line\">      v9 = <span class=\"number\">83</span>;</span><br><span class=\"line\">      v10 = <span class=\"number\">69</span>;</span><br><span class=\"line\">      v11 = <span class=\"number\">67</span>;</span><br><span class=\"line\">      v12 = <span class=\"number\">97</span>;</span><br><span class=\"line\">      v13 = <span class=\"number\">78</span>;</span><br><span class=\"line\">      v14 = <span class=\"number\">72</span>;</span><br><span class=\"line\">      v15 = <span class=\"number\">51</span>;</span><br><span class=\"line\">      v16 = <span class=\"number\">110</span>;</span><br><span class=\"line\">      v17 = <span class=\"number\">103</span>;</span><br><span class=\"line\">      <span class=\"built_in\">sub_4010F0</span>(&amp;v7, <span class=\"number\">0</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>(&amp;v26, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">      v26 = v23;</span><br><span class=\"line\">      v28 = v25;</span><br><span class=\"line\">      v27 = v24;</span><br><span class=\"line\">      v4 = (<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"built_in\">sub_401000</span>(&amp;v26, <span class=\"built_in\">strlen</span>(&amp;v26));</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>(&amp;v26, <span class=\"number\">0</span>, <span class=\"number\">0xFFFF</span>u);</span><br><span class=\"line\">      v27 = v21;</span><br><span class=\"line\">      v26 = v20;</span><br><span class=\"line\">      v28 = v22;</span><br><span class=\"line\">      v5 = (<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"built_in\">sub_401000</span>(&amp;v26, <span class=\"built_in\">strlen</span>(&amp;v26));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( String == v7 + <span class=\"number\">34</span></span><br><span class=\"line\">        &amp;&amp; v19 == v11</span><br><span class=\"line\">        &amp;&amp; <span class=\"number\">4</span> * v20 - <span class=\"number\">141</span> == <span class=\"number\">3</span> * v9</span><br><span class=\"line\">        &amp;&amp; v21 / <span class=\"number\">4</span> == <span class=\"number\">2</span> * (v14 / <span class=\"number\">9</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v4, <span class=\"string\">&quot;ak1w&quot;</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v5, <span class=\"string\">&quot;V1Ax&quot;</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MessageBoxA</span>(hDlg, <span class=\"string\">&quot;U g3t 1T!&quot;</span>, <span class=\"string\">&quot;@_@&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (_WORD)a3 != <span class=\"number\">1</span> &amp;&amp; (_WORD)a3 != <span class=\"number\">2</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">EndDialog</span>(hDlg, (<span class=\"type\">unsigned</span> __int16)a3);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>发现关键代码如下： <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( String == v7 + <span class=\"number\">34</span></span><br><span class=\"line\">        &amp;&amp; v19 == v11</span><br><span class=\"line\">        &amp;&amp; <span class=\"number\">4</span> * v20 - <span class=\"number\">141</span> == <span class=\"number\">3</span> * v9</span><br><span class=\"line\">        &amp;&amp; v21 / <span class=\"number\">4</span> == <span class=\"number\">2</span> * (v14 / <span class=\"number\">9</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v4, <span class=\"string\">&quot;ak1w&quot;</span>)</span><br><span class=\"line\">        &amp;&amp; !<span class=\"built_in\">strcmp</span>(v5, <span class=\"string\">&quot;V1Ax&quot;</span>) )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">MessageBoxA</span>(hDlg, <span class=\"string\">&quot;U g3t 1T!&quot;</span>, <span class=\"string\">&quot;@_@&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure> 将v4、v5分别与<code>\"ak1w\"</code>、<code>\"V1Ax\"</code>对比，String与v7+34对比，其他类似，从String开始到v25为我方输入，后续对String部分进行变换。 1. sub_4010F0(&amp;v7, 0, 10)函数对v7开始的数组进行排序（升序）， 2. sub_401000函数为base64编码。</p>\r\n<h3 id=\"编写py对其还原\">编写py对其还原：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\">a = [<span class=\"string\">&#x27;Z&#x27;</span>,<span class=\"string\">&#x27;J&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;N&#x27;</span>,<span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;n&#x27;</span>,<span class=\"string\">&#x27;g&#x27;</span>]</span><br><span class=\"line\">a = [<span class=\"built_in\">ord</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> a]</span><br><span class=\"line\">a.sort()</span><br><span class=\"line\">res = []</span><br><span class=\"line\">res.append(<span class=\"built_in\">chr</span>(a[<span class=\"number\">0</span>]+<span class=\"number\">34</span>))                        <span class=\"comment\"># str[0]</span></span><br><span class=\"line\">res.append(<span class=\"built_in\">chr</span>(a[<span class=\"number\">4</span>]))                           <span class=\"comment\"># str[1] = v19</span></span><br><span class=\"line\">res.append( <span class=\"built_in\">chr</span>((a[<span class=\"number\">2</span>] * <span class=\"number\">3</span> + <span class=\"number\">141</span>) // <span class=\"number\">4</span>) )        <span class=\"comment\"># v20</span></span><br><span class=\"line\">res.append(base64.b64decode(<span class=\"string\">&quot;ak1w&quot;</span>).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)[<span class=\"number\">1</span>:])        <span class=\"comment\"># v21-v22</span></span><br><span class=\"line\">res.append(base64.b64decode(<span class=\"string\">&quot;V1Ax&quot;</span>).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>))            <span class=\"comment\"># v23-v25</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"得到flagujwmpwp1\">得到flag：UJWMpWP1</h3>\r\n","categories":["CTF"],"tags":["reverse","c/c++"]},{"title":"古典密码题解 1","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-1/","content":"<h2 id=\"斐波那契\">斐波那契</h2>\r\n<h3 id=\"打开文件发现内容如下\">打开文件发现内容如下</h3>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>encryption:1,1346269,2,5,8,13,3,21,34,55,89,144,233,377,610,987,2584,4181,6765,1597,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,2178309,1</p>\r\n<p>cipher:flag{0efa24ed49aa78d97bc2657c4aeaf4ad}</p>\r\n</blockquote>\r\n<h3 id=\"解题\">解题</h3>\r\n<p>发现encrytion后内容为乱序斐波那契数列，长度为32，和flag中内容长度一致，推测需找出encryption对应的编号，然后再对应到flag内容上，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = [<span class=\"number\">1</span>,<span class=\"number\">1346269</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">3</span>,<span class=\"number\">21</span>,<span class=\"number\">34</span>,<span class=\"number\">55</span>,<span class=\"number\">89</span>,<span class=\"number\">144</span>,<span class=\"number\">233</span>,<span class=\"number\">377</span>,<span class=\"number\">610</span>,<span class=\"number\">987</span>,<span class=\"number\">2584</span>,<span class=\"number\">4181</span>,<span class=\"number\">6765</span>,<span class=\"number\">1597</span>,<span class=\"number\">10946</span>,<span class=\"number\">17711</span>,<span class=\"number\">28657</span>,<span class=\"number\">46368</span>,<span class=\"number\">75025</span>,<span class=\"number\">121393</span>,<span class=\"number\">196418</span>,<span class=\"number\">317811</span>,<span class=\"number\">514229</span>,<span class=\"number\">832040</span>,<span class=\"number\">2178309</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">flag = <span class=\"string\">&#x27;0efa24ed49aa78d97bc2657c4aeaf4ad&#x27;</span></span><br><span class=\"line\">b = s.copy()</span><br><span class=\"line\">b.sort()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">res = [<span class=\"literal\">None</span>] * <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(flag)):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> res[b.index(s[i])]:</span><br><span class=\"line\">        res[b.index(s[i])] = flag[i]</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        c = (flag[i])</span><br><span class=\"line\">res[res.index(<span class=\"literal\">None</span>)] = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>\r\n<p>解得flag如下：<code>0dfea24d49aa78d927bc657c4aeaf4ea</code></p>\r\n<h2 id=\"仿射\">仿射</h2>\r\n<ol type=\"1\">\r\n<li>查看目录，存在两个文件：<code>hint.txt</code>和<code>cipher.txt</code>，内容分别为<code>achjbnpdfherebjsw</code>、<code>b=7</code></li>\r\n<li>解题 根据仿射变换性质：<span class=\"math inline\">\\(C = (a*M+b)\\mod 26\\)</span>，且a与26互素，因此穷举a，便历所有字符，当输出字符为可读单词时，便求得解。编写脚本如下：</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 仿射</span></span><br><span class=\"line\">cipher = <span class=\"string\">&#x27;achjbnpdfherebjsw&#x27;</span></span><br><span class=\"line\">b = <span class=\"number\">7</span></span><br><span class=\"line\">a_ = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">17</span>,<span class=\"number\">19</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">25</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> a_: <span class=\"comment\"># 便历所有a</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> cipher:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>),<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>): <span class=\"comment\"># 便历所有小写字母，判断进行加密后是否与cipher一致</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((d - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)) * a + b) % <span class=\"number\">26</span> == <span class=\"built_in\">ord</span>(c) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>):</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>(d)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(res) == <span class=\"built_in\">len</span>(cipher):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a, res)</span><br></pre></td></tr></table></figure>\r\n<p>输出结果为 &gt; 1 tvacugiwyaxkxuclp &gt; &gt; 3 phasycuqiazmzysvf &gt; &gt; 5 jzaqewmukapcpeqxd &gt; &gt; 7 zdaeomqswahuhoejr &gt; &gt; 9 flagisyouareright &gt; &gt; 11 xjamqkwcoavivqmbz &gt; &gt; 15 draokqeymafsfkozb &gt; &gt; 17 vpausicmgajwjsuth &gt; &gt; 19 bxawmokieatgtmwrj &gt; &gt; 21 rbakweogqalylwkdx &gt; &gt; 23 ltaicygksabobcifv &gt; &gt; 25 hfaygusecadqdgypl</p>\r\n<p>因此结果为：<code>flagisyouareright</code>，转换为32位md5后为<code>e8cb7b46bcf72d62e74100dd19bc63c6</code></p>\r\n<h2 id=\"大帝的秘密武器\">大帝的秘密武器</h2>\r\n<h3 id=\"题目\">题目</h3>\r\n<p>请解开以下密文获得合理单词，并使用同样加密方法和加密向量加密以下明文，作为答案提交</p>\r\n<blockquote>\r\n<p>FRPHEVGL</p>\r\n<p>ComeChina</p>\r\n</blockquote>\r\n<h3 id=\"解题-1\">解题</h3>\r\n<p>使用脚本，求得偏移量，然后再进行加密</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 大帝的秘密武器</span></span><br><span class=\"line\">s1 = <span class=\"string\">&#x27;FRPHEVGL&#x27;</span></span><br><span class=\"line\">s2 = <span class=\"string\">&#x27;ComeChina&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">encrypt_ks</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, w: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span> :</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.islower():</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) + w) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) + w) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">decrypt_ks(s1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(encrypt_ks(s2, <span class=\"number\">13</span>))</span><br></pre></td></tr></table></figure>\r\n<p>从<code>decrypt_ks</code>可以看出结果为<code>13 security</code>，因此偏移为<code>13</code>，使用encrypt_ks函数，偏移参数为13，加密结果为<code>PbzrPuvan</code></p>\r\n<h2 id=\"残缺的哈希值\">残缺的哈希值</h2>\r\n<h3 id=\"题目-1\">题目</h3>\r\n<p>小明一直将电脑密码的哈希值写在纸上，结果一不小心将墨水撒在了上面，只看得到前10位是c2979c7124，小明只记得密码是4位的数字加字母，你能帮小明恢复密码的哈希值吗？（提示：flag为密码的哈希值）</p>\r\n<h3 id=\"解题-2\">解题</h3>\r\n<p>编写脚本，暴力破解</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">md5 = <span class=\"string\">&#x27;c2979c7124&#x27;</span></span><br><span class=\"line\">ss = <span class=\"string\">&#x27;0123456789abcdefghjklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> itertools.product(ss, repeat=<span class=\"number\">4</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hashlib.md5(<span class=\"string\">&#x27;&#x27;</span>.join(s).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest()[:<span class=\"number\">10</span>] == md5:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(hashlib.md5(<span class=\"string\">&#x27;&#x27;</span>.join(s).encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest())</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>得到flag为：<code>c2979c71244dec2befc6e369941c6546</code></p>\r\n<h2 id=\"浪里淘沙\">浪里淘沙</h2>\r\n<h3 id=\"题目-2\">题目</h3>\r\n<blockquote>\r\n<p>我有密集恐惧症，所以大家自求多福吧，把获得的单词连在一起提交即可。（我这里有一串数字：4，8，11，15，16）</p>\r\n</blockquote>\r\n<p>打开<code>浪里淘沙.txt</code>，发现存在大量英文单词文本，且无空格区分。</p>\r\n<h3 id=\"解题-3\">解题</h3>\r\n<p>使用编辑器手动对单词进行切分（添加空格），然后使用脚本进行统计词频，并按次数从小到大排序，最后将数字作为索引输出单词</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">b = [<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>]</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\浪里淘沙\\浪里淘沙.txt&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    text : <span class=\"built_in\">str</span> = f.read()</span><br><span class=\"line\">    l = text.split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(l))</span><br><span class=\"line\">    s = <span class=\"built_in\">dict</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"string\">&#x27;&#x27;</span> <span class=\"keyword\">and</span> i != <span class=\"string\">&#x27; &#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s.get(i):</span><br><span class=\"line\">                s[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            s[i] += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(s), s)</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> s.items():</span><br><span class=\"line\">        res.append(item)</span><br><span class=\"line\">    res.sort(key = <span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> b:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(res[j][<span class=\"number\">0</span>],end=<span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>得到flag为：<code>weshouldlearnthecrypto</code></p>\r\n<h2 id=\"easy-crypto\">Easy Crypto</h2>\r\n<h3 id=\"打开文件发现内容如下-1\">打开文件，发现内容如下</h3>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">Jxyi yi oekh tqo.Jxyi yi oekh suburhqjyed., qdt jxu vbqw yi vv97v97t5t1ss32t9q5u62s2uu1t2v2s, ikrcyj myjx vbqw qdt &#123;&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"使用凯撒密码暴力破解\">使用凯撒密码暴力破解</h3>\r\n<p>得到结果为：<code>flag&#123;ff97f97d5d1cc32d9a5e62c2ee1d2f2c&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 2","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-2/","content":"<h2 id=\"凯撒替换\">凯撒？替换？</h2>\r\n<h3 id=\"打开文件\">打开文件</h3>\r\n<span id=\"more\"></span>\r\n<p>发现内容为：<code>MTHJ&#123;CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZO HIXOEOWMEHZO&#125;</code></p>\r\n<p>采用词频分析网站，进行解密，得到结果为<code>flag substitution cipher decryption is always easy just like a piece of cake</code></p>\r\n<p>因此flag为<code>flag&#123;substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake&#125;</code></p>\r\n<h2 id=\"简单刺激小游戏\">简单刺激小游戏</h2>\r\n<ol type=\"1\">\r\n<li>文件内容为<code>f&#123;1calrfesaaE_ygInE&#125;</code>，应该为栅栏密码</li>\r\n<li>使用脚本，得到结果为：<code>flag&#123;raI1fEnce_Easy&#125;</code></li>\r\n</ol>\r\n<h2 id=\"还原大师\">还原大师</h2>\r\n<p>我们得到了一串神秘字符串：<code>TASC?O3RJMV?WDJKX?ZM</code>，中间的问号为未知大写字母，并得到了该字符串的部分MD5为<code>E903???4DAB</code>，请猜出该字符串，并提交MD5作为答案</p>\r\n<p>编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">s = <span class=\"string\">&#x27;TASC?O3RJMV?WDJKX?ZM&#x27;</span></span><br><span class=\"line\">md5 = <span class=\"string\">&#x27;E903???4DAB&#x27;</span>.lower()</span><br><span class=\"line\"><span class=\"keyword\">for</span> j1 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j2 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j3 <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            ss = s[:<span class=\"number\">4</span>]+<span class=\"built_in\">chr</span>(j1)+ s[<span class=\"number\">5</span>:<span class=\"number\">11</span>] + <span class=\"built_in\">chr</span>(j2)+ s[<span class=\"number\">12</span>:<span class=\"number\">17</span>] + <span class=\"built_in\">chr</span>(j3) + s[-<span class=\"number\">2</span>:]</span><br><span class=\"line\">            <span class=\"keyword\">assert</span>(<span class=\"built_in\">len</span>(ss) == <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">            mds = hashlib.md5(ss.encode(<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest().lower()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mds[:<span class=\"number\">4</span>] == md5[:<span class=\"number\">4</span>] <span class=\"keyword\">and</span> mds[<span class=\"number\">7</span>:<span class=\"number\">11</span>] == md5[<span class=\"number\">7</span>:]:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(mds)</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<p>得到结果为<code>E9032994DABAC08080091151380478A2</code></p>\r\n<h2 id=\"古典密码1\">古典密码1</h2>\r\n<p>打开文件，发现内容如下： &gt; iodj{36g9i2777 &gt; &gt; -... ----. ..--- -... .- -.-. ...-- ----. .- .- ..--- &gt; &gt; a0dd}b6942c07</p>\r\n<p>第1为凯撒加密，第2为摩尔斯密码，第3为栅栏密码</p>\r\n<p>凯撒和摩尔斯密码解密脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 凯撒密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ks</span>(<span class=\"params\">s : <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    s = s.lower()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">27</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i.isalpha():</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) + j - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)) % <span class=\"number\">26</span> + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)), end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(i,end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">decrypt_ks(<span class=\"string\">&#x27;iodj&#123;36g9i2777&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 摩尔斯密码</span></span><br><span class=\"line\">a2mo_dict = &#123;<span class=\"string\">&#x27;a&#x27;</span>: <span class=\"string\">&#x27;.-&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"string\">&#x27;-...&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>: <span class=\"string\">&#x27;-.-.&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>: <span class=\"string\">&#x27;-..&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>: <span class=\"string\">&#x27;.&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;f&#x27;</span>: <span class=\"string\">&#x27;..-.&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>: <span class=\"string\">&#x27;--.&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>: <span class=\"string\">&#x27;....&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>: <span class=\"string\">&#x27;..&#x27;</span>, <span class=\"string\">&#x27;j&#x27;</span>: <span class=\"string\">&#x27;.---&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;k&#x27;</span>: <span class=\"string\">&#x27;-.-&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>: <span class=\"string\">&#x27;.-..&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>: <span class=\"string\">&#x27;--&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>: <span class=\"string\">&#x27;-.&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>: <span class=\"string\">&#x27;---&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;p&#x27;</span>: <span class=\"string\">&#x27;.--.&#x27;</span>, <span class=\"string\">&#x27;q&#x27;</span>: <span class=\"string\">&#x27;--.-&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>: <span class=\"string\">&#x27;.-.&#x27;</span>, <span class=\"string\">&#x27;s&#x27;</span>: <span class=\"string\">&#x27;...&#x27;</span>, <span class=\"string\">&#x27;t&#x27;</span>: <span class=\"string\">&#x27;-&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;u&#x27;</span>: <span class=\"string\">&#x27;..-&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>: <span class=\"string\">&#x27;...-&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>: <span class=\"string\">&#x27;.--&#x27;</span>, <span class=\"string\">&#x27;x&#x27;</span>: <span class=\"string\">&#x27;-..-&#x27;</span>, <span class=\"string\">&#x27;y&#x27;</span>: <span class=\"string\">&#x27;-.--&#x27;</span>, <span class=\"string\">&#x27;z&#x27;</span>: <span class=\"string\">&#x27;--..&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;0&#x27;</span>: <span class=\"string\">&#x27;-----&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>: <span class=\"string\">&#x27;.----&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>: <span class=\"string\">&#x27;..---&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>: <span class=\"string\">&#x27;...--&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>: <span class=\"string\">&#x27;....-&#x27;</span>,</span><br><span class=\"line\">             <span class=\"string\">&#x27;5&#x27;</span>: <span class=\"string\">&#x27;.....&#x27;</span>, <span class=\"string\">&#x27;6&#x27;</span>: <span class=\"string\">&#x27;-....&#x27;</span>, <span class=\"string\">&#x27;7&#x27;</span>: <span class=\"string\">&#x27;--...&#x27;</span>, <span class=\"string\">&#x27;8&#x27;</span>: <span class=\"string\">&#x27;---..&#x27;</span>, <span class=\"string\">&#x27;9&#x27;</span>: <span class=\"string\">&#x27;----.&#x27;</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">mo2a_dict = <span class=\"built_in\">dict</span>(<span class=\"built_in\">zip</span>(a2mo_dict.values(), a2mo_dict.keys()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt_ms</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, split: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    l = s.split(split)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mo2a_dict[i],end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">decrypt_ms(<span class=\"string\">&#x27;-... ----. ..--- -... .- -.-. ...-- ----. .- .- ..---&#x27;</span>,<span class=\"string\">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>得到解密内容1、2分别为：<code>flag&#123;36d9f2777</code>、<code>b92bac39aa2</code>，使用之前的栅栏密码解码脚本解密内容3，得到<code>ab206cd90d47&#125;</code>，因此flag为<code>flag&#123;36d9f2777b92bac39aa2ab206cd90d47&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 4","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-4/","content":"<h2 id=\"异性相吸\">异性相吸</h2>\r\n<ol type=\"1\">\r\n<li><p>打开压缩文件</p>\r\n<p><span id=\"more\"></span></p>\r\n<p>发现存在<code>密文.txt</code>和<code>key.txt</code>，根据题目，猜测使用异或进行解密</p></li>\r\n<li><p>编写py脚本如下</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\异性相吸\\key.txt&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f1:</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\异性相吸\\密文.txt&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f2:</span><br><span class=\"line\">key = f1.read()</span><br><span class=\"line\">enc = f2.read()</span><br><span class=\"line\">res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(key)):</span><br><span class=\"line\">    res += <span class=\"built_in\">chr</span>(key[i] ^ enc[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(res)</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>得到flag：flag{ea1bc0988992276b7f95b54a7435e89e}</p></li>\r\n</ol>\r\n<h2 id=\"一眼就解密\">一眼就解密</h2>\r\n<ol type=\"1\">\r\n<li><p>查看字符串，为<code>ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=</code></p></li>\r\n<li><p>根据尾部<code>=</code>号判断为base64编码</p></li>\r\n<li><p>编写py脚本如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> base64; <span class=\"built_in\">print</span>(base64.b64decode(<span class=\"string\">&#x27;ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>得到flag：flag{THE_FLAG_OF_THIS_STRING}</p></li>\r\n</ol>\r\n<h2 id=\"四四方方一座城\">四四方方一座城</h2>\r\n<ol type=\"1\">\r\n<li><p>打开压缩包，发现hint.py，打开文件，内容如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flag <span class=\"keyword\">import</span> FLAG,key1,key2,Offset</span><br><span class=\"line\"><span class=\"keyword\">from</span> enc <span class=\"keyword\">import</span> encrypt</span><br><span class=\"line\"></span><br><span class=\"line\">ciphertext = encrypt(FLAG)</span><br><span class=\"line\">enc_key1 = enc_key2 = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key1:</span><br><span class=\"line\">enc_key1 += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span>) + Offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key2:</span><br><span class=\"line\">enc_key2 += <span class=\"built_in\">chr</span>((<span class=\"built_in\">ord</span>(i) ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span>) + Offset)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> enc_key1</span><br><span class=\"line\"><span class=\"built_in\">print</span> enc_key2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#ciphertext:XBBSPASGXRAEUIOHPZ</span></span><br><span class=\"line\"><span class=\"comment\">#enc_key1:VXYjj</span></span><br><span class=\"line\"><span class=\"comment\">#enc_key2:NQLOUVXab</span></span><br></pre></td></tr></table></figure></p>\r\n<p>可以看出flag被加密，推测使用<code>key1</code>和<code>key2</code>加密，其中key1和key2经过编码，得到<code>enc_key1</code>和<code>enc_key2</code>，且Offset偏移未知。</p></li>\r\n<li><p>使用脚本如下，推测Offset值：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">min_num, max_num = <span class=\"number\">255</span>, <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    c = i ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &lt; min_num:</span><br><span class=\"line\">        min_num = c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &gt; max_num:</span><br><span class=\"line\">        max_num = c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">    c = i ^ <span class=\"number\">0xff</span> &amp; <span class=\"number\">0xaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &lt; min_num:</span><br><span class=\"line\">        min_num = c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c &gt; max_num:</span><br><span class=\"line\">        max_num = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(min_num, max_num)</span><br><span class=\"line\">range1 = (<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>) - max_num, <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) - min_num)  <span class=\"comment\"># 初步推测Offset范围</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(range1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">i, key</span>):  <span class=\"comment\"># 检查offset i还原key是否正常</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> key:</span><br><span class=\"line\">        c = (<span class=\"built_in\">ord</span>(s) - i) ^ <span class=\"number\">0xaf</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>)+<span class=\"number\">1</span>)):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, res</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res += <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"literal\">True</span>, res)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">enc_key1 = <span class=\"string\">&#x27;VXYjj&#x27;</span></span><br><span class=\"line\">enc_key2 = <span class=\"string\">&#x27;NQLOUVXab&#x27;</span></span><br><span class=\"line\">enc_txt = <span class=\"string\">&#x27;XBBSPASGXRAEUIOHPZ&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(range1[<span class=\"number\">0</span>], range1[<span class=\"number\">1</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">    flag1, res1 = check(i, enc_key1)</span><br><span class=\"line\">    flag2, res2 = check(i, enc_key2)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag1 <span class=\"keyword\">and</span> flag2:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i, res1, res2)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果如下：</p>\r\n<blockquote>\r\n<p>192 255</p>\r\n<p>(-190, -70)</p>\r\n<p>-149 DBAPP LINKEDBYX</p>\r\n</blockquote>\r\n<p>因此offset偏移为<code>-149</code>，且key1和key2分别为：<code>DBAPP</code>，<code>LINKEDBYX</code></p></li>\r\n<li><p>编写解密脚本，求取flag</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cons_martix</span>(<span class=\"params\">key: <span class=\"built_in\">str</span></span>):  <span class=\"comment\"># 构造矩阵</span></span><br><span class=\"line\">    key_set = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    s = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> key:  <span class=\"comment\"># 移除重复字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> i <span class=\"keyword\">in</span> key_set:</span><br><span class=\"line\">            s += i</span><br><span class=\"line\">            key_set.add(i)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(key_set)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;A&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Z&#x27;</span>)+<span class=\"number\">1</span>):  <span class=\"comment\"># 添加除key中出现过的26个英文字母(除掉Q)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;Q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(i) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> key_set:</span><br><span class=\"line\">                s += <span class=\"built_in\">chr</span>(i)</span><br><span class=\"line\">                key_set.add(i)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (<span class=\"built_in\">len</span>(s) == <span class=\"number\">25</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">key1, key2, enc_txt</span>):</span><br><span class=\"line\">    m1, m2 = cons_martix(key1), cons_martix(key2)</span><br><span class=\"line\">    cm = [<span class=\"built_in\">chr</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>), <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;z&#x27;</span>) + <span class=\"number\">1</span>)]</span><br><span class=\"line\">    cm.remove(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(cm)</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(enc_txt):</span><br><span class=\"line\">        t1 = m1.find(enc_txt[i])</span><br><span class=\"line\">        t2 = m2.find(enc_txt[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">        x1, y1 = t1 // <span class=\"number\">5</span>, t1 % <span class=\"number\">5</span></span><br><span class=\"line\">        x2, y2 = t2 // <span class=\"number\">5</span>, t2 % <span class=\"number\">5</span></span><br><span class=\"line\">        res = res + cm[x1 * <span class=\"number\">5</span> + y2] + cm[x2*<span class=\"number\">5</span>+y1]</span><br><span class=\"line\">        i += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">res = decrypt(res1, res2, enc_txt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(res, hashlib.md5(<span class=\"built_in\">bytes</span>(res, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)).hexdigest())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<p>运行结果如下：</p>\r\n<blockquote>\r\n<p>{'P', 'B', 'D', 'A'}</p>\r\n<p>{'B', 'I', 'N', 'X', 'Y', 'K', 'L', 'E', 'D'}</p>\r\n<p>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']</p>\r\n<p>whereismysecretkey</p>\r\n</blockquote>\r\n<p>得到flag：<code>whereismysecretkey</code></p></li>\r\n</ol>\r\n<h2 id=\"篱笆墙的影子\">篱笆墙的影子</h2>\r\n<ol type=\"1\">\r\n<li><p>打开文件发现内容为，推测为栅栏密码：<code>felhaagv&#123;ewtehtehfilnakgw&#125;</code></p></li>\r\n<li><p>编写脚本:</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 栅栏密码</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pad</span>(<span class=\"params\">s: <span class=\"built_in\">str</span>, n: <span class=\"built_in\">int</span>, pad_char: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    m = <span class=\"built_in\">len</span>(s) // n  <span class=\"comment\"># 共多少组</span></span><br><span class=\"line\">    l = <span class=\"built_in\">len</span>(s) % n  <span class=\"comment\"># 补余数</span></span><br><span class=\"line\">    res = <span class=\"built_in\">list</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l:</span><br><span class=\"line\">        pad_num = n - l</span><br><span class=\"line\">        <span class=\"keyword\">while</span> pad_num &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">            res.insert(-(pad_num-<span class=\"number\">1</span>)*m, <span class=\"built_in\">chr</span>(pad_char))</span><br><span class=\"line\">            pad_num -= <span class=\"number\">1</span></span><br><span class=\"line\">        res.append(<span class=\"built_in\">chr</span>(pad_char))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span>.join(res)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">s, n</span>):</span><br><span class=\"line\">    pad_s = pad(s, n, <span class=\"number\">1</span>)</span><br><span class=\"line\">    cates = <span class=\"built_in\">len</span>(pad_s) // n  <span class=\"comment\"># 组数</span></span><br><span class=\"line\">    res = [<span class=\"string\">&#x27;&#x27;</span>] * cates</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(pad_s):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cates):</span><br><span class=\"line\">            res[j] += pad_s[i+j]</span><br><span class=\"line\">        i += cates</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span>.join(res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res.strip(<span class=\"built_in\">chr</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">loop</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, <span class=\"built_in\">len</span>(s)):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(decrypt(s, i))</span><br></pre></td></tr></table></figure></p>\r\n<p>得到flag为：<code>flag&#123;wethinkwehavetheflag&#125;</code></p></li>\r\n</ol>\r\n<h2 id=\"真的是键盘吗\">真的是键盘吗？</h2>\r\n<ol type=\"1\">\r\n<li>密文ypau_kjg;“g;”ypau+</li>\r\n<li>使用<a href=\"http://wbic16.xedoloh.com/dvorak.html\">解密网址</a>解密</li>\r\n<li>得到<code>flag&#123;this“is”flag&#125;</code></li>\r\n<li>对<code>this_is_flag</code>进行md5处理</li>\r\n<li>得到<code>951c712ac2c3e57053c43d80c0a9e543</code></li>\r\n</ol>\r\n<h2 id=\"vvvv\">VVVV</h2>\r\n<ol type=\"1\">\r\n<li>题目 查看压缩包，给出两个文件，分别为<code>encrypt.py</code>和<code>cipher</code>，查看encrypt.py，给出加密方式为维吉尼亚密码，查看cipher，发现内容为加密后的字符串。</li>\r\n<li>解题 使用脚本暴力破解或使用<a href=\"https://www.guballa.de/vigenere-solver\">在线网址</a>解密，得到flag为：<code>flag&#123;dvsksivtmjlochssoel&#125;</code></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"古典密码题解 3","url":"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/","content":"<h2 id=\"世上无难事\">世上无难事</h2>\r\n<h3 id=\"题目\">题目</h3>\r\n<p>以下为某国总统外发的一段指令，经过一种奇怪的加密方式，看来只能用分析方法了，请将这段语句还原成通顺语句，并从其中找到KEY作为答案提交：</p>\r\n<span id=\"more\"></span>\r\n<blockquote>\r\n<p>VIZZB IFIUOJBWO NVXAP OBC XZZ UKHVN IFIUOJBWO HB XVIXW XAW VXFI X QIXN VBD KQ IFIUOJBWO WBKAH NBWXO VBD XJBCN NKG QLKEIU DI XUI VIUI DKNV QNCWIANQ XN DXPIMKIZW VKHV QEVBBZ KA XUZKAHNBA FKUHKAKX XAW DI VXFI HBN QNCWIANQ NCAKAH KA MUBG XZZ XEUBQQ XGIUKEX MUBG PKAWIUHXUNIA NVUBCHV 12NV HUXWI XAW DI XUI SCQN QB HZXW NVXN XZZ EBCZW SBKA CQ NBWXO XAW DI DXAN NB NVXAP DXPIMKIZW MBU JIKAH QCEV XA BCNQNXAWKAH VBQN HKFI OBCUQIZFIQ X JKH UBCAW BM XLLZXCQI XAW NVI PIO KQ 640I11012805M211J0XJ24MM02X1IW09</p>\r\n</blockquote>\r\n<h3 id=\"解题\">解题</h3>\r\n<p>应当采用词频分析，可以看出 VIZZB = HELLO，使用<a href=\"https://quipqiup.com/\">词频分析网站</a>，可得结果为： &gt; HELLO EVERYBODY THANK YOU ALL RIGHT EVERYBODY GO AHEAD AND HAVE A SEAT HOW IS EVERYBODY DOING TODAY HOW ABOUT TIM SPICER WE ARE HERE WITH STUDENTS AT WAKEFIELD HIGH SCHOOL IN ARLINGTON VIRGINIA AND WE HAVE GOT STUDENTS TUNING IN FROM ALL ACROSS AMERICA FROM KINDERGARTEN THROUGH 12TH GRADE AND WE ARE JUST SO GLAD THAT ALL COULD JOIN US TODAY AND WE WANT TO THANK WAKEFIELD FOR BEING SUCH AN OUTSTANDING HOST GIVE YOURSELVES A BIG ROUND OF APPLAUSE AND THE KEY IS 640E11012805F211B0AB24FF02A1ED09</p>\r\n<p>因此flag为<code>640e11012805f211b0ab24ff02a1ed09</code></p>\r\n<h2 id=\"其实很简单\">其实很简单</h2>\r\n<h3 id=\"题目-1\">题目</h3>\r\n<p>学习凯撒密码后，密码前辈又创造出新奇异的加密方法，维吉尼亚是其中一种。出题者是一个程序员，喜欢拿helloworld做秘钥，下面是密文：dlpcsegkshrjj。</p>\r\n<h3 id=\"解题-1\">解题</h3>\r\n<p>编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decrypt</span>(<span class=\"params\">key, enc_txt</span>):</span><br><span class=\"line\">    res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    key_len = <span class=\"built_in\">len</span>(key)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(enc_txt)):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">26</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">ord</span>(key[i % key_len]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) + j)  % <span class=\"number\">26</span>  + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>) == <span class=\"built_in\">ord</span>(enc_txt[i]):</span><br><span class=\"line\">                res += <span class=\"built_in\">chr</span>(j + <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(decrypt(<span class=\"string\">&#x27;helloworld&#x27;</span>, <span class=\"string\">&#x27;dlpcsegkshrjj&#x27;</span>))</span><br></pre></td></tr></table></figure>\r\n<p>运行结果为<code>whereisthekey</code></p>\r\n<h2 id=\"密码学的心声\">密码学的心声</h2>\r\n<h3 id=\"题目-2\">题目</h3>\r\n<p>二战时期，某国军官与一个音乐家情妇相好，然而自从那时起，他屡战屡败，敌人似乎料事如神。他也有怀疑过他的情妇，但是他经过24小时观察他的情妇，发现她每天都只是作曲，然后弹奏给战地电台，为士兵们鼓气，并未有任何逾越。那么，间谍到底是谁？这张曲谱是否有猫腻？</p>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/谱子.png\" alt=\"谱子.png\"><figcaption aria-hidden=\"true\">谱子.png</figcaption>\r\n</figure>\r\n<h3 id=\"解题-2\">解题</h3>\r\n<p>题目提示没有8，因此将八进制转换为Ascii，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&#x27;111114157166145123145143165162151164171126145162171115165143150&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(s):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>(<span class=\"built_in\">int</span>(s[i:i+<span class=\"number\">3</span>], <span class=\"number\">8</span>)), end =<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    i += <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\r\n<p>结果为<code>ILoveSecurityVeryMuch</code></p>\r\n<h2 id=\"萌萌哒的八戒\">萌萌哒的八戒</h2>\r\n<h3 id=\"题目-3\">题目</h3>\r\n<p>萌萌哒的八戒原来曾经是猪村的村长，从远古时期，猪村就有一种神秘的代码。请从附件中找出代码，看看萌萌哒的猪八戒到底想说啥</p>\r\n<h3 id=\"解题-3\">解题</h3>\r\n<p>根据题目信息，提示为猪圈密码，打开图片后如下所示： <img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/猪圈1.png\" alt=\"猪圈1.png\"></p>\r\n<figure>\r\n<img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/猪圈2.png\" alt=\"猪圈2.png\"><figcaption aria-hidden=\"true\">猪圈2.png</figcaption>\r\n</figure>\r\n<p>根据猪圈密码，解得flag为<code>whenthepigwanttoeat</code></p>\r\n<h2 id=\"两种密码\">两种密码</h2>\r\n<h3 id=\"解题-4\">解题</h3>\r\n<p>根据题目信息，发现Bill.txt和Ciphertext.txt，加密方式包含Bill密码，编写脚本如下：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">index = [<span class=\"number\">34</span>, <span class=\"number\">6</span>, <span class=\"number\">13</span>, <span class=\"number\">43</span>, <span class=\"number\">68</span>, <span class=\"number\">21</span>, <span class=\"number\">43</span>, <span class=\"number\">1</span>, <span class=\"number\">77</span>, <span class=\"number\">100</span>, <span class=\"number\">6</span>, <span class=\"number\">41</span>, <span class=\"number\">5</span>, <span class=\"number\">54</span>, <span class=\"number\">68</span>, <span class=\"number\">100</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">13</span>, <span class=\"number\">68</span>, <span class=\"number\">41</span>, <span class=\"number\">2</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">56</span>, <span class=\"number\">94</span>, <span class=\"number\">34</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">56</span>, <span class=\"number\">23</span>, <span class=\"number\">56</span>, <span class=\"number\">34</span>]</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;D:\\CTF\\CRYPTO\\两种密码\\Bill.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    s = f.read().split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> index:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(s[i][<span class=\"number\">0</span>], end = <span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\r\n<p>结果如下：</p>\r\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">the_decrption_path_is</span><br><span class=\"line\">&lt;--------oo&lt;-</span><br><span class=\"line\">-&gt;oo----&gt;oo-&gt;</span><br><span class=\"line\">&lt;-oo&lt;----oo&lt;-</span><br><span class=\"line\">-&gt;oo----&gt;oo-&gt;</span><br><span class=\"line\">&lt;-oo&lt;------&lt;-</span><br></pre></td></tr></table></figure>\r\n<p>根据结果，发现第二种加密方式为曲路密码，对秘文<code>lf1e7f05&#125;ba83909764e2686e&#123;7a7fsi_galfagb8d004</code>进行排列，得到结果为 <img src=\"/2022/09/12/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E9%A2%98%E8%A7%A3-3/曲路.png\" alt=\"曲路.png\"></p>\r\n<p>因此flag为<code>flag_isflag&#123;7a7f1e8be6862f7d09764e05400938ab&#125;</code></p>\r\n","categories":["CTF"],"tags":["crypto","classical cryptography"]},{"title":"威尔逊定理","url":"/2022/09/12/%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/","content":"<h2 id=\"威尔逊定理\">威尔逊定理</h2>\r\n<ol type=\"1\">\r\n<li><p>定义</p>\r\n<blockquote>\r\n<p>当且仅当p为素数时，<span class=\"math inline\">\\((p-1)!\\equiv -1\\mod p\\)</span></p>\r\n</blockquote>\r\n<p><span id=\"more\"></span></p></li>\r\n<li><p>题目</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sympy</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">myGetPrime</span>():</span><br><span class=\"line\">    A = getPrime(<span class=\"number\">513</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(A)</span><br><span class=\"line\">    B = A - random.randint(<span class=\"number\">1e3</span>, <span class=\"number\">1e5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(B)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sympy.nextPrime((B!) % A)</span><br><span class=\"line\"></span><br><span class=\"line\">p = myGetPrime()</span><br><span class=\"line\"><span class=\"comment\"># A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class=\"line\"><span class=\"comment\"># B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class=\"line\"></span><br><span class=\"line\">q = myGetPrime()</span><br><span class=\"line\"><span class=\"comment\"># A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class=\"line\"><span class=\"comment\"># B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class=\"line\"></span><br><span class=\"line\">r = myGetPrime()</span><br><span class=\"line\"></span><br><span class=\"line\">n = p*q*r</span><br><span class=\"line\"><span class=\"comment\"># n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class=\"line\">c = <span class=\"built_in\">pow</span>(flag, e, n)</span><br><span class=\"line\"><span class=\"comment\"># e=0x1001</span></span><br><span class=\"line\"><span class=\"comment\"># c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class=\"line\"><span class=\"comment\"># so,what is the flag?</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>求解过程</p>\r\n<p>此题难点在于<code>(B!)%A</code>，求B的阶乘的模，而B又很大，计算阶乘不大现实，由威尔逊定理可得：</p>\r\n<p><span class=\"math display\">\\[\r\n \\begin{align*}\r\n (A_1-1)! &amp;\\equiv -1\\mod A_1\\\\\r\n \\Rightarrow (B_1)!*k &amp;\\equiv -1\\mod A_1,(k = (A_1-1)!/B_1!)\\\\\r\n \\Rightarrow(B_1)!&amp;\\equiv -k^{-1}\\mod A_1,(k^{-1}为k在A_1下的逆元)\r\n \\end{align*}\r\n \\]</span></p>\r\n<p>代码如下：</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sympy</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes, bytes_to_long</span><br><span class=\"line\"></span><br><span class=\"line\">A1 = <span class=\"number\">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407</span></span><br><span class=\"line\">B1 = <span class=\"number\">21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596</span></span><br><span class=\"line\"></span><br><span class=\"line\">A2 = <span class=\"number\">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927</span></span><br><span class=\"line\">B2 = <span class=\"number\">16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026</span></span><br><span class=\"line\">n = <span class=\"number\">85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733</span></span><br><span class=\"line\">e = <span class=\"number\">0x1001</span></span><br><span class=\"line\">c = <span class=\"number\">75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fact_mod</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    m = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(b+<span class=\"number\">1</span>, a):</span><br><span class=\"line\">        m = m * i % a</span><br><span class=\"line\">    res = (-gmpy2.invert(m, a)) % a</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sympy.nextprime(res)</span><br><span class=\"line\"></span><br><span class=\"line\">p = fact_mod(A1, B1)</span><br><span class=\"line\">q = fact_mod(A2, B2)</span><br><span class=\"line\">r = n // (p*q)</span><br><span class=\"line\">phi_n = (q-<span class=\"number\">1</span>)*(p-<span class=\"number\">1</span>)*(r-<span class=\"number\">1</span>)</span><br><span class=\"line\">d = gmpy2.invert(e, phi_n)</span><br><span class=\"line\">m = gmpy2.powmod(c, d, n)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(long_to_bytes(m))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># b&#x27;RoarCTF&#123;wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A&#125;&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p></li>\r\n</ol>\r\n","categories":["CTF"],"tags":["crypto"]},{"title":"小米6X刷机教程","url":"/2022/09/12/%E5%B0%8F%E7%B1%B36X%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/","content":"<p>最进闲来无事，早就想将手中的<code>小米6X</code>手机刷机了，本以为刷机很简单，却也整整搞了一天才完成，这里记录下刷机的过程。</p>\r\n<h2 id=\"解锁\">解锁</h2>\r\n<p>首先下载<a href=\"https://www.miui.com/unlock/download.html\">官方解锁工具</a>，然后进行以下步骤：</p>\r\n<span id=\"more\"></span>\r\n<ol type=\"1\">\r\n<li>进入“设置 -&gt; 开发者选项 -&gt; 设备解锁状态”中绑定账号和设备；</li>\r\n<li>手动进入Bootloader模式（关机后，同时按住开机键和音量下键）；</li>\r\n<li>通过USB连接手机，点击 “解锁”按钮；</li>\r\n<li>电脑打开解锁工具，使用绑定过手机的账号登录解锁工具，使用USB连接进入了fastboot模式的手机，此时会显示已连接的状态，若未连接，则点击设置，进行驱动检测。</li>\r\n</ol>\r\n<p>连接成功后，点击<strong>解锁</strong>按钮，手机将会进行解锁，但<code>手机内资料将会被清空，记得备份好手机资料</code>。解锁后，手机系统将会恢复出场设置。</p>\r\n<blockquote>\r\n<p>使用USB2.0接口进行连接，否则无法连接到手机</p>\r\n</blockquote>\r\n<h2 id=\"刷入第三方bootloader\">刷入第三方bootloader</h2>\r\n<p>手机重启，同时按电源键和音量下键，进入fastboot模式，打开电脑上的platform-tools文件夹，在该文件夹下进入cmd命令行或者powershell。</p>\r\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; .\\fastboot.exe flash recovery [recovery.img] </span><br></pre></td></tr></table></figure>\r\n<p>将<code>[recovery.img]</code>替换为想刷入的recovery镜像。</p>\r\n<p>Mi6X可以刷入的recovery为<code>lineage-18.1-20220901-recovery-wayne.img</code>。其他的recovery不保证刷入其他系统后还可以使用。</p>\r\n<h2 id=\"刷入系统\">刷入系统</h2>\r\n<p>刷入lineage_recvoery后，按电源键和音量上键进入recovery模式，</p>\r\n<ol type=\"1\">\r\n<li>进入<code>Factory reset</code>，然后点击<code>Format data/factory reset</code>、<code>Format cache partition</code>和<code>Format system partition</code>；</li>\r\n<li>手机清除后，点击<code>Apply Update</code>，再点击<code>Apply from ADB</code>，此时进入ADB模式；</li>\r\n<li>USB连接电脑，使用adb工具运行命令<code>adb sideload 镜像.zip</code>，此时会自动进行刷入，当刷入成功后，会显示<strong>Total xfer: 1.00x,</strong>。此时已经成功刷入系统，点击重启即可。</li>\r\n</ol>\r\n<h2 id=\"刷入magisk\">刷入magisk</h2>\r\n<p>FastBoot刷Magisk的优点<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a></p>\r\n<ol type=\"1\">\r\n<li>无需第三方Recovery</li>\r\n<li>不影响系统升级（完整包升级）</li>\r\n</ol>\r\n<p>方法：</p>\r\n<ol type=\"1\">\r\n<li><p>安装magisk APP</p></li>\r\n<li><p>从镜像.zip中提取boot.img，放到手机中；（如果系统包里面没有boot.img，只有payload.bin，请参考这个<a href=\"magiskcn.com/payload-boot\">教程</a>提取：)</p></li>\r\n<li><p>打开Magisk【安装 – 选择并修补一个文件 – 弹窗文件管理窗口（找到刚刚提取的boot.img）- 开始】</p></li>\r\n<li><p>修补结束，会生成一个名字为（magisk_patched-版本号_随机字符.img）的文件（每次生成的随机字符都不一样，使用的时候请输入生成的名字），将生成的文件复制到电脑中</p></li>\r\n<li><p>手机进入fastboot模式，连接电脑，使用platform-tools运行如下命令 <code>fastboot flash boot 面具文件</code></p></li>\r\n<li><p>出现下面这三行代码，就是成功刷入了。</p>\r\n<blockquote>\r\n<p>Sending 'boot' (131072 KB) OKAY [ 3.049s] Writing 'boot' OKAY [ 0.587s] Finished. Total time: 4.582s</p>\r\n</blockquote></li>\r\n<li><p>重启手机，已经成功刷入面具</p></li>\r\n</ol>\r\n<blockquote>\r\n<p>若想恢复无面具的系统，则按步骤5、6、7刷入从<code>镜像.zip</code>中提取的<code>boot.img</code></p>\r\n</blockquote>\r\n<h2 id=\"刷机包汇总\">刷机包汇总</h2>\r\n<p>MIUI<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Arrow OS<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a></p>\r\n<p>Lineage OS<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a></p>\r\n<p>TWRP<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p><a href=\"https://github.com/xiaoleGun/android_device_xiaomi_wayne-4.19\">KaleidoscopeOS-unofficial</a></p>\r\n<h2 id=\"恢复系统\">恢复系统</h2>\r\n<ol type=\"1\">\r\n<li>下载系统包（线刷包）；</li>\r\n<li>解压系统包（解压两次，直到出现文件夹）</li>\r\n<li>手机重启进入fastboot模式</li>\r\n<li>连接电脑，打开小米手机助手，点击加载设备，并选择文件夹（第2步解压的文件夹）</li>\r\n<li>点击刷机即可以恢复原系统。</li>\r\n</ol>\r\n<blockquote>\r\n<p>右下角可以选择全部删除、保留用户数据、全部删除并lock三个选项，若选择<code>全部删除并lock</code>，则需要重新解bootloader。</p>\r\n</blockquote>\r\n<section class=\"footnotes\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\" role=\"doc-endnote\"><p><a href=\"https://magiskcn.com/\" class=\"uri\">https://magiskcn.com/</a><a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\" role=\"doc-endnote\"><p>https://web.vip.miui.com/page/info/mio/mio/detail?postId=5876321&amp;app_version=dev.20051<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\" role=\"doc-endnote\"><p>https://arrowos.net/download<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\" role=\"doc-endnote\"><p>https://download.lineageos.org/wayne<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\" role=\"doc-endnote\"><p>https://dl.twrp.me/wayne/<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","categories":["Life"],"tags":["刷机"]},{"title":"运行时压缩","url":"/2022/09/12/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/","content":"<p>运行时压缩器是针对可执行文件而言的，可执行文件内含有解压缩代码。 运行时压缩文件也是PE文件，内部含有PE文件与解码程序。 将普通文件创建成运行时压缩文件的程序称为“压缩器（Packer）”，经反逆向（Anti-Reversing）技术特别处理的压缩器称为保护器（Protector）。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"压缩器\">1.压缩器</h2>\r\n<ol type=\"1\">\r\n<li>使用目的\r\n<ol type=\"1\">\r\n<li>减少PE文件的大小</li>\r\n<li>隐藏PE文件内部代码与资源</li>\r\n</ol></li>\r\n<li>使用现状 使用较为广泛，现实实用程序，打补丁文件，普通程序广泛使用运行时压缩</li>\r\n<li>压缩器种类</li>\r\n</ol>\r\n<blockquote>\r\n<p>目的纯粹的压缩器：UPX，ASPack等 目的不存的压缩器：UPack，PESpin、NSAnti等</p>\r\n</blockquote>\r\n<h2 id=\"保护器\">2. 保护器</h2>\r\n<p>PE保护器一类保护PE文件免受代码逆向分析的实用程序。不仅对PE文件进行运行时压缩，同时应用了多种防逆向技术（反调试、反模拟、代码混淆、多态代码、垃圾代码、调试器监视等）。</p>\r\n<ol type=\"1\">\r\n<li><p>使用目的</p>\r\n<ol type=\"1\">\r\n<li>防止破解</li>\r\n<li>保护代码与资源</li>\r\n</ol></li>\r\n<li><p>使用现状</p>\r\n<p>大量运用于对破解很敏感的程序，例如游戏和恶意代码</p></li>\r\n<li><p>保护器种类</p></li>\r\n</ol>\r\n<blockquote>\r\n<p>商用保护器：ASProtect、Themida、SVKP等 公用保护器：UltraProtect、Morphine等</p>\r\n</blockquote>\r\n","categories":["逆向工程核心原理"],"tags":["book","reverse"]},{"title":"cache映射种类","url":"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/","content":"<p>Cache的容量很小，它保存的内容只是主存内容的一个子集，且Cache与主存的数据交换是以块为单位的。为了把信息放到Cache中，必须应用某种函数把主存地址定位到Cache中，这称为地址映射。在信息按这种映射关系装入Cache后，CPU执行程序时，会将程序中的主存地址变换成Cache地址，这个变换过程叫做地址变换。</p>\r\n<p>Cache的地址映射方式有直接映射、全相联映射和组相联映射。假设某台计算机主存容量为l MB，被分为2048块，每块512B；Cache容量为8KB，被分为16块，每块也是512B。下面以此为例介绍三种基本的地址映射方法。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"直接映射\">直接映射</h2>\r\n<p>直接映射的Cache组织如图3-14所示。主存中的一个块只能映射到Cache的某一特定块中去。例如，主存的第0块、第16块、……、第2032块，只能映射到Cache的第0块；而主存的第1块、第17块、……、第2033块，只能映射到Cache的第1块……。</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/8c5e6e14f8f446c1bbaa5927a8e7c74a-16630354709608.gif\" alt=\"8c5e6e14f8f446c1bbaa5927a8e7c74a\"><figcaption aria-hidden=\"true\">8c5e6e14f8f446c1bbaa5927a8e7c74a</figcaption>\r\n</figure>\r\n<p>直接映射是最简单的地址映射方式，它的硬件简单，成本低，地址变换速度快，而且不涉及替换<code>算法</code>问题。但是这种方式不够灵活，Cache的存储空间得不到充分利用，每个主存块只有一个固定位置可存放，容易产生冲突，使Cache效率下降，因此只适合大容量Cache采用。例如，如果一个程序需要重复引用主存中第0块与第16块，最好将主存第0块与第16块同时复制到Cache中，但由于它们都只能复制到Cache的第0块中去，即使Cache中别的存储空间空着也不能占用，因此这两个块会不断地交替装入Cache中，导致命中率降低。</p>\r\n<h2 id=\"全相联映射\">全相联映射</h2>\r\n<p>图3-15 是全相联映射的Cache组织，主存中任何一块都可以映射到Cache中的任何一块位置上。</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/909b5be8dccb4c7e96824a364371363f-166303548562910.gif\" alt=\"909b5be8dccb4c7e96824a364371363f\"><figcaption aria-hidden=\"true\">909b5be8dccb4c7e96824a364371363f</figcaption>\r\n</figure>\r\n<p>全相联映射方式比较灵活，主存的各块可以映射到Cache的任一块中，Cache的利用率高，块冲突概率低，只要淘汰Cache中的某一块，即可调入主存的任一块。但是，由于Cache比较电路的设计和实现比较困难，这种方式只适合于小容量Cache采用。</p>\r\n<h2 id=\"组相联映射\">组相联映射</h2>\r\n<p>组相联映射实际上是直接映射和全相联映射的折中方案，其组织结构如图3-16所示。主存和Cache都分组，主存中一个组内的块数与Cache中的分组数相同，组间采用直接映射，组内采用全相联映射。也就是说，将Cache分成u组，每组v块，主存块存放到哪个组是固定的，至于存到该组哪一块则是灵活的。例如，主存分为256组，每组8块，Cache分为8组，每组2块。</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/7be3283b8b02490ba52cae653dfde1a0-166303550540612.gif\" alt=\"7be3283b8b02490ba52cae653dfde1a0\"><figcaption aria-hidden=\"true\">7be3283b8b02490ba52cae653dfde1a0</figcaption>\r\n</figure>\r\n<p>主存中的各块与Cache的组号之间有固定的映射关系，但可自由映射到对应Cache组中的任何一块。例如，主存中的第0块、第8块……均映射于Cache的第0组，但可映射到Cache第0组中的第0块或第1块；主存的第1块、第9块……均映射于Cache的第1组，但可映射到Cache第1组中的第2块或第3块。</p>\r\n<p>常采用的组相联结构Cache，每组内有2、4、8、16块，称为2路、4路、8路、16路组相联Cache。组相联结构Cache是前两种方法的折中方案，适度兼顾二者的优点，尽量避免二者的缺点，因而得到普遍采用。</p>\r\n<h2 id=\"一次内存访问示意图\">一次内存访问示意图</h2>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/c2e354808af84ebf84c680839586de22-166303551596014.png\" alt=\"c2e354808af84ebf84c680839586de22\"><figcaption aria-hidden=\"true\">c2e354808af84ebf84c680839586de22</figcaption>\r\n</figure>\r\n<p><strong>注意事项</strong></p>\r\n<ul>\r\n<li><p>TLB采用组相联</p></li>\r\n<li><p>页表采用两级页表</p></li>\r\n<li><p>cache采用组相联</p></li>\r\n<li><p>cache仅考虑L1 d-cache，不考虑L1 i-cache、L2 cache和L3 cache</p></li>\r\n<li><p>未考虑页表缺页</p></li>\r\n<li><p>简化了cache未命中情况</p></li>\r\n</ul>\r\n<h2 id=\"实际例子\">实际例子</h2>\r\n<p>下面展示了现代Intel处理器的CPU cache是如何组织的。有关cache的讨论往往缺乏具体的实例，使得一些简单的概念变得扑朔迷离。也许是我可爱的小脑瓜有点迟钝吧，但不管怎样，至少下面讲述了故事的前一半，即Core 2的 L1 cache是如何被访问的：</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/abc64a76ead74d5b97faa28fa3359f76-166303553065116.png\" alt=\"abc64a76ead74d5b97faa28fa3359f76\"><figcaption aria-hidden=\"true\">abc64a76ead74d5b97faa28fa3359f76</figcaption>\r\n</figure>\r\n<p>​ L1 cache – 32KB，8路组相联，64字节缓存线</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/7703ebdd1f544637bd7a253cfe7b6cd5-166303554265218.png\" alt=\"7703ebdd1f544637bd7a253cfe7b6cd5\"><figcaption aria-hidden=\"true\">7703ebdd1f544637bd7a253cfe7b6cd5</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/6fd3941001bf4fa7a759caa5c6f0e38d-166303555491920.jpg\" alt=\"6fd3941001bf4fa7a759caa5c6f0e38d\"><figcaption aria-hidden=\"true\">6fd3941001bf4fa7a759caa5c6f0e38d</figcaption>\r\n</figure>\r\n<h3 id=\"由索引拣选缓存组行\">1. 由索引拣选缓存组（行）</h3>\r\n<p>在cache中的数据是以<strong>缓存线</strong>（line）为单位组织的，一条缓存线对应于内存中一个连续的字节块。这个cache使用了64字节的缓存线。这些线被保存在cache bank中，也叫<strong>路</strong>（way）。每一路都有一个专门的<strong>目录</strong>（directory）用来保存一些登记信息。你可以把每一路连同它的目录想象成电子表格中的一列，而表的一行构成了cache的一<strong>组</strong>（set）。列中的每一个单元（cell）都含有一条缓存线，由与之对应的目录单元跟踪管理。图中的cache有64 组、每组8路，因此有512个含有缓存线的单元，合计32KB的存储空间。</p>\r\n<p>在cache眼中，物理内存被分割成了许多4KB大小的物理内存页（page）。每一页都含有<code>4KB / 64 bytes</code> == 64条缓存线。在一个4KB的页中，第0到63字节是第一条缓存线，第64到127字节是第二条缓存线，以此类推。每一页都重复着这种划分，所以第0页第3条缓存线与第1页第3条缓存线是不同的。</p>\r\n<p>在<strong>全相联缓存</strong>（fully associative cache）中，内存中的任意一条缓存线都可以被存储到任意的缓存单元中。这种存储方式十分灵活，但也使得要访问它们时，检索缓存单元的工作变得复杂、昂贵。由于L1和L2 cache工作在很强的约束之下，包括功耗，芯片物理空间，存取速度等，所以在多数情况下，使用全相联缓存并不是一个很好的折中。</p>\r\n<p>取而代之的是图中的<strong>组相联缓存</strong>（set associative cache）。意思是，内存中一条给定的缓存线只能被保存在一个特定的组（或行）中。所以，<em>任意</em>物理内存页的第0条缓存线（页内第0到63字节）<strong>必须</strong>存储到第0组，第1条缓存线存储到第1组，以此类推。每一组有8个单元可用于存储它所关联的缓存线，从而形成一个8路关联的组（8-way associative set）。当访问一个内存地址时，地址的第6到11位（译注：组索引）指出了在4KB内存页中缓存线的编号，从而决定了即将使用的缓存组。举例来说，物理地址0x800010a0的组索引是<code>000010</code>，所以此地址的内容一定是在第2组中缓存的。</p>\r\n<p>但是还有一个问题，就是要找出一组中<em>哪个</em>单元包含了想要的信息，如果有的话。这就到了缓存目录登场的时刻。每一个缓存线都被其对应的目录单元做了<em>标记</em>（tag）；这个标记就是一个简单的内存页编号，指出缓存线来自于哪一页。由于处理器可以寻址64GB的物理RAM，所以总共有<code>64GB / 4KB</code> == 224个内存页，需要24位来保存标记。前例中的物理地址0x800010a0对应的页号为<code>524,289</code>。下面是故事的后一半：</p>\r\n<p>​</p>\r\n<figure>\r\n<img src=\"/2022/09/13/cache%E6%98%A0%E5%B0%84%E7%A7%8D%E7%B1%BB/96bca75190ac4c30bb24425483fa2b6f-166303556809422.png\" alt=\"96bca75190ac4c30bb24425483fa2b6f\"><figcaption aria-hidden=\"true\">96bca75190ac4c30bb24425483fa2b6f</figcaption>\r\n</figure>\r\n<h3 id=\"在组中搜索匹配标记\">2、在组中搜索匹配标记</h3>\r\n<p>由于我们只需要去查看某一组中的8路，所以查找匹配标记是非常迅速的；事实上，从电学角度讲，所有的标记是同时进行比对的，我用箭头来表示这一点。如果此时正好有一条具有匹配标签的有效缓存线，我们就获得一次缓存命中（cache hit）。否则，这个请求就会被转发的L2 cache，如果还没匹配上就再转发给主系统内存。通过应用各种调节尺寸和容量的技术，Intel给CPU配置了较大的L2 cache，但其基本的设计都是相同的。比如，你可以将原先的缓存增加8路而获得一个64KB的缓存；再将组数增加到4096，每路可以存储<code>256KB</code>。经过这两次修改，就得到了一个4MB的L2 cache。在此情况下，需要18位来保存标记，12位保存组索引；缓存所使用的物理内存页的大小与其一路的大小相等。（译注：有4096组，就需要lg(4096)==12位的组索引，缓存线依然是64字节，所以一路有4096*64B==256KB字节；在L2 cache眼中，内存被分割为许多256KB的块，所以需要lg(64GB/256KB)==18位来保存标记。）</p>\r\n<p>如果有一组已经被放满了，那么在另一条缓存线被存储进来之前，已有的某一条则必须被腾空（evict）。为了避免这种情况，对运算速度要求较高的程序就要尝试仔细组织它的数据，使得内存访问均匀的分布在已有的缓存线上。举例来说，假设程序中有一个数组，元素的大小是512字节，其中一些对象在内存中相距4KB。这些对象的各个字段都落在同一缓存线上，并竞争同一缓存组。如果程序频繁的访问一个给定的字段（比如，通过<code>虚函数表</code>调用虚函数），那么这个组看起来就好像一直是被填满的，缓存开始变得毫无意义，因为缓存线一直在重复着腾空与重新载入的步骤。在我们的例子中，由于组数的限制，L1 cache仅能保存8个这类对象的虚函数表。这就是组相联策略的折中所付出的代价：即使在整体缓存的使用率并不高的情况下，由于组冲突，我们还是会遇到缓存缺失的情况。然而，鉴于计算机中各个存储层次的<code>相对速度</code>，不管怎么说，大部分的应用程序并不必为此而担心。</p>\r\n<p>一个内存访问经常由一个线性（或虚拟）地址发起，所以L1 cache需要依赖分页单元（paging unit）来求出物理内存页的地址，以便用于缓存标记。与此相反，组索引来自于线性地址的低位，所以不需要转换就可以使用了（在我们的例子中为第6到11位）。因此L1 cache是物理标记但虚拟索引的（<strong>physically tagged</strong> but <strong>virtually indexed</strong>），从而帮助CPU进行并行的查找操作。因为L1 cache的一路绝不会比MMU的一页还大，所以可以保证一个给定的物理地址位置总是关联到同一组，即使组索引是虚拟的。在另一方面L2 cache必须是物理标记和物理索引的，因为它的一路比MMU的一页要大。但是，当一个请求到达L2 cache时，物理地址已经被L1 cache准备（resolved）完毕了，所以L2 cache会工作得很好。</p>\r\n<p>最后，目录单元还存储了对应缓存线的<em>状态</em>（state）。在L1代码缓存中的一条缓存线要么是无效的（invalid）要么是共享的（shared，意思是有效的，真的J）。在L1数据缓存和L2缓存中，一条缓存线可以为4个MESI状态之一：被修改的（modified），独占的（exclusive），共享的（shared），无效的（invalid）。Intel缓存是包容式的（<strong>inclusive</strong>）：L1缓存的内容会被复制到L2缓存中。</p>\r\n<h2 id=\"总结\">总结</h2>\r\n<ol type=\"1\">\r\n<li><p>内存层次结构的意义在于利用引用的空间局部性和时间局部性原理，将经常被访问的数据放到快速的存储器中，而将不经常访问的数据留在较慢的存储器中。</p></li>\r\n<li><p>一般情况下，除了寄存器和L1缓存可以操作指定字长的数据，下层的内存子系统就不会再使用这么小的单位了，而是直接移动数据块，比如以缓存线为单位访问数据。</p></li>\r\n<li><p>对于组冲突，可以这么理解：与上文相似，假设一个缓存，由512条缓存线组成，每条线64字节，容量32KB。</p>\r\n<ol type=\"1\">\r\n<li>假如它是直接映射缓存，由于它往往使用地址的低位直接映射缓存线编号，所以所有的32K倍数的地址（32K，64K，96K等）都会映射到同一条线上（即第0线）。假如程序的内存组织不当，交替的去访问布置在这些地址的数据，则会导致冲突。从外表看来就好像缓存只有1条线了，尽管其他缓存线一直是空闲着的。</li>\r\n<li>如果是全相联缓存，那么每条缓存线都是独立的，可以对应于内存中的任意缓存线。只有当所有的512条缓存线都被占满后才会出现冲突。</li>\r\n<li>组相联是前两者的折中，每一路中的缓存线采用直接映射方式，而在路与路之间，缓存控制器使用全相联映射算法，决定选择一组中的哪一条线。</li>\r\n<li>如果是2路组相联缓存，那么这512条缓存线就被分为了2路，每路256条线，一路16KB。此时所有为16K整数倍的地址（16K，32K，48K等）都会映射到第0线，但由于2路是关联的，所以可以同时有2个这种地址的内容被缓存，不会发生冲突。当然了，如果要访问第三个这种地址，还是要先腾空已有的一条才行。所以极端情况下，从外表看来就好像缓存只有2条线了，尽管其他缓存线一直是空闲着的。</li>\r\n<li>如果是8路组相联缓存（与文中示例相同），那么这512条缓存线就被分为了8路，每路64条线，一路4KB。所以如果数组中元素地址是4K对齐的，并且程序交替的访问这些元素，就会出现组冲突。从外表看来就好像缓存只有8条线了，尽管其他缓存线一直是空闲着的。</li>\r\n</ol></li>\r\n</ol>\r\n<p><a href=\"https://my.oschina.net/fileoptions/blog/1630855\">原文链接</a></p>\r\n","categories":["Computer Architecture"],"tags":["cache","arch"]},{"title":"侧信道攻击","url":"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/","content":"<p>侧信道主要是指通过非直接途径泄露物理状态信息，攻击者通过测量采集,继而恢复出敏感数据。现代CPU内通常包含有缓存结构，攻击者通过侧信道方法获取缓存信息，就有可能窃取到隐私信息，这里主要介绍四种侧信道攻击方法：</p>\r\n<ol type=\"1\">\r\n<li>Flush-Reload</li>\r\n<li>Flush-Flush</li>\r\n<li>Prime-Probe</li>\r\n<li>Evict-Time</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h2 id=\"flush-reload\">Flush-Reload</h2>\r\n<p>Flush-Reload（FR）方法是prime-probe方法的变种，基于共享内存实现，是一种跨内核、跨虚拟机的Cache 探测方法。在Flush 阶段，攻击者将监控的内存块从cache中驱逐出去，然后在Trigger阶段等待目标用户访问共享内存。在Reload阶段，攻击者重新加载监控的共享内存块。如果在等待的期间，目标虚拟机访问过的内存块不需要重新加载，时间将会较短，因为这些数据已经被缓存在cache中。根据加载时间长短，可判定目标虚拟机访问过的数据。Flush-Reload具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>Flush：将共享内存中特定位置映射的cache数据驱逐</li>\r\n<li>Trigger：等待目标虚拟机响应服务请求，更新Cache</li>\r\n<li>Reload：重新加载Flush阶段驱逐的内存块，测量并记录cache组的重载时间</li>\r\n</ol>\r\n<p>攻击原理如下：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/image-20220913100403942.png\" alt=\"image-20220913100403942\"><figcaption aria-hidden=\"true\">image-20220913100403942</figcaption>\r\n</figure>\r\n<h2 id=\"flush-flush\">Flush-Flush</h2>\r\n<p>与Flush-Reload不同的是，Flush-Flush攻击是基于clflush指令执行时间的长短来实施攻击的。如果数据没在Cache中则clflush指令执行时间会比较短，反之若有数据在cache中则执行时间会比较长。与其它Cache攻击不同，Flush Flush侧信道攻击技术在整个攻击过程中是不需要对内存进行存取的，因此该攻击技术更加隐蔽。然而根据我们的经验，由于有无数据情况下Cache被flush的时间差别其实并非特别明显，因此在攻击过程中数据判断的精度并不高。Flush-Flush具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>通过flush清空Cache原始数据</li>\r\n<li>等待目标进程运行，更新Cache，并刷新共享缓存行，测量刷新时间</li>\r\n<li>根据测量时间判断原始数据是否被缓存</li>\r\n</ol>\r\n<p>该方法攻击原理如图所示：</p>\r\n<figure>\r\n<img src=\"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/image-20220913100418534-16630346610926.png\" alt=\"image-20220913100418534\"><figcaption aria-hidden=\"true\">image-20220913100418534</figcaption>\r\n</figure>\r\n<h2 id=\"prime-probe\">Prime-Probe</h2>\r\n<p>Prime-Probe方法具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>Prime: 攻击者用预先准备的数据填充特定多个cache 组</li>\r\n<li>Trigger: 等待目标虚拟机响应服务请求，将cache数据更新</li>\r\n<li>Probe: 重新读取Prime 阶段填充的数据，测量并记录各个cache 组读取时间</li>\r\n</ol>\r\n<figure>\r\n<img src=\"/2022/09/13/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/image-20220913100429757.png\" alt=\"image-20220913100429757\"><figcaption aria-hidden=\"true\">image-20220913100429757</figcaption>\r\n</figure>\r\n<h2 id=\"evict-time\">Evict-Time</h2>\r\n<p>Evict-Time方法具体步骤如下：</p>\r\n<ol type=\"1\">\r\n<li>暂无</li>\r\n<li>等待目标程序运行，并记录其运行时间（运行过程有可能使用到第一步所说的Cache数据）</li>\r\n<li>使用Evict方法覆盖Cache上的数据</li>\r\n<li>然后再运行一次该函数，并第二次记录执行时间，如果时间不一致且执行时间变长则说明程序运行时读取了第一步所说的Cache数据（Cache未命中）</li>\r\n</ol>\r\n<p>与其他三种侧信道攻击技术相比，Evict-Time不是当前主流的侧信道攻击技术。</p>\r\n","categories":["Security"],"tags":["cache","side-channel"]}]